<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet href="file:///C|/Users/legat/Desktop/skriptanje-sa-kaizerom/pawno/xml/pawndoc.xsl" type="text/xsl"?>
<doc source="c:\Users\legat\Desktop\skriptanje-sa-kaizerom\gamemodes\TR.pwn">
	<assembly>
		<name>TR.pwn</name>
	</assembly>

	<!-- general -->
	<general>
		MySQL plugin R41-4 <p/> <library name="y_utils">  <section>  Description  </section>  Misc functions used throughout.  <section>  Version  </section>  0.1.3  <section>  Functions  </section>  <subsection>Stock</subsection>  <ul>  <symbol name="StrToLower">Convert a whole string to lower-case.</symbol>  <symbol name="StrToUpper">Convert a whole string to upper-case.</symbol>  <symbol name="Random">Generate a random number, optionally takes lower and upper bounds.</symbol>  <symbol name="RandomFloat">Same as <symbolref name="Random" />, but for floats.</symbol>  <symbol name="StripNL">Strips the newline characters from the end of a string.</symbol>  <symbol name="StripL">Remove whitespace from the start of a string.</symbol>  <symbol name="Strip">Remove whitespace from both ends of a string.</symbol>  <symbol name="endofline">Check if the given position is the end of a string (ignoring whitespace).</symbol>  <symbol name="chrfind">Return the first position (after <symbolref name="start" />) of the given character.</symbol>  <symbol name="chrfindp">Like <symbolref name="chrfind" />, but without the upper-bounds check.</symbol>  <symbol name="bernstein">Generate the Bernstein hash of the given string.</symbol>  <symbol name="ishex">Is the given string hexadecimal?</symbol>  <symbol name="unpack">Version of <symbolref name="strunpack" /> that returns the result.</symbol>  <symbol name="returnstringarg">Get the string passed as a variable argument from the given index.</symbol>  <symbol name="va_return">Like <symbolref name="sprintf" />, formats a string and returns the result.</symbol>  <symbol name="isnumeric">Is the given string a number?</symbol>  <symbol name="hexstr">Return the value of the given hexadecimal string.</symbol>  <symbol name="boolstr">Return the value of the given boolean string.</symbol>  <symbol name="binstr">Return the value of the given binary string.</symbol>  <symbol name="rawMemcpy">Copy memory between two address, instead of two arrays.</symbol>  <symbol name="memset">Set all of an array to a value.</symbol>  <symbol name="rawMemset">Set all of a given memory region to a value.</symbol>  <symbol name="ReturnPlayerName">Return a player's name.</symbol>  <symbol name="ftouch">Ensures that a file exists, but nothing more.</symbol>  <symbol name="InterpolateColour">Get the colour (in 3D RGB space) between two other colours.</symbol>  <symbol name="SkipWhitespace">Return the first position in a string of a non-whitespace character.</symbol>  <symbol name="Trim">Get the first and last positions of non-whitespace characters in the string.  Like  <symbolref name="Strip" />, but doesn't modify the string.</symbol>  <symbol name="Sum">Get the total (sum) of an array.</symbol>  <symbol name="Mean">Get the mathematical mean of an array.</symbol>  <symbol name="Mode">Get the mathematical mode of an array.</symbol>  <symbol name="Median">Get the mathematical median of an array.</symbol>  <symbol name="Range">Get the mathematical range of an array.</symbol>  </ul>  <subsection>Inline</subsection>  <ul>  <symbol name="UCMP">Unsigned compare.</symbol>  <symbol name="VALID_PLAYERID">Check if a player ID is valid (in range).</symbol>  <symbol name="IS_IN_RANGE">Check if a number is in range.</symbol>  <symbol name="NOT_IN_RANGE">Check if a number is outside a range.</symbol>  <symbol name="ceildiv">Divide two numbers and round up.</symbol>  <symbol name="floordiv">Divide two numbers and round down.</symbol>  <symbol name="isnull">Checks if a string is NULL (<c>\1\0</c> or <c>\0</c>).</symbol>  <symbol name="isodd">Checks if a number is odd.</symbol>  <symbol name="iseven">Checks if a number is even.</symbol>  <symbol name="strcpy">Copy one string to another.</symbol>  <symbol name="GetIP">Return the encoded (32-bit) version of a player's IP.</symbol>  <synonym name="getstring" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="GetString" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="getstringarg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="GetStringArg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="ReturnStringArg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="InterpolateColor" for="InterpolateColour" />  <synonym name="StripR" for="StripNL" />  </ul>  <section>  Variables  </section>  <subsection>Global</subsection>  <ul>  <symbol name="TRUE">True hack for infinate loops.</symbol>  <symbol name="FALSE">False hack for one-time loops.</symbol>  <symbol name="NULL">1 long string for passing via Call(Remote|Local)Function.</symbol>  </ul>  </library> <p/> <library name="y_va">  <section>  Description  </section>  This library currently provides two functions - va_printf and va_format  which perform printf and format using variable arguments passed to another  function.  This is bsed on the variable parameter passing method based on code by Zeex.  See page 15 of the code optimisations topic.  <section>  Version  </section>  1.0  </library> <p/> <library name="y_utils">  <section>  Description  </section>  Misc functions used throughout.  <section>  Version  </section>  0.1.3  <section>  Functions  </section>  <subsection>Stock</subsection>  <ul>  <symbol name="StrToLower">Convert a whole string to lower-case.</symbol>  <symbol name="StrToUpper">Convert a whole string to upper-case.</symbol>  <symbol name="Random">Generate a random number, optionally takes lower and upper bounds.</symbol>  <symbol name="RandomFloat">Same as <symbolref name="Random" />, but for floats.</symbol>  <symbol name="StripNL">Strips the newline characters from the end of a string.</symbol>  <symbol name="StripL">Remove whitespace from the start of a string.</symbol>  <symbol name="Strip">Remove whitespace from both ends of a string.</symbol>  <symbol name="endofline">Check if the given position is the end of a string (ignoring whitespace).</symbol>  <symbol name="chrfind">Return the first position (after <symbolref name="start" />) of the given character.</symbol>  <symbol name="chrfindp">Like <symbolref name="chrfind" />, but without the upper-bounds check.</symbol>  <symbol name="bernstein">Generate the Bernstein hash of the given string.</symbol>  <symbol name="ishex">Is the given string hexadecimal?</symbol>  <symbol name="unpack">Version of <symbolref name="strunpack" /> that returns the result.</symbol>  <symbol name="returnstringarg">Get the string passed as a variable argument from the given index.</symbol>  <symbol name="va_return">Like <symbolref name="sprintf" />, formats a string and returns the result.</symbol>  <symbol name="isnumeric">Is the given string a number?</symbol>  <symbol name="hexstr">Return the value of the given hexadecimal string.</symbol>  <symbol name="boolstr">Return the value of the given boolean string.</symbol>  <symbol name="binstr">Return the value of the given binary string.</symbol>  <symbol name="rawMemcpy">Copy memory between two address, instead of two arrays.</symbol>  <symbol name="memset">Set all of an array to a value.</symbol>  <symbol name="rawMemset">Set all of a given memory region to a value.</symbol>  <symbol name="ReturnPlayerName">Return a player's name.</symbol>  <symbol name="ftouch">Ensures that a file exists, but nothing more.</symbol>  <symbol name="InterpolateColour">Get the colour (in 3D RGB space) between two other colours.</symbol>  <symbol name="SkipWhitespace">Return the first position in a string of a non-whitespace character.</symbol>  <symbol name="Trim">Get the first and last positions of non-whitespace characters in the string.  Like  <symbolref name="Strip" />, but doesn't modify the string.</symbol>  <symbol name="Sum">Get the total (sum) of an array.</symbol>  <symbol name="Mean">Get the mathematical mean of an array.</symbol>  <symbol name="Mode">Get the mathematical mode of an array.</symbol>  <symbol name="Median">Get the mathematical median of an array.</symbol>  <symbol name="Range">Get the mathematical range of an array.</symbol>  </ul>  <subsection>Inline</subsection>  <ul>  <symbol name="UCMP">Unsigned compare.</symbol>  <symbol name="VALID_PLAYERID">Check if a player ID is valid (in range).</symbol>  <symbol name="IS_IN_RANGE">Check if a number is in range.</symbol>  <symbol name="NOT_IN_RANGE">Check if a number is outside a range.</symbol>  <symbol name="ceildiv">Divide two numbers and round up.</symbol>  <symbol name="floordiv">Divide two numbers and round down.</symbol>  <symbol name="isnull">Checks if a string is NULL (<c>\1\0</c> or <c>\0</c>).</symbol>  <symbol name="isodd">Checks if a number is odd.</symbol>  <symbol name="iseven">Checks if a number is even.</symbol>  <symbol name="strcpy">Copy one string to another.</symbol>  <symbol name="GetIP">Return the encoded (32-bit) version of a player's IP.</symbol>  <synonym name="getstring" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="GetString" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="getstringarg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="GetStringArg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="ReturnStringArg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="InterpolateColor" for="InterpolateColour" />  <synonym name="StripR" for="StripNL" />  </ul>  <section>  Variables  </section>  <subsection>Global</subsection>  <ul>  <symbol name="TRUE">True hack for infinate loops.</symbol>  <symbol name="FALSE">False hack for one-time loops.</symbol>  <symbol name="NULL">1 long string for passing via Call(Remote|Local)Function.</symbol>  </ul>  </library> <p/> <param name="expr"><code>var : Iterator</code></param>  <remarks>  </remarks> <p/> <library name="y_hooks">  <section>  Description  </section>  Automatically hooks any callbacks with a very simple syntax.  <section>  Version  </section>  2.0  </library> <p/> <library name="y_utils">  <section>  Description  </section>  Misc functions used throughout.  <section>  Version  </section>  0.1.3  <section>  Functions  </section>  <subsection>Stock</subsection>  <ul>  <symbol name="StrToLower">Convert a whole string to lower-case.</symbol>  <symbol name="StrToUpper">Convert a whole string to upper-case.</symbol>  <symbol name="Random">Generate a random number, optionally takes lower and upper bounds.</symbol>  <symbol name="RandomFloat">Same as <symbolref name="Random" />, but for floats.</symbol>  <symbol name="StripNL">Strips the newline characters from the end of a string.</symbol>  <symbol name="StripL">Remove whitespace from the start of a string.</symbol>  <symbol name="Strip">Remove whitespace from both ends of a string.</symbol>  <symbol name="endofline">Check if the given position is the end of a string (ignoring whitespace).</symbol>  <symbol name="chrfind">Return the first position (after <symbolref name="start" />) of the given character.</symbol>  <symbol name="chrfindp">Like <symbolref name="chrfind" />, but without the upper-bounds check.</symbol>  <symbol name="bernstein">Generate the Bernstein hash of the given string.</symbol>  <symbol name="ishex">Is the given string hexadecimal?</symbol>  <symbol name="unpack">Version of <symbolref name="strunpack" /> that returns the result.</symbol>  <symbol name="returnstringarg">Get the string passed as a variable argument from the given index.</symbol>  <symbol name="va_return">Like <symbolref name="sprintf" />, formats a string and returns the result.</symbol>  <symbol name="isnumeric">Is the given string a number?</symbol>  <symbol name="hexstr">Return the value of the given hexadecimal string.</symbol>  <symbol name="boolstr">Return the value of the given boolean string.</symbol>  <symbol name="binstr">Return the value of the given binary string.</symbol>  <symbol name="rawMemcpy">Copy memory between two address, instead of two arrays.</symbol>  <symbol name="memset">Set all of an array to a value.</symbol>  <symbol name="rawMemset">Set all of a given memory region to a value.</symbol>  <symbol name="ReturnPlayerName">Return a player's name.</symbol>  <symbol name="ftouch">Ensures that a file exists, but nothing more.</symbol>  <symbol name="InterpolateColour">Get the colour (in 3D RGB space) between two other colours.</symbol>  <symbol name="SkipWhitespace">Return the first position in a string of a non-whitespace character.</symbol>  <symbol name="Trim">Get the first and last positions of non-whitespace characters in the string.  Like  <symbolref name="Strip" />, but doesn't modify the string.</symbol>  <symbol name="Sum">Get the total (sum) of an array.</symbol>  <symbol name="Mean">Get the mathematical mean of an array.</symbol>  <symbol name="Mode">Get the mathematical mode of an array.</symbol>  <symbol name="Median">Get the mathematical median of an array.</symbol>  <symbol name="Range">Get the mathematical range of an array.</symbol>  </ul>  <subsection>Inline</subsection>  <ul>  <symbol name="UCMP">Unsigned compare.</symbol>  <symbol name="VALID_PLAYERID">Check if a player ID is valid (in range).</symbol>  <symbol name="IS_IN_RANGE">Check if a number is in range.</symbol>  <symbol name="NOT_IN_RANGE">Check if a number is outside a range.</symbol>  <symbol name="ceildiv">Divide two numbers and round up.</symbol>  <symbol name="floordiv">Divide two numbers and round down.</symbol>  <symbol name="isnull">Checks if a string is NULL (<c>\1\0</c> or <c>\0</c>).</symbol>  <symbol name="isodd">Checks if a number is odd.</symbol>  <symbol name="iseven">Checks if a number is even.</symbol>  <symbol name="strcpy">Copy one string to another.</symbol>  <symbol name="GetIP">Return the encoded (32-bit) version of a player's IP.</symbol>  <synonym name="getstring" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="GetString" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="getstringarg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="GetStringArg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="ReturnStringArg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="InterpolateColor" for="InterpolateColour" />  <synonym name="StripR" for="StripNL" />  </ul>  <section>  Variables  </section>  <subsection>Global</subsection>  <ul>  <symbol name="TRUE">True hack for infinate loops.</symbol>  <symbol name="FALSE">False hack for one-time loops.</symbol>  <symbol name="NULL">1 long string for passing via Call(Remote|Local)Function.</symbol>  </ul>  </library> <p/> <library name="y_hooks">  <section>  Description  </section>  Automatically hooks any callbacks with a very simple syntax.  <section>  Version  </section>  2.0  </library> <p/> <library name="y_remote">  <section>  Description  </section>  Wrapper for "__CallRemoteFunction".  Enforces some features like no returns  and arrays being followed by their length.  <section>  Version  </section>  1.0  <section>  Macros  </section><ul>  <symbol name="remotefunc">Define a function to be called remotely (use like "stock").</symbol>  <symbol name="broadcastfunc">Call the function, but in all scripts.</symbol>  <symbol name="localfunc">Call the function by name, not address, in the current script.</symbol>  </ul><section>Compile options</section><ul>  <symbol name="YSI_NO_MASTER">Disable all knowledge of other scripts.</symbol>  </ul>  </library> <p/> <library name="y_utils">  <section>  Description  </section>  Misc functions used throughout.  <section>  Version  </section>  0.1.3  <section>  Functions  </section>  <subsection>Stock</subsection>  <ul>  <symbol name="StrToLower">Convert a whole string to lower-case.</symbol>  <symbol name="StrToUpper">Convert a whole string to upper-case.</symbol>  <symbol name="Random">Generate a random number, optionally takes lower and upper bounds.</symbol>  <symbol name="RandomFloat">Same as <symbolref name="Random" />, but for floats.</symbol>  <symbol name="StripNL">Strips the newline characters from the end of a string.</symbol>  <symbol name="StripL">Remove whitespace from the start of a string.</symbol>  <symbol name="Strip">Remove whitespace from both ends of a string.</symbol>  <symbol name="endofline">Check if the given position is the end of a string (ignoring whitespace).</symbol>  <symbol name="chrfind">Return the first position (after <symbolref name="start" />) of the given character.</symbol>  <symbol name="chrfindp">Like <symbolref name="chrfind" />, but without the upper-bounds check.</symbol>  <symbol name="bernstein">Generate the Bernstein hash of the given string.</symbol>  <symbol name="ishex">Is the given string hexadecimal?</symbol>  <symbol name="unpack">Version of <symbolref name="strunpack" /> that returns the result.</symbol>  <symbol name="returnstringarg">Get the string passed as a variable argument from the given index.</symbol>  <symbol name="va_return">Like <symbolref name="sprintf" />, formats a string and returns the result.</symbol>  <symbol name="isnumeric">Is the given string a number?</symbol>  <symbol name="hexstr">Return the value of the given hexadecimal string.</symbol>  <symbol name="boolstr">Return the value of the given boolean string.</symbol>  <symbol name="binstr">Return the value of the given binary string.</symbol>  <symbol name="rawMemcpy">Copy memory between two address, instead of two arrays.</symbol>  <symbol name="memset">Set all of an array to a value.</symbol>  <symbol name="rawMemset">Set all of a given memory region to a value.</symbol>  <symbol name="ReturnPlayerName">Return a player's name.</symbol>  <symbol name="ftouch">Ensures that a file exists, but nothing more.</symbol>  <symbol name="InterpolateColour">Get the colour (in 3D RGB space) between two other colours.</symbol>  <symbol name="SkipWhitespace">Return the first position in a string of a non-whitespace character.</symbol>  <symbol name="Trim">Get the first and last positions of non-whitespace characters in the string.  Like  <symbolref name="Strip" />, but doesn't modify the string.</symbol>  <symbol name="Sum">Get the total (sum) of an array.</symbol>  <symbol name="Mean">Get the mathematical mean of an array.</symbol>  <symbol name="Mode">Get the mathematical mode of an array.</symbol>  <symbol name="Median">Get the mathematical median of an array.</symbol>  <symbol name="Range">Get the mathematical range of an array.</symbol>  </ul>  <subsection>Inline</subsection>  <ul>  <symbol name="UCMP">Unsigned compare.</symbol>  <symbol name="VALID_PLAYERID">Check if a player ID is valid (in range).</symbol>  <symbol name="IS_IN_RANGE">Check if a number is in range.</symbol>  <symbol name="NOT_IN_RANGE">Check if a number is outside a range.</symbol>  <symbol name="ceildiv">Divide two numbers and round up.</symbol>  <symbol name="floordiv">Divide two numbers and round down.</symbol>  <symbol name="isnull">Checks if a string is NULL (<c>\1\0</c> or <c>\0</c>).</symbol>  <symbol name="isodd">Checks if a number is odd.</symbol>  <symbol name="iseven">Checks if a number is even.</symbol>  <symbol name="strcpy">Copy one string to another.</symbol>  <symbol name="GetIP">Return the encoded (32-bit) version of a player's IP.</symbol>  <synonym name="getstring" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="GetString" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="getstringarg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="GetStringArg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="ReturnStringArg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="InterpolateColor" for="InterpolateColour" />  <synonym name="StripR" for="StripNL" />  </ul>  <section>  Variables  </section>  <subsection>Global</subsection>  <ul>  <symbol name="TRUE">True hack for infinate loops.</symbol>  <symbol name="FALSE">False hack for one-time loops.</symbol>  <symbol name="NULL">1 long string for passing via Call(Remote|Local)Function.</symbol>  </ul>  </library> <p/> <library name="y_iterate">  <section>  Description  </section>  Provides efficient looping through sparse data sets, such as connected  players.  Significantly improved from the original version to be a generic  loop system, rather then purely a player loop system.  When used for  players this has constant time O(n) for number of connected players (n),  unlike standard player loops which are O(MAX_PLAYERS), regardless of the  actual number of connected players.  Even when n is MAX_PLAYERS this is  still faster.  For extensive documentation on writing and using iterators, see this topic:  <a href="http://forum.sa-mp.com/showthread.php?t=481877" />  <section>  Version  </section>  0.4  <section>  Functions  </section>  <subsection>  Public  </subsection><ul>  <symbol name="OnPlayerDisconnect">Called when a player leaves to remove them.</symbol>  <symbol name="OnPlayerConnect">Called when a player connects to add them.</symbol>  </ul><subsection>  Stock  </subsection><ul>  <symbol name="Iter_ShowArray">Displays the contents of the array.</symbol>  <symbol name="Iter_AddInternal">Add a value to an iterator.</symbol>  <symbol name="Iter_RemoveInternal">Remove a value from an iterator.</symbol>  <symbol name="Iter_RandomInternal">Get a random item from an iterator.</symbol>  <symbol name="Iter_FreeInternal">Gets the first free slot in the iterator.</symbol>  <symbol name="Iter_InitInternal">Initialises a multi-dimensional iterator.</symbol>  </ul><subsection>  Inline  </subsection><ul>  <symbol name="Iter_Create">Create a new iterator value set.</symbol>  <symbol name="Iter_Add">Wraps Iter_AddInternal.</symbol>  <symbol name="Iter_Remove">Wraps Iter_RemoveInternal.</symbol>  <symbol name="Iter_Random">Wraps Iter_RandomInternal.</symbol>  <symbol name="Iter_Count">Gets the number of items in an iterator.</symbol>  <symbol name="Iter_Debug">Wraps around Iter_ShowArray.</symbol>  <symbol name="Iter_Free">Wraps around Iter_FreeInternal.</symbol>  <symbol name="Iter_Create2">Create a new iterator array value set.</symbol>  <symbol name="Iter_Add2">Wraps Iter_AddInternal for arrays.</symbol>  <symbol name="Iter_Remove2">Wraps Iter_RemoveInternal for arrays.</symbol>  <symbol name="Iter_Random2">Wraps Iter_RandomInternal for arrays.</symbol>  <symbol name="Iter_Count2">Gets the number of items in an iterator array.</symbol>  <symbol name="Iter_Debug2">Wraps around Iter_ShowArray for arrays.</symbol>  <symbol name="Iter_Free2">Wraps around Iter_FreeInternal for arrays.</symbol>  </ul><section>  Hooks  </section><ul>  <symbol name="Iter_OnPlayerConnect">Hook for the OnPlayerConnect callback.</symbol>  <symbol name="Iter_OnPlayerDisconnect">Hook for the OnPlayerDisconnect callback.</symbol>  <symbol name="Iter_OnGameModeInit">Only exists to make the code compile correctly...</symbol>  </ul><section>  Keywords  </section><ul>  <symbol name="foreach">Command to loop an iterator.</symbol>  <symbol name="foreachex">Like foreach but without a new variable.</symbol>  <symbol name="foreach2">Command to loop through an iterator array.</symbol>  <symbol name="foreachex">Like foreach2 but without a new variable.</symbol>  </ul><section>  Tags  </section><ul>  <symbol name="Iterator">Declare an iterator.</symbol>  </ul><section>  Variables  </section>  <subsection>  Static  </subsection><ul>  <symbol name="YSI_g_OPC">Records wether Iter_OnPlayerConnect exists for speed.</symbol>  <symbol name="YSI_g_OPDC">Records wether Iter_OnPlayerDisconnect exists for speed.</symbol>  </ul><section>Compile options</section><ul>  <symbol name="YSI_ITTER_NO_SORT">Removed.</symbol>  <symbol name="FOREACH_NO_BOTS">Remove the bot iterators for smaller code.</symbol>  <symbol name="FOREACH_NO_PLAYERS">Remove all default code for player itteration.</symbol>  </ul><section>  Iterators  </section><ul>  <symbol name="Player">List of all players connected.</symbol>  <symbol name="Bot">List of all bots (npcs) connected.</symbol>  <symbol name="NPC">Alias of Bot.</symbol>  <symbol name="Character">All players and bots.</symbol>  </ul><section>  Examples  </section>  <subsection>Basic Iterators</subsection>  <p>  Basic iterators are simply collections of numbers - little more than an array.  A number is either in the array, or not in the array, <em>y_iterate</em> loops  through only the <em>in</em> numbers.</p>  <p><em>Players</em><br /><br />  This code will loop through every player connected to the server.  <code>  foreach (new i : Player)																				<br />  {																				<br /><indent />  printf("player %d is connected", i);																				<br />  }  </code>  </p>  <p><em>Vehicles</em><br /><br />  This code will loop through all the created vehicles on the server (including  those made in other running scripts).  <code>  foreach (new vid : Vehicle)																				<br />  {																				<br /><indent />  printf("vehicleid %d has been created", vid);																				<br />  }  </code>  </p>  <p><em>Create An Iterator</em><br /><br />  To create your own iterator, first declare it, then add things to it, then loop  over it:  <code>  new																				<br /><indent />  Iterator:MyIter&lt;100&gt;; // First declare it (this has room for 100 items numbered 0-99).									 											<br />  // Then add things to it.																				<br />  Iter_Add(MyIter, 0);  // Fine.																				<br />  Iter_Add(MyIter, 55); // Fine.																				<br />  Iter_Add(MyIter, 100); // Will fail.																				<br />  // Then loop over it.																				<br />  foreach (new i : MyIter)																				<br />  {																				<br /><indent />  printf("%d", i); // Will print "0" then "55".																				<br />  }  </code>  </p>  <subsection>Special Iterators</subsection>  </library> <p/> <library name="y_va">  <section>  Description  </section>  This library currently provides two functions - va_printf and va_format  which perform printf and format using variable arguments passed to another  function.  This is bsed on the variable parameter passing method based on code by Zeex.  See page 15 of the code optimisations topic.  <section>  Version  </section>  1.0  </library> 
	</general>

	<members>

		<!-- enumerations -->
		<member name="T:AMX_FUNCSTUBNT" value="2">
			<tagname value="AMX_FUNCSTUBNT"/>
			<member name="C:AMX_FUNCSTUBNT_ADDRESS" value="0">
			</member>
			<member name="C:AMX_FUNCSTUBNT_NAMEOFS" value="1">
			</member>
			<referrer name="GetPublicAddressFromIndex"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeAddressFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarAddressFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagIDFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="IsTagIndexStrong"/>
			<referrer name="IsTagIndexWeak"/>
		</member>
		<member name="T:AMX_HDR" value="17">
			<tagname value="AMX_HDR"/>
			<member name="C:AMX_HDR_SIZE" value="0">
			</member>
			<member name="C:AMX_HDR_MAGIC" value="1">
			</member>
			<member name="C:AMX_HDR_FILE_VERSION" value="2">
			</member>
			<member name="C:AMX_HDR_AMX_VERSION" value="3">
			</member>
			<member name="C:AMX_HDR_FLAGS" value="4">
			</member>
			<member name="C:AMX_HDR_DEFSIZE" value="5">
			</member>
			<member name="C:AMX_HDR_COD" value="6">
			</member>
			<member name="C:AMX_HDR_DAT" value="7">
			</member>
			<member name="C:AMX_HDR_HEA" value="8">
			</member>
			<member name="C:AMX_HDR_STP" value="9">
			</member>
			<member name="C:AMX_HDR_CIP" value="10">
			</member>
			<member name="C:AMX_HDR_PUBLICS" value="11">
			</member>
			<member name="C:AMX_HDR_NATIVES" value="12">
			</member>
			<member name="C:AMX_HDR_LIBRARIES" value="13">
			</member>
			<member name="C:AMX_HDR_PUBVARS" value="14">
			</member>
			<member name="C:AMX_HDR_TAGS" value="15">
			</member>
			<member name="C:AMX_HDR_NAMETABLE" value="16">
			</member>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmInit"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="AsmGetJumpAddressFromOffset"/>
			<referrer name="AsmGetCode"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="AddressofResolveFoundStart"/>
			<referrer name="Indirect_Init"/>
			<referrer name="Hooks_OnCodeInit"/>
		</member>
		<member name="T:AsmContext" value="21">
			<tagname value="AsmContext"/>
			<member name="C:AsmContext_buffer" value="0">
			</member>
			<member name="C:AsmContext_buffer_size" value="1">
			</member>
			<member name="C:AsmContext_buffer_offset" value="2">
			</member>
			<member name="C:AsmContext_error" value="3">
			</member>
			<member name="C:AsmContext_error_handler" value="4">
			</member>
			<member name="C:AsmContext_label_names" value="5">
				<size value="8"/>
			</member>
			<member name="C:AsmContext_labels" value="13">
				<size value="8"/>
			</member>
			<referrer name="AddressofResolveFoundStart"/>
			<referrer name="AddressofResolveFoundEnd"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
		</member>
		<member name="T:CodeScanMatcher" value="171">
			<tagname value="CodeScanMatcher"/>
			<member name="C:CodeScanMatcher_func" value="0">
			</member>
			<member name="C:CodeScanMatcher_user_data" value="1">
			</member>
			<member name="C:CodeScanMatcher_code" value="2">
				<size value="128"/>
			</member>
			<member name="C:CodeScanMatcher_len" value="130">
			</member>
			<member name="C:CodeScanMatcher_offset" value="131">
				<size value="2"/>
			</member>
			<member name="C:CodeScanMatcher_start" value="133">
				<size value="2"/>
			</member>
			<member name="C:CodeScanMatcher_holeidx" value="135">
				<size value="2"/>
			</member>
			<member name="C:CodeScanMatcher_holes" value="137">
				<size value="32"/>
			</member>
			<member name="C:CodeScanMatcher_next" value="169">
			</member>
			<member name="C:CodeScanMatcher_flags" value="170">
			</member>
			<referrer name="CodeScanDeref"/>
			<referrer name="AddressofResolve"/>
			<referrer name="YVA2_Initalise"/>
		</member>
		<member name="T:CodeScanner" value="164">
			<tagname value="CodeScanner"/>
			<member name="C:CodeScanMatch_func" value="0">
			</member>
			<member name="C:CodeScanMatch_size" value="1">
			</member>
			<member name="C:CodeScanMatch_type" value="2">
			</member>
			<member name="C:CodeScanMatch_heap" value="3">
			</member>
			<member name="C:CodeScanMatch_stack" value="4">
			</member>
			<member name="C:CodeScanMatch_params" value="5">
			</member>
			<member name="C:CodeScanMatch_cip" value="6">
			</member>
			<member name="C:CodeScanMatch_holes" value="7">
				<size value="16"/>
			</member>
			<member name="C:CodeScanMatch_hole_count" value="23">
			</member>
			<member name="C:CodeScanMatch_name" value="24">
				<size value="8"/>
			</member>
			<member name="C:CodeScanner_first" value="32">
			</member>
			<member name="C:CodeScanner_minn" value="33">
			</member>
			<member name="C:CodeScanner_jump_switch" value="34">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_jump_target" value="66">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_jump_stack" value="98">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_jump_heap" value="130">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_state" value="162">
			</member>
			<member name="C:CodeScanner_param" value="163">
			</member>
			<referrer name="AddressofResolve"/>
			<referrer name="YVA2_Initalise"/>
		</member>
		<member name="T:DisasmContext" value="5">
			<tagname value="DisasmContext"/>
			<member name="C:DisasmContext_start_ip" value="0">
			</member>
			<member name="C:DisasmContext_end_ip" value="1">
			</member>
			<member name="C:DisasmContext_nip" value="2">
			</member>
			<member name="C:DisasmContext_cip" value="3">
			</member>
			<member name="C:DisasmContext_opcode" value="4">
				<tagname value="Opcode"/>
			</member>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="VA_OnCodeInit"/>
			<referrer name="Hooks_GetStubEntry"/>
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
		</member>
		<member name="T:E_CHAIN_HOOK" value="17">
			<tagname value="E_CHAIN_HOOK"/>
			<member name="C:E_CHAIN_HOOK_NAME" value="0">
				<size value="16"/>
			</member>
			<member name="C:E_CHAIN_HOOK_VALUE" value="16">
			</member>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_DoAllHooks"/>
		</member>
		<member name="T:E_HOOK_NAME_REPLACEMENT_DATA" value="34">
			<tagname value="E_HOOK_NAME_REPLACEMENT_DATA"/>
			<member name="C:E_HOOK_NAME_REPLACEMENT_SHORT" value="0">
				<size value="16"/>
			</member>
			<member name="C:E_HOOK_NAME_REPLACEMENT_LONG" value="16">
				<size value="16"/>
			</member>
			<member name="C:E_HOOK_NAME_REPLACEMENT_MIN" value="32">
			</member>
			<member name="C:E_HOOK_NAME_REPLACEMENT_MAX" value="33">
			</member>
		</member>
		<member name="T:E_ITER_YIELD" value="11">
			<tagname value="E_ITER_YIELD"/>
			<member name="C:E_ITER_YIELD_STACK_START" value="0">
			</member>
			<member name="C:E_ITER_YIELD_STACK_END" value="1">
			</member>
			<member name="C:E_ITER_YIELD_STACK_SIZE" value="2">
			</member>
			<member name="C:E_ITER_YIELD_HEAP_START" value="3">
			</member>
			<member name="C:E_ITER_YIELD_HEAP_END" value="4">
			</member>
			<member name="C:E_ITER_YIELD_HEAP_SIZE" value="5">
			</member>
			<member name="C:E_ITER_YIELD_FIRST" value="6">
			</member>
			<member name="C:E_ITER_YIELD_FRM" value="7">
			</member>
			<member name="C:E_ITER_YIELD_CIP" value="8">
			</member>
			<member name="C:E_ITER_YIELD_FRAME" value="9">
			</member>
			<member name="C:E_ITER_YIELD_RETURN" value="10">
			</member>
		</member>
		<member name="T:IgraceveInformacije" value="30">
			<tagname value="IgraceveInformacije"/>
			<member name="C:SQLID" value="0">
			</member>
			<member name="C:Username" value="1">
				<size value="24"/>
			</member>
			<member name="C:Password" value="25">
			</member>
			<member name="C:Level" value="26">
			</member>
			<member name="C:Novac" value="27">
			</member>
			<member name="C:Skin" value="28">
			</member>
			<member name="C:Admin" value="29">
			</member>
		</member>
		<member name="T:OpcodeInsnInfo" value="17">
			<tagname value="OpcodeInsnInfo"/>
			<member name="C:OpcodeInsnInfo_name" value="0">
				<size value="15"/>
			</member>
			<member name="C:OpcodeInsnInfo_num_opers" value="15">
			</member>
			<member name="C:OpcodeInsnInfo_needs_reloc" value="16">
				<tagname value="bool"/>
			</member>
		</member>
		<member name="T:__E_COMPILER_ENUM" value="4">
			<tagname value="__E_COMPILER_ENUM"/>
			<member name="C:__E_COMPILER_ENUM_ENTRY" value="0">
				<size value="3"/>
			</member>
			<member name="C:__E_COMPILER_ENUM_AFTER" value="3">
			</member>
		</member>

		<!-- constants -->
		<member name="C:AMX_HDR_OFFSET_AMX_VERSION" value="7">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_CIP" value="28">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_COD" value="12">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_DAT" value="16">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_DEFSIZE" value="10">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_FILE_VERSION" value="6">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_FLAGS" value="8">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_HEA" value="20">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_LIBRARIES" value="40">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_MAGIC" value="4">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_NAMETABLE" value="52">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_NATIVES" value="36">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_PUBLICS" value="32">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_PUBVARS" value="44">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_SIZE" value="0">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_STP" value="24">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_TAGS" value="48">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:NUM_OPCODES" value="138">
			<referrer name="IsOpcodeValid"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="UnrelocateOpcode"/>
			<referrer name="GetOpcodeInstructionInformation"/>
			<referrer name="GetOpcodeInstructionName"/>
			<referrer name="GetOpcodeInstructionParameters"/>
			<referrer name="GetOpcodeInstructionRelocatable"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmNext"/>
			<referrer name="AsmEmitOpcode"/>
		</member>
		<member name="C:SORT_IS_PLAYERS" value="1">
			<referrer name="SortArrayUsingCompInto_Entry"/>
		</member>
		<member name="C:__Pawn" value="778">
		</member>
		<member name="C:__PawnBuild" value="8">
		</member>
		<member name="C:cellbits" value="32">
			<referrer name="Base64Encode"/>
			<referrer name="Base64Decode"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanNOPMatch"/>
			<referrer name="AddressofResolveFoundEnd"/>
			<referrer name="YVA2_CodeGenDeepCleanup"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="_yH@"/>
		</member>
		<member name="C:cellmax" value="2147483647">
			<referrer name="operator!(Float:)"/>
			<referrer name="Range"/>
			<referrer name="CodeScanGetFunctionAsm"/>
			<referrer name="CodeScanGetMatchAsm"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YHNPS_Insert"/>
			<referrer name="YHNPS_Push"/>
		</member>
		<member name="C:cellmin" value="-2147483648">
			<referrer name="operator-(Float:)"/>
			<referrer name="Random"/>
			<referrer name="endofline"/>
			<referrer name="ishex"/>
			<referrer name="isnumeric"/>
			<referrer name="SkipWhitespace"/>
			<referrer name="Trim"/>
			<referrer name="Range"/>
			<referrer name="CallN"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
			<referrer name="CallNative"/>
			<referrer name="CallNativeByAddress"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="CodeScanInit"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="Iter_Random_Internal"/>
			<referrer name="Iter_RandomFree_InternalC"/>
			<referrer name="Iter_Alloc_InternalC"/>
			<referrer name="Iter_Alloc_InternalD"/>
			<referrer name="Iter_Free_Internal"/>
			<referrer name="Iter_FreeMulti_Internal"/>
			<referrer name="Iter_Add_InternalC"/>
			<referrer name="Iter_Add_InternalD"/>
			<referrer name="Iter_Index_Internal"/>
			<referrer name="Iter_SafeRemove_InternalC"/>
			<referrer name="Iter_SafeRemove_InternalD"/>
			<referrer name="Iter_GetMulti_Internal"/>
			<referrer name="YHNPS_Find"/>
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
			<referrer name="Iter_Func@Range"/>
			<referrer name="Iter_Func@Random"/>
		</member>
		<member name="C:debug" value="2">
			<referrer name="RelocateOpcodeNow"/>
		</member>
		<member name="C:false" value="0">
			<tagname value="bool"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="OnGameModeInit"/>
			<referrer name="YVers_Callback"/>
			<referrer name="Utils_PreSort"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="GetOpcodeInstructionRelocatable"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmWrite"/>
			<referrer name="O@A_"/>
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanGetFuncName"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanFindOneFastPattern3"/>
			<referrer name="CodeScanFindOneFastPattern2"/>
			<referrer name="CodeScanRunFastPrescan"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="AddressofResolve"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_IsolateName"/>
			<referrer name="Iter_YieldEnter"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="@yH_OnPlayerDisconnect@001"/>
			<referrer name="Iter_DestroyActor"/>
			<referrer name="Iter_DestroyVehicle"/>
			<referrer name="KreirajGlobalneTD"/>
			<referrer name="PawnCmd_OnGameModeInit"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
			<referrer name="ProvjeriBAN"/>
			<referrer name="ProvjeriBANIP"/>
			<referrer name="SSCANF_OnPlayerDisconnect"/>
			<referrer name="OnPlayerText"/>
			<referrer name="pc_cmd_aduty"/>
			<referrer name="pc_cmd_kick"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<referrer name="pc_cmd_unban"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="IgracRegistrovan"/>
		</member>
		<member name="C:true" value="1">
			<tagname value="bool"/>
			<referrer name="OnJITCompile"/>
			<referrer name="OnRuntimeError"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="boolstr"/>
			<referrer name="Utils_PreSort"/>
			<referrer name="ResetStaticAmxHeader"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="GetTagNameFromID"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmWrite"/>
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="AsmEmitJrelLabelStringize"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanGetFuncName"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanFindOneFastPattern3"/>
			<referrer name="CodeScanFindOneFastPattern2"/>
			<referrer name="CodeScanRunFastPrescan"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="AddressofResolve"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetFunctionWritePoint"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="_Hooks_RepairStub"/>
			<referrer name="Iter_YieldEnter"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Indirection_OnFilterScriptInit"/>
			<referrer name="Indirection_OnGameModeInit"/>
			<referrer name="sscanf_weapon"/>
			<referrer name="sscanf_vehicle"/>
			<referrer name="KreirajGlobalneTD"/>
			<referrer name="OnPlayerRequestClass"/>
			<referrer name="pc_cmd_aduty"/>
			<referrer name="pc_cmd_kick"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<referrer name="pc_cmd_unban"/>
			<referrer name="BAN_TIMER"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="ResetujVarijable"/>
			<referrer name="SacuvajNalog"/>
			<referrer name="IgracRegistrovan"/>
		</member>

		<!-- variables -->
		<member name="F:@_">
			<attribute name="public"/>
			<referrer name="C@"/>
			<referrer name="D@"/>
			<referrer name="E@"/>
			<referrer name="@@Iter_ActorDo"/>
			<referrer name="@@Iter_VehicleDo"/>
		</member>
		<member name="F:AMX_BASE_ADDRESS">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetEntryPrefix"/>
			<referrer name="AMX_GetEntrySuffix"/>
			<referrer name="AMX_GetName"/>
			<referrer name="AMX_GetNamePrefix"/>
			<referrer name="AMX_GetNameSuffix"/>
			<referrer name="AMX_GetStringFromEntry"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_InvalidateName"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="_Hooks_RepairStub"/>
		</member>
		<member name="F:AMX_HEADER_AMX_VERSION">
			<referrer name="Debug_OnCodeInit"/>
		</member>
		<member name="F:AMX_HEADER_CIP">
			<referrer name="Debug_OnCodeInit"/>
		</member>
		<member name="F:AMX_HEADER_COD">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetGlobal"/>
			<referrer name="AMX_TraceCode"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="VA_OnCodeInit"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
		</member>
		<member name="F:AMX_HEADER_DAT">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_TraceCode"/>
			<referrer name="AMX_TraceMemory"/>
		</member>
		<member name="F:AMX_HEADER_DEFSIZE">
			<referrer name="Debug_OnCodeInit"/>
		</member>
		<member name="F:AMX_HEADER_FILE_VERSION">
			<referrer name="Debug_OnCodeInit"/>
		</member>
		<member name="F:AMX_HEADER_FLAGS">
			<referrer name="Debug_OnCodeInit"/>
		</member>
		<member name="F:AMX_HEADER_HEA">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_TraceMemory"/>
		</member>
		<member name="F:AMX_HEADER_LIBRARIES">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_HEADER_MAGIC">
			<referrer name="Debug_OnCodeInit"/>
		</member>
		<member name="F:AMX_HEADER_NAMETABLE">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_HEADER_NATIVES">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetBaseCount"/>
			<referrer name="AMX_GetEntryFromNativeIndex"/>
			<referrer name="AMX_GetNativeIndexFromEntry"/>
			<referrer name="Hooks_SortPublics"/>
		</member>
		<member name="F:AMX_HEADER_PUBLICS">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetBaseCount"/>
			<referrer name="AMX_GetEntryFromPublicIndex"/>
			<referrer name="AMX_GetPublicIndexFromEntry"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="_Hooks_RepairStub"/>
			<referrer name="Hooks_RepairJITInit"/>
		</member>
		<member name="F:AMX_HEADER_PUBVARS">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_HEADER_SIZE">
			<referrer name="Debug_OnCodeInit"/>
		</member>
		<member name="F:AMX_HEADER_STP">
			<referrer name="Debug_OnCodeInit"/>
		</member>
		<member name="F:AMX_HEADER_TAGS">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_REAL_ADDRESS">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="Hooks_WriteFunction"/>
		</member>
		<member name="F:AMX_REAL_DATA">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetGlobalAddress"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
		</member>
		<member name="F:ASM_ARGUMENTS_OFFSET">
			<referrer name="AsmGetArgOffset"/>
		</member>
		<member name="F:ASM_CALLER_FRAME_OFFSET">
		</member>
		<member name="F:ASM_CTRL_CIP">
		</member>
		<member name="F:ASM_CTRL_COD">
		</member>
		<member name="F:ASM_CTRL_DAT">
		</member>
		<member name="F:ASM_CTRL_FRM">
		</member>
		<member name="F:ASM_CTRL_HEA">
		</member>
		<member name="F:ASM_CTRL_JIT">
		</member>
		<member name="F:ASM_CTRL_JMP">
		</member>
		<member name="F:ASM_CTRL_STK">
		</member>
		<member name="F:ASM_CTRL_STP">
		</member>
		<member name="F:ASM_LOCALS_OFFSET">
		</member>
		<member name="F:ASM_RETURN_ADDR_OFFSET">
		</member>
		<member name="F:AdminDuty">
			<referrer name="pc_cmd_aduty"/>
			<referrer name="pc_cmd_kick"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<referrer name="pc_cmd_unban"/>
		</member>
		<member name="F:CELLMIN_ON_MATCHES">
		</member>
		<member name="F:F@o">
		</member>
		<member name="F:FALSE">
			<tagname value="bool"/>
			<referrer name="Hooks_RepairJITInit"/>
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="@yH_OnPlayerConnect@001"/>
			<referrer name="Iter_OPDCInternal"/>
			<referrer name="Iter_ActorDo"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
			<referrer name="Iter_VehicleDo"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
		</member>
		<member name="F:FLOAT_TAG_">
			<tagname value="Float"/>
		</member>
		<member name="F:I@">
			<referrer name="Iter_YieldReturn"/>
			<referrer name="_@Iter_ActorDo"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
			<referrer name="_@Iter_VehicleDo"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
		</member>
		<member name="F:IC_CHAT">
			<referrer name="OnPlayerText"/>
		</member>
		<member name="F:INDIRECTION_DATA">
			<referrer name="Indirect_Call"/>
			<referrer name="Indirect_Callstring"/>
			<referrer name="Indirect_Callvoid"/>
			<referrer name="Indirect_Array"/>
		</member>
		<member name="F:INDIRECTION_TAG">
			<referrer name="Indirect_Call"/>
			<referrer name="Indirect_Callstring"/>
			<referrer name="Indirect_Callvoid"/>
			<referrer name="Indirect_Array"/>
		</member>
		<member name="F:IgracInfo">
			<referrer name="SSCANF_OnPlayerDisconnect"/>
			<referrer name="pc_cmd_aduty"/>
			<referrer name="pc_cmd_kick"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<referrer name="pc_cmd_unban"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="ResetujVarijable"/>
			<referrer name="SacuvajNalog"/>
			<referrer name="IgracRegistrovan"/>
			<referrer name="SQL_ProvjeraAccounta"/>
		</member>
		<member name="F:IgracUlogovan">
			<tagname value="bool"/>
			<referrer name="OnPlayerRequestClass"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
			<referrer name="SSCANF_OnPlayerDisconnect"/>
			<referrer name="pc_cmd_aduty"/>
			<referrer name="pc_cmd_kick"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<referrer name="pc_cmd_unban"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="SacuvajNalog"/>
			<referrer name="IgracRegistrovan"/>
		</member>
		<member name="F:Iter_Single@Actor">
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="Iter_ActorDo"/>
		</member>
		<member name="F:Iter_Single@Bot">
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="@yH_OnPlayerConnect@001"/>
			<referrer name="Iter_OPDCInternal"/>
		</member>
		<member name="F:Iter_Single@Character">
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="@yH_OnPlayerConnect@001"/>
			<referrer name="Iter_OPDCInternal"/>
		</member>
		<member name="F:Iter_Single@LocalActor">
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
		</member>
		<member name="F:Iter_Single@LocalVehicle">
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
		</member>
		<member name="F:Iter_Single@Player">
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="@yH_OnPlayerConnect@001"/>
			<referrer name="Iter_OPDCInternal"/>
		</member>
		<member name="F:Iter_Single@Vehicle">
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="Iter_VehicleDo"/>
		</member>
		<member name="F:Iterator@Actor">
			<tagname value="_no_itertag"/>
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="Iter_ActorDo"/>
		</member>
		<member name="F:Iterator@Bot">
			<tagname value="_no_itertag"/>
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="@yH_OnPlayerConnect@001"/>
			<referrer name="Iter_OPDCInternal"/>
		</member>
		<member name="F:Iterator@Character">
			<tagname value="_no_itertag"/>
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="@yH_OnPlayerConnect@001"/>
			<referrer name="Iter_OPDCInternal"/>
		</member>
		<member name="F:Iterator@Fib">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Filter">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@LocalActor">
			<tagname value="_no_itertag"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
		</member>
		<member name="F:Iterator@LocalVehicle">
			<tagname value="_no_itertag"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
		</member>
		<member name="F:Iterator@NonNull">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Null">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Player">
			<tagname value="_no_itertag"/>
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="@yH_OnPlayerConnect@001"/>
			<referrer name="Iter_OPDCInternal"/>
			<referrer name="ProxDetector"/>
			Create the internal iterators. 
		</member>
		<member name="F:Iterator@Powers">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Random">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Range">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Until">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Vehicle">
			<tagname value="_no_itertag"/>
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="Iter_VehicleDo"/>
		</member>
		<member name="F:J@">
			<referrer name="_@Iter_ActorDo"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
			<referrer name="_@Iter_VehicleDo"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
		</member>
		<member name="F:LOGREG_TD">
			<tagname value="Text"/>
			<referrer name="KreirajGlobalneTD"/>
			<referrer name="ProvjeriBANIP"/>
			<referrer name="OnPlayerClickTextDraw"/>
			<referrer name="SQL_ProvjeraAccounta"/>
		</member>
		<member name="F:MATCH_NAME_PARTIAL">
		</member>
		<member name="F:NULL">
		</member>
		<member name="F:O@V_">
			<referrer name="O@A_"/>
			<referrer name="AddressofResolve"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="YVA2_Initalise"/>
			<referrer name="Hooks_GenerateContinue"/>
		</member>
		<member name="F:OLD_DEFAULT_CUSTOM">
		</member>
		<member name="F:OLD_DEFAULT_KUSTOM">
		</member>
		<member name="F:OLD_DEFAULT_NAME">
		</member>
		<member name="F:Q@">
			<referrer name="C@"/>
			<referrer name="S@"/>
			<referrer name="G@"/>
		</member>
		<member name="F:SQL">
			<tagname value="MySQL"/>
			<referrer name="PawnCmd_OnGameModeInit"/>
			<referrer name="ScriptInit_OnGameModeExit"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
			<referrer name="ProvjeriBAN"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<referrer name="pc_cmd_unban"/>
			<referrer name="ProvjeriUNBAN"/>
			<referrer name="OnPlayerClickTextDraw"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="SacuvajNalog"/>
		</member>
		<member name="F:SSCANF_QUIET">
		</member>
		<member name="F:SSCANF_gInit">
			<tagname value="bool"/>
			<referrer name="Indirection_OnFilterScriptInit"/>
			<referrer name="Indirection_OnGameModeInit"/>
		</member>
		<member name="F:SSCANF_g_sPlayers">
		</member>
		<member name="F:Streamer_IncludeFileVersion">
			<attribute name="public"/>
		</member>
		<member name="F:TRUE">
			<tagname value="bool"/>
			<referrer name="YVA2_DummyPush"/>
		</member>
		<member name="F:UNIQUE_SYMBOL_DOESNT_EXIST">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:USERNAME_TD">
			<tagname value="PlayerText"/>
			<referrer name="KreirajPlayerTD"/>
			<referrer name="ProvjeriBANIP"/>
			<referrer name="SQL_ProvjeraAccounta"/>
		</member>
		<member name="F:YSI_FILTERSCRIPT">
			<tagname value="bool"/>
			<referrer name="Server_IsFilterscript"/>
			<referrer name="Server_IsGameMode"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="OnGameModeInit"/>
			<referrer name="OnFilterScriptExit"/>
			<referrer name="OnGameModeExit"/>
			<referrer name="ScriptInit_OnCodeInit"/>
		</member>
		<member name="F:YSI_gDebugLevel">
			<referrer name="Debug_Level"/>
		</member>
		<member name="F:YSI_gIteratorDepth">
			<referrer name="Iter_YieldEnter"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_YieldReturn"/>
		</member>
		<member name="F:YSI_gPlayerIP">
			<referrer name="OnPlayerConnect"/>
			<referrer name="OnPlayerDisconnect"/>
		</member>
		<member name="F:YSI_gUnsafeHugeString">
		</member>
		<member name="F:YSI_g_sActiveHooks">
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="ScriptInit_OnRuntimeError"/>
		</member>
		<member name="F:YSI_g_sCallData">
			<referrer name="C@"/>
			<referrer name="D@"/>
			<referrer name="F@"/>
		</member>
		<member name="F:YSI_g_sCodeEnd">
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="CGen_UseCodeSpace"/>
		</member>
		<member name="F:YSI_g_sCodeJITed">
			<tagname value="bool"/>
			<referrer name="Server_JITComplete"/>
			<referrer name="OnJITCompile"/>
		</member>
		<member name="F:YSI_g_sCodeJITing">
			<tagname value="bool"/>
			<referrer name="Server_JITExists"/>
			<referrer name="OnJITCompile"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="OnGameModeInit"/>
		</member>
		<member name="F:YSI_g_sCodeSpace">
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="VA_OnCodeInit"/>
			<referrer name="CGen_UseCodeSpace"/>
			<referrer name="CGen_GetCodeSpace"/>
			<referrer name="CGen_AddCodeSpace"/>
		</member>
		<member name="F:YSI_g_sContexts">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sCrashdetect">
			<tagname value="bool"/>
			<referrer name="Server_CrashDetectExists"/>
			<referrer name="OnRuntimeError"/>
		</member>
		<member name="F:YSI_g_sInitFSIdx">
			<referrer name="CGen_OnCodeInit"/>
			<referrer name="_Hooks_RepairStub"/>
			<referrer name="Hooks_RepairJITInit"/>
		</member>
		<member name="F:YSI_g_sInitFSPtr">
			<referrer name="_Hooks_RepairStubFS"/>
			<referrer name="Hooks_RepairJITInit"/>
		</member>
		<member name="F:YSI_g_sInitFSRep">
			<referrer name="_Hooks_RepairStub"/>
			<referrer name="Hooks_RepairJITInit"/>
		</member>
		<member name="F:YSI_g_sInitGMIdx">
			<referrer name="CGen_OnCodeInit"/>
			<referrer name="_Hooks_RepairStub"/>
			<referrer name="Hooks_RepairJITInit"/>
		</member>
		<member name="F:YSI_g_sInitGMPtr">
			<referrer name="_Hooks_RepairStubGM"/>
			<referrer name="Hooks_RepairJITInit"/>
		</member>
		<member name="F:YSI_g_sInitGMRep">
			<referrer name="_Hooks_RepairStub"/>
			<referrer name="Hooks_RepairJITInit"/>
		</member>
		<member name="F:YSI_g_sInitPublicDiff">
			<referrer name="Hooks_SortPublics"/>
			<referrer name="_Hooks_RepairStub"/>
		</member>
		<member name="F:YSI_g_sInitialised">
			<referrer name="YVA2_DummyPush"/>
			<referrer name="ThirdParty_OnCodeInit"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sIteratorStack">
			<referrer name="Iter_YieldEnter"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_YieldReturn"/>
		</member>
		<member name="F:YSI_g_sLength">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sMaxNesting">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sNPSBaseCall">
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
		</member>
		<member name="F:YSI_g_sNPSReplace">
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
		</member>
		<member name="F:YSI_g_sNPSStack">
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
		</member>
		<member name="F:YSI_g_sNPSTrampoline">
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
		</member>
		<member name="F:YSI_g_sPassthroughNestings">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sPropCaller">
			<referrer name="C@"/>
			<referrer name="D@"/>
		</member>
		<member name="F:YSI_g_sPropEmpty">
			<referrer name="C@"/>
			<referrer name="D@"/>
			<referrer name="T@"/>
		</member>
		<member name="F:YSI_g_sPropReturn">
			<referrer name="D@"/>
			<referrer name="L@"/>
		</member>
		<member name="F:YSI_g_sPropVarArg">
			<referrer name="C@"/>
			<referrer name="D@"/>
			<referrer name="L@"/>
			<referrer name="T@"/>
		</member>
		<member name="F:YSI_g_sPtr">
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_YieldReturn"/>
		</member>
		<member name="F:YSI_g_sReplacePtr">
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sReplacements">
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sReplacementsLongOrder">
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sReplacementsShortOrder">
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sSkips">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sSortedOnce">
			<tagname value="bool"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="_Hooks_RepairStub"/>
		</member>
		<member name="F:YSI_g_sStack">
			<referrer name="YHNPS_OnCodeInit"/>
		</member>
		<member name="F:YSI_g_sStackPtr">
			<referrer name="YHNPS_OnCodeInit"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_YieldReturn"/>
		</member>
		<member name="F:YSI_g_sStacks">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sTempRet">
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
		</member>
		<member name="F:YSI_g_sYSIM_STRING">
			<referrer name="C@"/>
		</member>
		<member name="F:YSI_g_sYSI_MAX_STRING">
			<referrer name="C@"/>
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:__ARR">
		</member>
		<member name="F:__REF">
		</member>
		<member name="F:__YSI_gsCompilerEnum">
		</member>
		<member name="F:__date">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__time">
		</member>
		<member name="F:_pawncmd_is_gamemode">
			<tagname value="bool"/>
			<attribute name="public"/>
		</member>
		<member name="F:_pawncmd_version">
			<attribute name="public"/>
		</member>
		<member name="F:gBase">
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanInit"/>
		</member>
		<member name="F:gCodBase">
			<referrer name="CodeScanRunFastPrescan"/>
			<referrer name="CodeScanInit"/>
		</member>
		<member name="F:gCodBase">
			<referrer name="DisasmInit"/>
			<referrer name="DisasmReloc"/>
			<referrer name="DisasmWriteCode"/>
		</member>
		<member name="F:gCodeScanCallback_match">
			<referrer name="AddressofResolve"/>
			<referrer name="YVA2_Initalise"/>
		</member>
		<member name="F:gDat">
			<referrer name="CodeScanRun"/>
			<referrer name="CodeScanInit"/>
			<referrer name="CodeScanGetMatchFunc"/>
			<referrer name="CodeScanGetMatchAddress"/>
		</member>
		<member name="F:gHdr">
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanInit"/>
		</member>
		<member name="F:gHdr">
			<referrer name="ResetStaticAmxHeader"/>
			<referrer name="GetAmxHeader"/>
			<referrer name="GetAmxHeaderComponent"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
		</member>
		<member name="F:gInitialized">
			<tagname value="bool"/>
			<referrer name="ResetStaticAmxHeader"/>
			<referrer name="GetAmxHeader"/>
			<referrer name="GetAmxHeaderComponent"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
		</member>
		<member name="F:gOP_CASETBL">
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanInit"/>
		</member>
		<member name="F:gOP_NOP">
			<referrer name="CodeScanInit"/>
			<referrer name="CodeScanNOPMatch"/>
		</member>
		<member name="F:gOpArgCount">
			<referrer name="CodeScanRunFastPrescan"/>
		</member>
		<member name="F:gPreviousWriteOffset">
			<referrer name="AsmEmitInstruction"/>
			<referrer name="AsmEmitJumpLabelInstruction"/>
			<referrer name="AsmGetPreviousWriteOffset"/>
		</member>
		<member name="F:g_args">
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="Call"/>
			<referrer name="CallN"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
		</member>
		<member name="F:g_nargs">
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="Call"/>
			<referrer name="CallN"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
		</member>
		<member name="F:g_sort_cmp_array">
		</member>
		<member name="F:g_sort_cmp_offset">
			<referrer name="SortDeepArray_Entry"/>
			<referrer name="_SortDeepArray"/>
		</member>
		<member name="F:g_sort_cmp_type">
			<referrer name="SortDeepArray_Entry"/>
			<referrer name="_SortDeepArray"/>
		</member>
		<member name="F:g_sort_ignorecase">
			<tagname value="bool"/>
			<referrer name="SortDeepArray_Entry"/>
			<referrer name="_SortDeepArray"/>
		</member>
		<member name="F:g_sort_order">
			<tagname value="E_SORT_ORDER"/>
			<referrer name="SortDeepArray_Entry"/>
			<referrer name="_SortDeepArray"/>
		</member>
		<member name="F:g_sort_stack">
			<referrer name="_SortDeepArray"/>
			<referrer name="SortArrayUsingComparator_QS"/>
			<referrer name="SortArrayUsingCompInto_QS"/>
		</member>
		<member name="F:gsCodSize">
			<referrer name="Indirect_Call"/>
			<referrer name="Indirect_Callstring"/>
			<referrer name="Indirect_Callvoid"/>
			<referrer name="Indirect_Array"/>
			<referrer name="Indirect_GetMeta_"/>
			<referrer name="Indirect_SetMeta_"/>
			<referrer name="Indirect_Claim_"/>
			<referrer name="Indirect_Release_"/>
			<referrer name="Indirect_Ref_"/>
			<referrer name="Indirect_Ptr_"/>
			<referrer name="Indirect_DeRef_"/>
			<referrer name="Indirect_DePtr_"/>
			<referrer name="Indirect_Init"/>
		</member>
		<member name="F:insn_table">
			<referrer name="GetOpcodeInstructionInformation"/>
			<referrer name="GetOpcodeInstructionName"/>
			<referrer name="GetOpcodeInstructionParameters"/>
			<referrer name="GetOpcodeInstructionRelocatable"/>
		</member>
		<member name="F:iterstart@Fib">
		</member>
		<member name="F:iterstart@Filter">
		</member>
		<member name="F:iterstart@NonNull">
		</member>
		<member name="F:iterstart@Null">
		</member>
		<member name="F:iterstart@Powers">
		</member>
		<member name="F:iterstart@Random">
		</member>
		<member name="F:iterstart@Range">
		</member>
		<member name="F:iterstart@Until">
		</member>
		<member name="F:opcode_table">
			<tagname value="Opcode"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="RelocateOpcode"/>
			<referrer name="UnrelocateOpcode"/>
		</member>
		<member name="F:opcode_table_is_ready">
			<tagname value="bool"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="RelocateOpcode"/>
			<referrer name="UnrelocateOpcode"/>
		</member>
		<member name="F:size_l">
			<remarks>  <p>Because of the strange way we manipulate the stack, this function actually  gets called twice as often as you would expect.  Essentially, for this  (psudo-)loop:</p>  <code>  for (new i = iter_func(); Iter_YieldLoop(); )                              <br />  {                                                                          <br />  }  </code>  <p>The loop is entered and <c>iter_func()</c> is called.  This indirectly  calls <c>yield</c>, which returns to the call point of that function.  The  loop check is then entered and <c>Iter_YieldLoop()</c> is called.  Depending  on if <c>yield</c> was actually used, the main loop body is entered.  At the  end of that iteration, the loop check is run again and so  <c>Iter_YieldLoop()</c> is called again.</p>  <p>This is where it gets wierd!</p>  <p><c>Iter_YieldLoop()</c> does a stack copy and a jump in to the earlier  call to <c>iter_func</c>, whose return address is earlier in the code.  When  a <c>yield</c> is done again, that return is to the first part of the  <c>for</c> loop, which then instantly enters the loop check section and calls  <c>Iter_YieldLoop()</c> again (as a side-effect, saving the iterator value in  the loop variable).</p>  <p>So for <c>N</c> iterations of the loop, <c>Iter_YieldLoop()</c> is called  <c>2N + 1</c> times, and should be made aware of which phase of its calls it  is in.</p>  <p>This is, of course, made more complicated by nested loops, but that just  means we need to store the state on our own stack.</p>  </remarks> 
		</member>
		<member name="F:src_l">
		</member>
		<member name="F:using_deprecated_foreach_syntax">
			<tagname value="bool"/>
			The workings of these macros are very extensively documented at:  <a href="http://forum.sa-mp.com/showpost.php?p=2823668" /> 
		</member>
		<member name="F:using_deprecated_itertag_syntax">
			<tagname value="bool"/>
		</member>

		<!-- functions -->
		<member name="M:operator!(Float:)" syntax="operator!(Float:)(oper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="cellmax"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator*(_no_itertag:,_:)" syntax="operator*(_no_itertag:,_:)(a, b)">
			<stacksize value="1"/>
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="@yH_OnPlayerConnect@001"/>
			<referrer name="Iter_OPDCInternal"/>
			<referrer name="Iter_ActorDo"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
			<referrer name="Iter_VehicleDo"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
			<param name="a">
				<paraminfo>_no_itertag </paraminfo>
			</param>
			<param name="b">
			</param>
			<remarks>  Suppress warnings when `_:` is used (correctly) instead of `_no_itertag:`.  </remarks> 
		</member>
		<member name="M:operator%(_:,Float:)" syntax="operator%(_:,Float:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(Float:,_:)" syntax="operator%(Float:,_:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator%(Float:,Float:)" syntax="operator%(Float:,Float:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator!=(Float:,_:)" syntax="operator!=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator!=(Float:,Float:)" syntax="operator!=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="RandomFloat"/>
			<referrer name="_SortDeepArray"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(_:,Float:)" syntax="operator-(_:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatsub"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:,_:)" syntax="operator-(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatsub"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator+(Float:,_:)" syntax="operator+(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatadd"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator/(_:,Float:)" syntax="operator/(_:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatdiv"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(Float:,_:)" syntax="operator/(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<referrer name="ProxDetector"/>
			<dependency name="float"/>
			<dependency name="floatdiv"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator*(Float:,_:)" syntax="operator*(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatmul"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator++(Float:)" syntax="operator++(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<dependency name="operator+(Float:,Float:)"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:)" syntax="operator-(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<referrer name="RandomFloat"/>
			<referrer name="ProxDetector"/>
			<dependency name="cellmin"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator--(Float:)" syntax="operator--(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<dependency name="operator-(Float:,Float:)"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:,Float:)" syntax="operator-(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator--(Float:)"/>
			<referrer name="RandomFloat"/>
			<referrer name="ProxDetector"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator+(Float:,Float:)" syntax="operator+(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator++(Float:)"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(Float:,Float:)" syntax="operator/(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="__TU"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator*(Float:,Float:)" syntax="operator*(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:Float:operator=(_:)" syntax="Float:operator=(_:)(oper)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="pc_cmd_aduty"/>
			<param name="oper">
			</param>
		</member>
		<member name="M:operator==(Float:,Float:)" syntax="operator==(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator==(Float:,_:)" syntax="operator==(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;(Float:,Float:)" syntax="operator&gt;(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="_SortDeepArray"/>
			<referrer name="ProxDetector"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;(Float:,_:)" syntax="operator&gt;(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;(_:,Float:)" syntax="operator&gt;(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;=(Float:,Float:)" syntax="operator&gt;=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;=(Float:,_:)" syntax="operator&gt;=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;=(_:,Float:)" syntax="operator&gt;=(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;(Float:,Float:)" syntax="operator&lt;(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="RandomFloat"/>
			<referrer name="_SortDeepArray"/>
			<referrer name="ProxDetector"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;(Float:,_:)" syntax="operator&lt;(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&lt;(_:,Float:)" syntax="operator&lt;(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;=(Float:,Float:)" syntax="operator&lt;=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;=(Float:,_:)" syntax="operator&lt;=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&lt;=(_:,Float:)" syntax="operator&lt;=(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:_:operator=(_no_itertag:)" syntax="_:operator=(_no_itertag:)(a)">
			<stacksize value="1"/>
			<referrer name="ProxDetector"/>
			<param name="a">
				<paraminfo>_no_itertag </paraminfo>
			</param>
			<remarks>  Suppress warnings when `_:` is used (correctly) instead of `_no_itertag:`.  </remarks> 
		</member>
		<member name="M:_no_itertag:operator=(_:)" syntax="_no_itertag:operator=(_:)(a)">
			<tagname value="_no_itertag"/>
			<stacksize value="1"/>
			<param name="a">
			</param>
			<remarks>  Suppress warnings when `_:` is used (correctly) instead of `_no_itertag:`.  </remarks> 
		</member>
		<member name="M:@@Iter_ActorDo" syntax="@@Iter_ActorDo(add, actorid, __m)">
			<tagname value="I@R"/>
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="@_"/>
			<dependency name="Iter_ActorDo"/>
			<dependency name="L@"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="actorid">
			</param>
			<param name="__m">
			</param>
		</member>
		<member name="M:@@Iter_VehicleDo" syntax="@@Iter_VehicleDo(add, vehicleid, __m)">
			<tagname value="I@R"/>
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="@_"/>
			<dependency name="Iter_VehicleDo"/>
			<dependency name="L@"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="vehicleid">
			</param>
			<param name="__m">
			</param>
		</member>
		<member name="M:@CO_CGen" syntax="@CO_CGen()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="@CO_Debug"/>
		</member>
		<member name="M:@CO_Debug" syntax="@CO_Debug()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<referrer name="@CO_CGen"/>
			<dependency name="@CO_YVers"/>
		</member>
		<member name="M:@CO_ScriptInit" syntax="@CO_ScriptInit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<referrer name="@CO_YVers"/>
		</member>
		<member name="M:@CO_YVers" syntax="@CO_YVers()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<referrer name="@CO_Debug"/>
			<dependency name="@CO_ScriptInit"/>
		</member>
		<member name="M:@_yHCheckpoint" syntax="@_yHCheckpoint()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHCommand" syntax="@_yHCommand()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHContainer" syntax="@_yHContainer()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHDynamic" syntax="@_yHDynamic()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHDynamicCP" syntax="@_yHDynamicCP()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHInventory" syntax="@_yHInventory()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHObject" syntax="@_yHObject()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHTextDraw" syntax="@_yHTextDraw()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHUpdate" syntax="@_yHUpdate()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@receivepacket" syntax="@receivepacket(packet[], size, source[])">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="packet">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:@receivestring" syntax="@receivestring(message[], source[])">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:@yH_OnPlayerConnect@001" syntax="@yH_OnPlayerConnect@001(playerid)">
			<attribute name="public"/>
			<stacksize value="7"/>
			<dependency name="operator*(_no_itertag:,_:)"/>
			<dependency name="FALSE"/>
			<dependency name="IsPlayerNPC"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Single@Bot"/>
			<dependency name="Iter_Single@Character"/>
			<dependency name="Iter_Single@Player"/>
			<dependency name="Iterator@Bot"/>
			<dependency name="Iterator@Character"/>
			<dependency name="Iterator@Player"/>
			<param name="playerid">
				Player who joined.
			</param>
			  <remarks>  Adds a player to the loop data.  Now sorts the list too.  Note that I found  the most bizzare bug ever (I *think* it may be a compiler but, but it  requires further investigation), basically it seems that multiple variables  were being treated as the same variable (namely @YSII_EgotS and  @YSII_CgharacterS were the same and @YSII_EgotC and @YSII_CgharacterC were the  same).  Adding print statements which reference these variables seem to fix  the problem, and I've tried to make sure that the values will never actually  get printed.  </remarks> 
		</member>
		<member name="M:@yH_OnPlayerDisconnect@001" syntax="@yH_OnPlayerDisconnect@001(playerid, reason)">
			<attribute name="public"/>
			<stacksize value="7"/>
			<dependency name="SetTimerEx"/>
			<dependency name="false"/>
			<param name="playerid">
				Player who left.
			</param>
			<param name="reason">
			</param>
			  <remarks>  Removes a player from the loop data.  No longer uses "hook" to ENSURE  that this is always last.  Previously I think that the order of  evaluation in y_hooks meant that this got called before the user  "OnPlayerDisconnect".  </remarks> 
		</member>
		<member name="M:@yH_OnScriptInit@001" syntax="@yH_OnScriptInit@001()">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="operator*(_no_itertag:,_:)"/>
			<dependency name="FALSE"/>
			<dependency name="GetVehicleModel"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="IsPlayerNPC"/>
			<dependency name="IsValidActor"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Clear_InternalC"/>
			<dependency name="Iter_Single@Actor"/>
			<dependency name="Iter_Single@Bot"/>
			<dependency name="Iter_Single@Character"/>
			<dependency name="Iter_Single@Player"/>
			<dependency name="Iter_Single@Vehicle"/>
			<dependency name="Iterator@Actor"/>
			<dependency name="Iterator@Bot"/>
			<dependency name="Iterator@Character"/>
			<dependency name="Iterator@Player"/>
			<dependency name="Iterator@Vehicle"/>
			<remarks>  Sets up all existing iterators.  Does nothing for "XXLocal" ones, since they  are by definition empty when a script starts.  </remarks> 
		</member>
		<member name="M:@y_HOnPlayerCommandText" syntax="@y_HOnPlayerCommandText()">
			<attribute name="public"/>
			<stacksize value="1"/>
		</member>
		<member name="M:@y_HOnRconCommand" syntax="@y_HOnRconCommand()">
			<attribute name="public"/>
			<stacksize value="1"/>
		</member>
		<member name="M:AMX_DoNothing" syntax="AMX_DoNothing()">
			<stacksize value="1"/>
			<referrer name="AMX_GetGlobal"/>
		</member>
		<member name="M:AMX_DumpHeader" syntax="AMX_DumpHeader()">
			<stacksize value="41"/>
			<dependency name="AMX_GetName"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="printf"/>
			<dependency name="strunpack"/>
		</member>
		<member name="M:AMX_GetBaseCount" syntax="AMX_GetBaseCount(table, &amp;base, &amp;count)">
			<stacksize value="1"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetEntryPrefix"/>
			<referrer name="AMX_GetEntrySuffix"/>
			<referrer name="AMX_GetName"/>
			<referrer name="AMX_GetNamePrefix"/>
			<referrer name="AMX_GetNameSuffix"/>
			<dependency name="AMX_HEADER_LIBRARIES"/>
			<dependency name="AMX_HEADER_NAMETABLE"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_HEADER_PUBVARS"/>
			<dependency name="AMX_HEADER_TAGS"/>
			<dependency name="AMX_TABLE_LIBRARIES"/>
			<dependency name="AMX_TABLE_NATIVES"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="AMX_TABLE_PUBVARS"/>
			<dependency name="AMX_TABLE_TAGS"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="base">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetEntry" syntax="AMX_GetEntry(table, idx, &amp;buffer, pattern[], exact)">
			<stacksize value="42"/>
			<referrer name="AMX_GetPointer"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetFunctionWritePoint"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetEntryFromNativeIndex" syntax="AMX_GetEntryFromNativeIndex(index)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<param name="index">
			</param>
		</member>
		<member name="M:AMX_GetEntryFromPublicIndex" syntax="AMX_GetEntryFromPublicIndex(index)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<param name="index">
			</param>
		</member>
		<member name="M:AMX_GetEntryPointer" syntax="AMX_GetEntryPointer(entry)">
			<stacksize value="1"/>
			<param name="entry">
			</param>
		</member>
		<member name="M:AMX_GetEntryPrefix" syntax="AMX_GetEntryPrefix(table, idx, &amp;buffer, pattern)">
			<stacksize value="9"/>
			<referrer name="AMX_GetPointerPrefix"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_CountInvalidPublics"/>
			<referrer name="CGen_OnCodeInit"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetEntrySuffix" syntax="AMX_GetEntrySuffix(table, idx, &amp;buffer, pattern)">
			<stacksize value="10"/>
			<referrer name="AMX_GetPointerSuffix"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetGlobal" syntax="AMX_GetGlobal()">
			<stacksize value="4"/>
			<referrer name="Debug_OnCodeInit"/>
			<dependency name="AMX_DoNothing"/>
			<dependency name="AMX_HEADER_COD"/>
		</member>
		<member name="M:AMX_GetGlobalAddress" syntax="AMX_GetGlobalAddress(...)">
			<stacksize value="2"/>
			<dependency name="AMX_REAL_DATA"/>
			<param name="...">
			</param>
		</member>
		<member name="M:AMX_GetName" syntax="AMX_GetName(table, idx, buffer[], pattern[], exact)">
			<stacksize value="10"/>
			<referrer name="AMX_DumpHeader"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetNamePrefix" syntax="AMX_GetNamePrefix(table, idx, buffer[], pattern)">
			<stacksize value="9"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetNameSuffix" syntax="AMX_GetNameSuffix(table, idx, buffer[], pattern)">
			<stacksize value="10"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetNativeIndexFromEntry" syntax="AMX_GetNativeIndexFromEntry(entry)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<param name="entry">
			</param>
		</member>
		<member name="M:AMX_GetPointer" syntax="AMX_GetPointer(table, idx, &amp;buffer, pattern[], exact)">
			<stacksize value="9"/>
			<referrer name="AMX_GetValue"/>
			<dependency name="AMX_GetEntry"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetPointerPrefix" syntax="AMX_GetPointerPrefix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<referrer name="AMX_GetValuePrefix"/>
			<referrer name="ScriptInit_PreInitFuncs_"/>
			<referrer name="ScriptInit_PostInitFuncs_"/>
			<referrer name="ScriptInit_PreExitFuncs_"/>
			<referrer name="ScriptInit_PostExitFuncs_"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetPointerSuffix" syntax="AMX_GetPointerSuffix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<referrer name="AMX_GetValueSuffix"/>
			<dependency name="AMX_GetEntrySuffix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetPublicIndexFromEntry" syntax="AMX_GetPublicIndexFromEntry(entry)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<param name="entry">
			</param>
		</member>
		<member name="M:AMX_GetRelativeAddress" syntax="AMX_GetRelativeAddress(...)">
			<stacksize value="2"/>
			<param name="...">
			</param>
		</member>
		<member name="M:AMX_GetStringFromEntry" syntax="AMX_GetStringFromEntry(entry, str[], size)">
			<stacksize value="6"/>
			<referrer name="Hooks_GetAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_ReadString"/>
			<param name="entry">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AMX_GetValue" syntax="AMX_GetValue(table, idx, &amp;buffer, pattern[], exact)">
			<stacksize value="9"/>
			<dependency name="AMX_GetPointer"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetValuePrefix" syntax="AMX_GetValuePrefix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetValueSuffix" syntax="AMX_GetValueSuffix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<dependency name="AMX_GetPointerSuffix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_OnCodeInit" syntax="AMX_OnCodeInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="AddressofResolve"/>
			<dependency name="Indirect_Init"/>
		</member>
		<member name="M:AMX_RawRead" syntax="AMX_RawRead(addr)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:AMX_RawWrite" syntax="AMX_RawWrite(addr, value)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AMX_Read" syntax="AMX_Read(addr)">
			<stacksize value="1"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_InvalidateName"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_CompareNextCell"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="CGen_OnCodeInit"/>
			<referrer name="_Hooks_RepairStub"/>
			<referrer name="Hooks_RepairJITInit"/>
			<referrer name="ScriptInit_OnRuntimeError"/>
			<referrer name="YHNPS_Find"/>
			<referrer name="YHNPS_Insert"/>
			<referrer name="Hooks_OnCodeInit"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:AMX_ReadArray" syntax="AMX_ReadArray(addr, dest[], len)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_ReadString" syntax="AMX_ReadString(addr, str[], len)">
			<stacksize value="5"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetName"/>
			<referrer name="AMX_GetNamePrefix"/>
			<referrer name="AMX_GetNameSuffix"/>
			<referrer name="AMX_GetStringFromEntry"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<dependency name="swapchars"/>
			<param name="addr">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_ReadUnpackedString" syntax="AMX_ReadUnpackedString(addr, str[], len)">
			<stacksize value="2"/>
			<param name="addr">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_TraceCode" syntax="AMX_TraceCode(pattern[], &amp;addrRet, &amp;dataRet, size)">
			<stacksize value="4"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_DAT"/>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="addrRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="dataRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AMX_TraceMemory" syntax="AMX_TraceMemory(pattern[], &amp;addrRet, &amp;dataRet, size)">
			<stacksize value="4"/>
			<dependency name="AMX_HEADER_DAT"/>
			<dependency name="AMX_HEADER_HEA"/>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="addrRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="dataRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AMX_Write" syntax="AMX_Write(addr, value)">
			<stacksize value="1"/>
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="VA_OnCodeInit"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_InvalidateName"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="_Hooks_RepairStub"/>
			<referrer name="Hooks_RepairJITInit"/>
			<referrer name="YHNPS_Insert"/>
			<referrer name="Hooks_OnCodeInit"/>
			<param name="addr">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AMX_WriteArray" syntax="AMX_WriteArray(addr, src[], len)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_WriteString" syntax="AMX_WriteString(addr, str[], len)">
			<stacksize value="4"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<param name="addr">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AbsToRel" syntax="AbsToRel(address)">
			<stacksize value="3"/>
			<referrer name="ReadPhysMemory"/>
			<referrer name="WritePhysMemory"/>
			<referrer name="ReadPhysMemoryCell"/>
			<referrer name="WritePhysMemoryCell"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetDat"/>
			<param name="address">
			</param>
		</member>
		<member name="M:AddPlayerClass" syntax="AddPlayerClass(modelid, spawn_x, spawn_y, spawn_z, z_angle, weapon1, weapon1_ammo, weapon2, weapon2_ammo, weapon3, weapon3_ammo)">
			<attribute name="native"/>
			<referrer name="PawnCmd_OnGameModeInit"/>
			<param name="modelid">
			</param>
			<param name="spawn_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z_angle">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weapon1">
			</param>
			<param name="weapon1_ammo">
			</param>
			<param name="weapon2">
			</param>
			<param name="weapon2_ammo">
			</param>
			<param name="weapon3">
			</param>
			<param name="weapon3_ammo">
			</param>
		</member>
		<member name="M:AddStaticVehicle" syntax="AddStaticVehicle(modelid, spawn_x, spawn_y, spawn_z, z_angle, color1, color2)">
			<attribute name="native"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<param name="modelid">
			</param>
			<param name="spawn_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z_angle">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
		</member>
		<member name="M:AddStaticVehicleEx" syntax="AddStaticVehicleEx(modelid, spawn_x, spawn_y, spawn_z, z_angle, color1, color2, respawn_delay, addsiren)">
			<attribute name="native"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<param name="modelid">
			</param>
			<param name="spawn_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z_angle">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
			<param name="respawn_delay">
			</param>
			<param name="addsiren">
			</param>
		</member>
		<member name="M:AddressofResolve" syntax="AddressofResolve()">
			<stacksize value="753"/>
			<referrer name="Indirect_Init"/>
			<referrer name="AMX_OnCodeInit"/>
			<dependency name="AddressofResolveFoundEnd"/>
			<dependency name="AddressofResolveFoundStart"/>
			<dependency name="CodeScanAddMatcher"/>
			<dependency name="CodeScanInit"/>
			<dependency name="CodeScanMatcher"/>
			<dependency name="CodeScanMatcherInit_"/>
			<dependency name="CodeScanMatcherPattern_"/>
			<dependency name="CodeScanRunFast"/>
			<dependency name="CodeScanner"/>
			<dependency name="GetAmxJITBaseAddress"/>
			<dependency name="O@A_"/>
			<dependency name="O@V_"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_JZER"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="false"/>
			<dependency name="gCodeScanCallback_match"/>
			<dependency name="ref"/>
			<dependency name="true"/>
		</member>
		<member name="M:AddressofResolveFoundEnd" syntax="AddressofResolveFoundEnd(scanner[])">
			<stacksize value="27"/>
			<referrer name="AddressofResolve"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitConstPri"/>
			<dependency name="CodeScanGetMatchAsm"/>
			<dependency name="CodeScanGetMatchHole"/>
			<dependency name="CodeScanGetMatchLength"/>
			<dependency name="cellbits"/>
			<param name="scanner">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:AddressofResolveFoundStart" syntax="AddressofResolveFoundStart(scanner[])">
			<stacksize value="44"/>
			<referrer name="AddressofResolve"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitJump"/>
			<dependency name="CodeScanGetMatchAsm"/>
			<dependency name="CodeScanGetMatchHole"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<param name="scanner">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:AllowInteriorWeapons" syntax="AllowInteriorWeapons(allow)">
			<attribute name="native"/>
			<referrer name="PawnCmd_OnGameModeInit"/>
			<param name="allow">
			</param>
		</member>
		<member name="M:AsmClearError" syntax="AsmClearError(ctx[])">
			<stacksize value="5"/>
			<referrer name="CGen_OOM"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmSetError"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitAdd" syntax="AsmEmitAdd(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADD"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitAddC" syntax="AsmEmitAddC(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADD_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitAddrAlt" syntax="AsmEmitAddrAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADDR_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitAddrPri" syntax="AsmEmitAddrPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADDR_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitAlignAlt" syntax="AsmEmitAlignAlt(ctx[], number)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ALIGN_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="number">
			</param>
		</member>
		<member name="M:AsmEmitAlignPri" syntax="AsmEmitAlignPri(ctx[], number)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ALIGN_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="number">
			</param>
		</member>
		<member name="M:AsmEmitAnd" syntax="AsmEmitAnd(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_AND"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitBounds" syntax="AsmEmitBounds(ctx[], bound)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_BOUNDS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="bound">
			</param>
		</member>
		<member name="M:AsmEmitBreak" syntax="AsmEmitBreak(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_BREAK"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitCall" syntax="AsmEmitCall(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CALL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitCallAbs" syntax="AsmEmitCallAbs(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="24"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="_yH@"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="OP_CALL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitCallLabelStringize" syntax="AsmEmitCallLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_CALL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitCell" syntax="AsmEmitCell(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AsmEmitJumpStringize"/>
			<referrer name="AsmEmitOpcode"/>
			<referrer name="AsmEmitOperand"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="ASM_ERROR_SPACE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="AsmRaiseError"/>
			<dependency name="WriteAmxMemory"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitCmps" syntax="AsmEmitCmps(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CMPS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitConstAlt" syntax="AsmEmitConstAlt(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CONST_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitConstPri" syntax="AsmEmitConstPri(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AddressofResolveFoundEnd"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CONST_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitDec" syntax="AsmEmitDec(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitDecAlt" syntax="AsmEmitDecAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitDecI" syntax="AsmEmitDecI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitDecPri" syntax="AsmEmitDecPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitDecS" syntax="AsmEmitDecS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitEq" syntax="AsmEmitEq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_EQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitEqCAlt" syntax="AsmEmitEqCAlt(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_EQ_C_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitEqCPri" syntax="AsmEmitEqCPri(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_EQ_C_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitFill" syntax="AsmEmitFill(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_FILL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitGeq" syntax="AsmEmitGeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_GEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitGrtr" syntax="AsmEmitGrtr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_GRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitHalt" syntax="AsmEmitHalt(ctx[], code)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_HALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="code">
			</param>
		</member>
		<member name="M:AsmEmitHeap" syntax="AsmEmitHeap(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="_yH@"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_HEAP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitIdxaddr" syntax="AsmEmitIdxaddr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_IDXADDR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIdxaddrB" syntax="AsmEmitIdxaddrB(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_IDXADDR_B"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitInc" syntax="AsmEmitInc(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitIncAlt" syntax="AsmEmitIncAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIncI" syntax="AsmEmitIncI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIncPri" syntax="AsmEmitIncPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIncS" syntax="AsmEmitIncS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitInstruction" syntax="AsmEmitInstruction(ctx[], opcode, ...)">
			<tagname value="AsmError"/>
			<stacksize value="8"/>
			<referrer name="AsmEmitJumpInstruction"/>
			<referrer name="AsmEmitAdd"/>
			<referrer name="AsmEmitAddC"/>
			<referrer name="AsmEmitAddrAlt"/>
			<referrer name="AsmEmitAddrPri"/>
			<referrer name="AsmEmitAlignAlt"/>
			<referrer name="AsmEmitAlignPri"/>
			<referrer name="AsmEmitAnd"/>
			<referrer name="AsmEmitBounds"/>
			<referrer name="AsmEmitBreak"/>
			<referrer name="AsmEmitCall"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="AsmEmitCmps"/>
			<referrer name="AsmEmitConstAlt"/>
			<referrer name="AsmEmitConstPri"/>
			<referrer name="AsmEmitDec"/>
			<referrer name="AsmEmitDecAlt"/>
			<referrer name="AsmEmitDecI"/>
			<referrer name="AsmEmitDecPri"/>
			<referrer name="AsmEmitDecS"/>
			<referrer name="AsmEmitEq"/>
			<referrer name="AsmEmitEqCAlt"/>
			<referrer name="AsmEmitEqCPri"/>
			<referrer name="AsmEmitFill"/>
			<referrer name="AsmEmitGeq"/>
			<referrer name="AsmEmitGrtr"/>
			<referrer name="AsmEmitHalt"/>
			<referrer name="AsmEmitHeap"/>
			<referrer name="AsmEmitIdxaddr"/>
			<referrer name="AsmEmitIdxaddrB"/>
			<referrer name="AsmEmitInc"/>
			<referrer name="AsmEmitIncAlt"/>
			<referrer name="AsmEmitIncI"/>
			<referrer name="AsmEmitIncPri"/>
			<referrer name="AsmEmitIncS"/>
			<referrer name="AsmEmitInvert"/>
			<referrer name="AsmEmitJeq"/>
			<referrer name="AsmEmitJgeq"/>
			<referrer name="AsmEmitJgrtr"/>
			<referrer name="AsmEmitJleq"/>
			<referrer name="AsmEmitJless"/>
			<referrer name="AsmEmitJneq"/>
			<referrer name="AsmEmitJnz"/>
			<referrer name="AsmEmitJsgeq"/>
			<referrer name="AsmEmitJsgrtr"/>
			<referrer name="AsmEmitJsleq"/>
			<referrer name="AsmEmitJsless"/>
			<referrer name="AsmEmitJump"/>
			<referrer name="AsmEmitJzer"/>
			<referrer name="AsmEmitLctrl"/>
			<referrer name="AsmEmitLeq"/>
			<referrer name="AsmEmitLess"/>
			<referrer name="AsmEmitLidx"/>
			<referrer name="AsmEmitLidxB"/>
			<referrer name="AsmEmitLoadAlt"/>
			<referrer name="AsmEmitLoadPri"/>
			<referrer name="AsmEmitLoad"/>
			<referrer name="AsmEmitLoadI"/>
			<referrer name="AsmEmitLoadSAlt"/>
			<referrer name="AsmEmitLoadSPri"/>
			<referrer name="AsmEmitLodbI"/>
			<referrer name="AsmEmitLrefAlt"/>
			<referrer name="AsmEmitLrefPri"/>
			<referrer name="AsmEmitLrefSAlt"/>
			<referrer name="AsmEmitLrefSPri"/>
			<referrer name="AsmEmitMoveAlt"/>
			<referrer name="AsmEmitMovePri"/>
			<referrer name="AsmEmitMovs"/>
			<referrer name="AsmEmitNeg"/>
			<referrer name="AsmEmitNeq"/>
			<referrer name="AsmEmitNop"/>
			<referrer name="AsmEmitNot"/>
			<referrer name="AsmEmitOr"/>
			<referrer name="AsmEmitPopAlt"/>
			<referrer name="AsmEmitPopPri"/>
			<referrer name="AsmEmitProc"/>
			<referrer name="AsmEmitPushAdr"/>
			<referrer name="AsmEmitPushAlt"/>
			<referrer name="AsmEmitPushC"/>
			<referrer name="AsmEmitPushPri"/>
			<referrer name="AsmEmitPush"/>
			<referrer name="AsmEmitPushS"/>
			<referrer name="AsmEmitRet"/>
			<referrer name="AsmEmitRetn"/>
			<referrer name="AsmEmitSctrl"/>
			<referrer name="AsmEmitSdiv"/>
			<referrer name="AsmEmitSdivAlt"/>
			<referrer name="AsmEmitSgeq"/>
			<referrer name="AsmEmitSgrtr"/>
			<referrer name="AsmEmitShl"/>
			<referrer name="AsmEmitShlCAlt"/>
			<referrer name="AsmEmitShlCPri"/>
			<referrer name="AsmEmitShrCAlt"/>
			<referrer name="AsmEmitShrCPri"/>
			<referrer name="AsmEmitShr"/>
			<referrer name="AsmEmitSignAlt"/>
			<referrer name="AsmEmitSignPri"/>
			<referrer name="AsmEmitSleq"/>
			<referrer name="AsmEmitSless"/>
			<referrer name="AsmEmitSmul"/>
			<referrer name="AsmEmitSmulC"/>
			<referrer name="AsmEmitSshr"/>
			<referrer name="AsmEmitSrefAlt"/>
			<referrer name="AsmEmitSrefPri"/>
			<referrer name="AsmEmitSrefSAlt"/>
			<referrer name="AsmEmitSrefSPri"/>
			<referrer name="AsmEmitStack"/>
			<referrer name="AsmEmitStorAlt"/>
			<referrer name="AsmEmitStorPri"/>
			<referrer name="AsmEmitStorI"/>
			<referrer name="AsmEmitStorSAlt"/>
			<referrer name="AsmEmitStorSPri"/>
			<referrer name="AsmEmitStrbI"/>
			<referrer name="AsmEmitSub"/>
			<referrer name="AsmEmitSubAlt"/>
			<referrer name="AsmEmitSwapAlt"/>
			<referrer name="AsmEmitSwapPri"/>
			<referrer name="AsmEmitSysreqC"/>
			<referrer name="AsmEmitSysreqD"/>
			<referrer name="AsmEmitSysreqPri"/>
			<referrer name="AsmEmitUdiv"/>
			<referrer name="AsmEmitUdivAlt"/>
			<referrer name="AsmEmitUmul"/>
			<referrer name="AsmEmitXchg"/>
			<referrer name="AsmEmitXor"/>
			<referrer name="AsmEmitZero"/>
			<referrer name="AsmEmitZeroAlt"/>
			<referrer name="AsmEmitZeroPri"/>
			<referrer name="AsmEmitZeroS"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitOpcode"/>
			<dependency name="AsmEmitOperand"/>
			<dependency name="gPreviousWriteOffset"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="...">
			</param>
		</member>
		<member name="M:AsmEmitInvert" syntax="AsmEmitInvert(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INVERT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJeq" syntax="AsmEmitJeq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJeqLabelStringize" syntax="AsmEmitJeqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJeqRel" syntax="AsmEmitJeqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJgeq" syntax="AsmEmitJgeq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJgeqLabelStringize" syntax="AsmEmitJgeqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJgeqRel" syntax="AsmEmitJgeqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJgrtr" syntax="AsmEmitJgrtr(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJgrtrLabelStringize" syntax="AsmEmitJgrtrLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJgrtrRel" syntax="AsmEmitJgrtrRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJleq" syntax="AsmEmitJleq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJleqLabelStringize" syntax="AsmEmitJleqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJleqRel" syntax="AsmEmitJleqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJless" syntax="AsmEmitJless(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJlessLabelStringize" syntax="AsmEmitJlessLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJlessRel" syntax="AsmEmitJlessRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJneq" syntax="AsmEmitJneq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JNEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJneqLabelStringize" syntax="AsmEmitJneqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JNEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJneqRel" syntax="AsmEmitJneqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JNEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJnz" syntax="AsmEmitJnz(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JNZ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJnzLabelStringize" syntax="AsmEmitJnzLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JNZ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJnzRel" syntax="AsmEmitJnzRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JNZ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJrel" syntax="AsmEmitJrel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JREL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJrelLabelStringize" syntax="AsmEmitJrelLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JREL"/>
			<dependency name="true"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsgeq" syntax="AsmEmitJsgeq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJsgeqLabelStringize" syntax="AsmEmitJsgeqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsgeqRel" syntax="AsmEmitJsgeqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJsgrtr" syntax="AsmEmitJsgrtr(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJsgrtrLabelStringize" syntax="AsmEmitJsgrtrLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsgrtrRel" syntax="AsmEmitJsgrtrRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJsleq" syntax="AsmEmitJsleq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJsleqLabelStringize" syntax="AsmEmitJsleqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsleqRel" syntax="AsmEmitJsleqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJsless" syntax="AsmEmitJsless(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJslessLabelStringize" syntax="AsmEmitJslessLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJslessRel" syntax="AsmEmitJslessRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJump" syntax="AsmEmitJump(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AddressofResolveFoundStart"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JUMP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJumpInstruction" syntax="AsmEmitJumpInstruction(ctx[], opcode, offset)">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="AsmEmitJeqRel"/>
			<referrer name="AsmEmitJgeqRel"/>
			<referrer name="AsmEmitJgrtrRel"/>
			<referrer name="AsmEmitJleqRel"/>
			<referrer name="AsmEmitJlessRel"/>
			<referrer name="AsmEmitJneqRel"/>
			<referrer name="AsmEmitJnzRel"/>
			<referrer name="AsmEmitJsgeqRel"/>
			<referrer name="AsmEmitJsgrtrRel"/>
			<referrer name="AsmEmitJsleqRel"/>
			<referrer name="AsmEmitJslessRel"/>
			<referrer name="AsmEmitJumpRel"/>
			<referrer name="AsmEmitJzerRel"/>
			<referrer name="AsmEmitJrel"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="AsmGetJumpAddressFromOffset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJumpLabelInstruction" syntax="AsmEmitJumpLabelInstruction(ctx[], opcode, label[], relative)">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="AsmEmitCallLabelStringize"/>
			<referrer name="AsmEmitJeqLabelStringize"/>
			<referrer name="AsmEmitJgeqLabelStringize"/>
			<referrer name="AsmEmitJgrtrLabelStringize"/>
			<referrer name="AsmEmitJleqLabelStringize"/>
			<referrer name="AsmEmitJlessLabelStringize"/>
			<referrer name="AsmEmitJneqLabelStringize"/>
			<referrer name="AsmEmitJnzLabelStringize"/>
			<referrer name="AsmEmitJsgeqLabelStringize"/>
			<referrer name="AsmEmitJsgrtrLabelStringize"/>
			<referrer name="AsmEmitJsleqLabelStringize"/>
			<referrer name="AsmEmitJslessLabelStringize"/>
			<referrer name="AsmEmitJumpLabelStringize"/>
			<referrer name="AsmEmitJzerLabelStringize"/>
			<referrer name="AsmEmitJrelLabelStringize"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitJumpStringize"/>
			<dependency name="AsmEmitOpcode"/>
			<dependency name="gPreviousWriteOffset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="relative">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJumpLabelStringize" syntax="AsmEmitJumpLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JUMP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJumpRel" syntax="AsmEmitJumpRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JUMP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJumpStringize" syntax="AsmEmitJumpStringize(ctx[], label[], relative)">
			<tagname value="AsmError"/>
			<stacksize value="10"/>
			<referrer name="AsmEmitJumpLabelInstruction"/>
			<dependency name="ASM_ERROR_LABEL_OVERFLOW"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_label_names"/>
			<dependency name="AsmContext_labels"/>
			<dependency name="AsmEmitCell"/>
			<dependency name="AsmFindLabelIndex"/>
			<dependency name="AsmHashLabel"/>
			<dependency name="AsmRaiseError"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="relative">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJzer" syntax="AsmEmitJzer(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JZER"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJzerLabelStringize" syntax="AsmEmitJzerLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JZER"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJzerRel" syntax="AsmEmitJzerRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JZER"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLabelStringize" syntax="AsmEmitLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="11"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="ASM_ERROR_LABEL_DUPLICATE"/>
			<dependency name="ASM_ERROR_LABEL_OVERFLOW"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_label_names"/>
			<dependency name="AsmContext_labels"/>
			<dependency name="AsmFindLabelIndex"/>
			<dependency name="AsmGetJumpAddressFromOffset"/>
			<dependency name="AsmHashLabel"/>
			<dependency name="AsmRaiseError"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="WriteAmxMemory"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLctrl" syntax="AsmEmitLctrl(ctx[], index)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LCTRL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:AsmEmitLeq" syntax="AsmEmitLeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLess" syntax="AsmEmitLess(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLidx" syntax="AsmEmitLidx(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LIDX"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLidxB" syntax="AsmEmitLidxB(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LIDX_B"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitLoad" syntax="AsmEmitLoad(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLoadAlt" syntax="AsmEmitLoadAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLoadI" syntax="AsmEmitLoadI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLoadPri" syntax="AsmEmitLoadPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLoadSAlt" syntax="AsmEmitLoadSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLoadSPri" syntax="AsmEmitLoadSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLodbI" syntax="AsmEmitLodbI(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LODB_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitLrefAlt" syntax="AsmEmitLrefAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLrefPri" syntax="AsmEmitLrefPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLrefSAlt" syntax="AsmEmitLrefSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLrefSPri" syntax="AsmEmitLrefSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitMoveAlt" syntax="AsmEmitMoveAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_MOVE_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitMovePri" syntax="AsmEmitMovePri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_MOVE_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitMovs" syntax="AsmEmitMovs(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_MOVS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitNeg" syntax="AsmEmitNeg(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NEG"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitNeq" syntax="AsmEmitNeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitNop" syntax="AsmEmitNop(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NOP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitNot" syntax="AsmEmitNot(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NOT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitOpcode" syntax="AsmEmitOpcode(ctx[], opcode)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AsmEmitInstruction"/>
			<referrer name="AsmEmitJumpLabelInstruction"/>
			<dependency name="ASM_ERROR_OPCODE"/>
			<dependency name="AsmEmitCell"/>
			<dependency name="AsmRaiseError"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="RelocateOpcode"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitOperand" syntax="AsmEmitOperand(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AsmEmitInstruction"/>
			<dependency name="AsmEmitCell"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitOr" syntax="AsmEmitOr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_OR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPadding" syntax="AsmEmitPadding(ctx[], op)">
			<stacksize value="7"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="GetOpcodeInstructionParameters"/>
			<dependency name="IsOpcodeValid"/>
			<dependency name="OP_NOP"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="WriteAmxMemory"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="op">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPopAlt" syntax="AsmEmitPopAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_POP_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPopArgs" syntax="AsmEmitPopArgs(ctx[], n)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitStack"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmEmitPopPri" syntax="AsmEmitPopPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="YVA2_CodeGenDeepCleanup"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_POP_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitProc" syntax="AsmEmitProc(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PROC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPush" syntax="AsmEmitPush(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitPushAdr" syntax="AsmEmitPushAdr(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_ADR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitPushAlt" syntax="AsmEmitPushAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPushArg" syntax="AsmEmitPushArg(ctx[], n)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitPushS"/>
			<dependency name="AsmGetArgOffset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmEmitPushC" syntax="AsmEmitPushC(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitPushNumArgs"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitPushNumArgs" syntax="AsmEmitPushNumArgs(ctx[], n)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitPushC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmEmitPushPri" syntax="AsmEmitPushPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPushS" syntax="AsmEmitPushS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitPushArg"/>
			<referrer name="YVA2_CodeGenPushVariable"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitRet" syntax="AsmEmitRet(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_RET"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitRetn" syntax="AsmEmitRetn(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_RETN"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSctrl" syntax="AsmEmitSctrl(ctx[], index)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SCTRL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:AsmEmitSdiv" syntax="AsmEmitSdiv(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SDIV"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSdivAlt" syntax="AsmEmitSdivAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SDIV_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSgeq" syntax="AsmEmitSgeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSgrtr" syntax="AsmEmitSgrtr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitShl" syntax="AsmEmitShl(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitShlCAlt" syntax="AsmEmitShlCAlt(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHL_C_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitShlCPri" syntax="AsmEmitShlCPri(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHL_C_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitShr" syntax="AsmEmitShr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitShrCAlt" syntax="AsmEmitShrCAlt(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHR_C_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitShrCPri" syntax="AsmEmitShrCPri(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHR_C_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitSignAlt" syntax="AsmEmitSignAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SIGN_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSignPri" syntax="AsmEmitSignPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SIGN_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSleq" syntax="AsmEmitSleq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSless" syntax="AsmEmitSless(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSmul" syntax="AsmEmitSmul(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SMUL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSmulC" syntax="AsmEmitSmulC(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SMUL_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitSrefAlt" syntax="AsmEmitSrefAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitSrefPri" syntax="AsmEmitSrefPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitSrefSAlt" syntax="AsmEmitSrefSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitSrefSPri" syntax="AsmEmitSrefSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitSshr" syntax="AsmEmitSshr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SSHR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitStack" syntax="AsmEmitStack(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitPopArgs"/>
			<referrer name="YVA2_CodeGenDeepCleanup"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STACK"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitStorAlt" syntax="AsmEmitStorAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitStorI" syntax="AsmEmitStorI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitStorPri" syntax="AsmEmitStorPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitStorSAlt" syntax="AsmEmitStorSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitStorSPri" syntax="AsmEmitStorSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitStrbI" syntax="AsmEmitStrbI(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STRB_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitSub" syntax="AsmEmitSub(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SUB"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSubAlt" syntax="AsmEmitSubAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SUB_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSwapAlt" syntax="AsmEmitSwapAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SWAP_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSwapPri" syntax="AsmEmitSwapPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SWAP_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSysreq" syntax="AsmEmitSysreq(ctx[], name[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitSysreqC"/>
			<dependency name="GetNativeIndexFromName"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSysreqC" syntax="AsmEmitSysreqC(ctx[], index)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitSysreq"/>
			<referrer name="_yH@"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SYSREQ_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:AsmEmitSysreqD" syntax="AsmEmitSysreqD(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SYSREQ_D"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitSysreqPri" syntax="AsmEmitSysreqPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SYSREQ_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitUdiv" syntax="AsmEmitUdiv(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_UDIV"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitUdivAlt" syntax="AsmEmitUdivAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_UDIV_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitUmul" syntax="AsmEmitUmul(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_UMUL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitXchg" syntax="AsmEmitXchg(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_XCHG"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitXor" syntax="AsmEmitXor(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_XOR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitZero" syntax="AsmEmitZero(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitZeroAlt" syntax="AsmEmitZeroAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitZeroPri" syntax="AsmEmitZeroPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitZeroS" syntax="AsmEmitZeroS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmFindLabelIndex" syntax="AsmFindLabelIndex(ctx[], hash)">
			<stacksize value="2"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpStringize"/>
			<dependency name="AsmContext_label_names"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="hash">
			</param>
		</member>
		<member name="M:AsmGetArgOffset" syntax="AsmGetArgOffset(n)">
			<stacksize value="1"/>
			<referrer name="AsmEmitPushArg"/>
			<dependency name="ASM_ARGUMENTS_OFFSET"/>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmGetBufferSize" syntax="AsmGetBufferSize(ctx[])">
			<stacksize value="1"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetCode" syntax="AsmGetCode(ctx[])">
			<stacksize value="21"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="GetAmxHeader"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetCodeSize" syntax="AsmGetCodeSize(ctx[])">
			<stacksize value="1"/>
			<dependency name="AsmContext_buffer_offset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetError" syntax="AsmGetError(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="1"/>
			<referrer name="CGen_OOM"/>
			<dependency name="AsmContext_error"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetErrorHandler" syntax="AsmGetErrorHandler(ctx[])">
			<stacksize value="1"/>
			<dependency name="AsmContext_error_handler"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetJumpAddressFromOffset" syntax="AsmGetJumpAddressFromOffset(ctx[], offset)">
			<stacksize value="22"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpInstruction"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmGetPreviousWriteOffset" syntax="AsmGetPreviousWriteOffset()">
			<stacksize value="1"/>
			<dependency name="gPreviousWriteOffset"/>
		</member>
		<member name="M:AsmHashLabel" syntax="AsmHashLabel(label[])">
			<stacksize value="4"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpStringize"/>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmInit" syntax="AsmInit(ctx[], buffer[], size)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="ref"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="buffer">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AsmInitPtr" syntax="AsmInitPtr(ctx[], buffer, size)">
			<tagname value="AsmError"/>
			<stacksize value="2"/>
			<referrer name="AsmInit"/>
			<referrer name="CodeScanGetFunctionAsm"/>
			<referrer name="CodeScanGetMatchAsm"/>
			<referrer name="CGen_UseCodeSpace"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="AsmContext_error_handler"/>
			<dependency name="AsmContext_label_names"/>
			<dependency name="AsmContext_labels"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="buffer">
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AsmRaiseError" syntax="AsmRaiseError(ctx[], error)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitCell"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpStringize"/>
			<referrer name="AsmEmitOpcode"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_error_handler"/>
			<dependency name="AsmSetError"/>
			<dependency name="CallFunction"/>
			<dependency name="ref"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error">
				<paraminfo>AsmError </paraminfo>
			</param>
		</member>
		<member name="M:AsmSetError" syntax="AsmSetError(ctx[], error)">
			<stacksize value="1"/>
			<referrer name="AsmRaiseError"/>
			<referrer name="AsmClearError"/>
			<dependency name="AsmContext_error"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error">
				<paraminfo>AsmError </paraminfo>
			</param>
		</member>
		<member name="M:AsmSetErrorHandler" syntax="AsmSetErrorHandler(ctx[], error_handler)">
			<tagname value="AsmError"/>
			<stacksize value="1"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_error_handler"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error_handler">
			</param>
		</member>
		<member name="M:AsmSetErrorHandlerName" syntax="AsmSetErrorHandlerName(ctx[], error_handler[])">
			<tagname value="AsmError"/>
			<stacksize value="4"/>
			<referrer name="CGen_UseCodeSpace"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_error_handler"/>
			<dependency name="GetPublicAddressFromName"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error_handler">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:BAN_TIMER" syntax="BAN_TIMER(playerid)">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="Ban"/>
			<dependency name="true"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Ban" syntax="Ban(playerid)">
			<attribute name="native"/>
			<referrer name="BAN_TIMER"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Base64Decode" syntax="Base64Decode(dest[], src[], len, offset)">
			<stacksize value="4"/>
			<dependency name="cellbits"/>
			<dependency name="min"/>
			<dependency name="strlen"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
			<param name="offset">
			</param>
			<summary>  Base64Decode  </summary>  <remarks>  Decodes data using proper base64.  </remarks> 
		</member>
		<member name="M:Base64Encode" syntax="Base64Encode(dest[], src[], num, len, offset)">
			<stacksize value="1"/>
			<dependency name="cellbits"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="num">
			</param>
			<param name="len">
			</param>
			<param name="offset">
			</param>
			<summary>  Base64Encode  </summary>  <remarks>  Encodes data using proper base64.  This code is complicated by the fact that  PAWN packed strings are backwards by cells in memory, so we need to do the  writes in what seems like a strange order.  </remarks> 
		</member>
		<member name="M:C@" syntax="C@(function[], fmat[], ...)">
			<stacksize value="9"/>
			<dependency name="@_"/>
			<dependency name="C@"/>
			<dependency name="CallLocalFunction"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="Q@"/>
			<dependency name="YSI_g_sCallData"/>
			<dependency name="YSI_g_sPropCaller"/>
			<dependency name="YSI_g_sPropEmpty"/>
			<dependency name="YSI_g_sPropVarArg"/>
			<dependency name="YSI_g_sYSIM_STRING"/>
			<dependency name="YSI_g_sYSI_MAX_STRING"/>
			<dependency name="getproperty"/>
			<dependency name="setarg"/>
			<dependency name="setproperty"/>
			<dependency name="strunpack"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:CGEN" syntax="CGEN(&amp;a, &amp;b, &amp;c, &amp;d, &amp;e, &amp;f, &amp;g, &amp;h, &amp;i, &amp;j, &amp;k, &amp;l, &amp;m, &amp;n, &amp;o, &amp;p, &amp;q, &amp;r, &amp;s, &amp;t, &amp;u, &amp;v, &amp;w, &amp;x, &amp;y, &amp;z)">
			<stacksize value="1"/>
			<referrer name="_@_y_cgen_@_0"/>
			<param name="a">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="b">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="c">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="d">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="e">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="f">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="g">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="h">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="i">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="j">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="k">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="l">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="m">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="n">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="o">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="p">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="q">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="r">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="s">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="t">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="u">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="v">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="w">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="x">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="y">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="z">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CGen_AddCodeSpace" syntax="CGen_AddCodeSpace(num)">
			<stacksize value="4"/>
			<referrer name="Hooks_GenerateCode"/>
			<dependency name="Debug_Print0"/>
			<dependency name="YSI_g_sCodeSpace"/>
			<param name="num">
			</param>
		</member>
		<member name="M:CGen_GetAddr" syntax="CGen_GetAddr(func[])">
			<stacksize value="4"/>
			<referrer name="CGen_SetupCodeSpace"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="funcidx"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CGen_GetCodeSpace" syntax="CGen_GetCodeSpace()">
			<stacksize value="1"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="YSI_g_sCodeSpace"/>
		</member>
		<member name="M:CGen_OOM" syntax="CGen_OOM(ctx[])">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="ASM_ERROR_LABEL_DUPLICATE"/>
			<dependency name="ASM_ERROR_LABEL_OVERFLOW"/>
			<dependency name="ASM_ERROR_OPCODE"/>
			<dependency name="ASM_ERROR_OPERAND"/>
			<dependency name="ASM_ERROR_SPACE"/>
			<dependency name="AsmClearError"/>
			<dependency name="AsmGetError"/>
			<dependency name="Debug_Print0"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:CGen_OnCodeInit" syntax="CGen_OnCodeInit()">
			<attribute name="public"/>
			<stacksize value="9"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="CallFunction"/>
			<dependency name="Hooks_DoAllHooks"/>
			<dependency name="Hooks_InvalidateName"/>
			<dependency name="Hooks_RepairJITInit"/>
			<dependency name="Hooks_SortPublics"/>
			<dependency name="Hooks_SortReplacements"/>
			<dependency name="Server_JITExists"/>
			<dependency name="YSI_g_sInitFSIdx"/>
			<dependency name="YSI_g_sInitGMIdx"/>
			<dependency name="funcidx"/>
			<remarks>  Call the main hook run code, then advance the ALS chain.  </remarks>  <transition keep="true" target="_ALS : _ALS_go"/>  <transition target="_ALS_go"/>

		</member>
		<member name="M:CGen_SetupCodeSpace" syntax="CGen_SetupCodeSpace()">
			<stacksize value="5"/>
			<referrer name="VA_OnCodeInit"/>
			<dependency name="AMX_Write"/>
			<dependency name="CGen_GetAddr"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_RETN"/>
			<dependency name="OP_ZERO_PRI"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="YSI_g_sCodeEnd"/>
			<dependency name="YSI_g_sCodeSpace"/>
		</member>
		<member name="M:CGen_UseCodeSpace" syntax="CGen_UseCodeSpace(ctx[])">
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="AsmSetErrorHandlerName"/>
			<dependency name="YSI_g_sCodeEnd"/>
			<dependency name="YSI_g_sCodeSpace"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:Call" syntax="Call(address, auto_pop)">
			<stacksize value="5"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:CallFunction" syntax="CallFunction(address, ...)">
			<stacksize value="5"/>
			<referrer name="AsmRaiseError"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="CGen_OnCodeInit"/>
			<param name="address">
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallLocalFunction" syntax="CallLocalFunction(function[], format[], ...)">
			<attribute name="native"/>
			<referrer name="C@"/>
			<referrer name="D@"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallN" syntax="CallN(address, args_to_push, auto_pop)">
			<stacksize value="6"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="args_to_push">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:CallNative" syntax="CallNative(index, ...)">
			<stacksize value="8"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<param name="index">
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallNativeByAddress" syntax="CallNativeByAddress(address, ...)">
			<stacksize value="8"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<param name="address">
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallRemoteFunction" syntax="CallRemoteFunction(function[], format[], ...)">
			<attribute name="native"/>
			<referrer name="C@"/>
			<referrer name="D@"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CancelSelectTextDraw" syntax="CancelSelectTextDraw(playerid)">
			<attribute name="native"/>
			<referrer name="OnDialogResponse"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Cell_CompressRight" syntax="Cell_CompressRight(x, m)">
			<stacksize value="12"/>
			<dependency name="Cell_CompressRightPrecomputed"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<param name="x">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				The number to compress.
			</param>
			<param name="m">
				The mask for which bits to compress.
			</param>
			<summary>  Cell_CompressRight(GLOBAL_TAG_TYPES:x, m);  </summary>      <returns>  Selected bits from "x", shifted to be LSBs.  </returns>  <remarks>  Doesn't require precomputation.  </remarks> 
		</member>
		<member name="M:Cell_CompressRightPrecomputed" syntax="Cell_CompressRightPrecomputed(x, m, masks[])">
			<stacksize value="2"/>
			<referrer name="Cell_CompressRight"/>
			<param name="x">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				The number to compress.
			</param>
			<param name="m">
				The mask for which bits to compress.
			</param>
			<param name="masks">
				<paraminfo> [5] </paraminfo>
				Precomputed constants for the compression.
			</param>
			<summary>  Cell_CompressRightPrecomputed(GLOBAL_TAG_TYPES:x, m, masks[5]);  </summary>        <returns>  Selected bits from "x", shifted to be LSBs.  </returns>  <remarks>  Very briefly, do "x &amp; m", to select certain bits, then shift those bits  by various amounts so that they are consecutive:  x = 0b110011  m = 0b011010  x &amp; m = 0b010010  From here, because the mask was three bits we know we want just those three  bits in the LSBs, so the answer becomes:  0b000101  Just read this question, it has a diagram:  <a href="http://stackoverflow.com/questions/28282869/shift-masked-bits-to-the-lsb" />  </remarks> 
		</member>
		<member name="M:Cell_CountBits" syntax="Cell_CountBits(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_CountBits(number);  </summary>  <param name="number">The number to get the number of 1s in.</param>  <returns>  The number of 1s (set bits) in the input.  </returns>  <remarks>  1)  Example: 0  Returns: 0  2)  Example: 1  Returns: 1  3)  Example: 0x01010101  Returns: 4  I rewrote this in assembly just to see if I could pretty much.  I also  rewrote the lookup version in assembly.  In theory it should be faster, but  the marshalling of data was a little awkward.  </remarks> 
		</member>
		<member name="M:Cell_CountBlanks" syntax="Cell_CountBlanks(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_CountBlanks(number);  </summary>  <param name="number">The number to get the number of 0s in.</param>  <returns>  The number of 0s (unset bits) in the input.  </returns>  <remarks>  Like Cell_CountBits, but for 0s not 1s.  </remarks> 
		</member>
		<member name="M:Cell_ExpandLeft" syntax="Cell_ExpandLeft(x, m)">
			<stacksize value="12"/>
			<dependency name="Cell_ExpandLeftPrecomputed"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<param name="x">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				The number to expand.
			</param>
			<param name="m">
				The mask for which bits to expand to.
			</param>
			<summary>  Cell_ExpandLeft(GLOBAL_TAG_TYPES:x, m)  </summary>      <returns>  LSBs from "x", shifted to selected bit positions.  </returns>  <remarks>  Doesn't require precomputation.  </remarks> 
		</member>
		<member name="M:Cell_ExpandLeftPrecomputed" syntax="Cell_ExpandLeftPrecomputed(x, m, masks[])">
			<stacksize value="2"/>
			<referrer name="Cell_ExpandLeft"/>
			<param name="x">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				The number to expand.
			</param>
			<param name="m">
				The mask for which bits to expand to.
			</param>
			<param name="masks">
				<paraminfo> [5] </paraminfo>
				Precomputed constants for the expansion.
			</param>
			<summary>  Cell_ExpandLeftPrecomputed(GLOBAL_TAG_TYPES:x, m, masks[5])  </summary>        <returns>  LSBs from "x", shifted to selected bit positions.  </returns>  <remarks>  The reverse of "Cell_CompressRightPrecomputed".  Doesn't return exactly the  original number before a compression, just the original number ANDed with  the mask "m".  </remarks> 
		</member>
		<member name="M:Cell_GetLowestBit" syntax="Cell_GetLowestBit(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestBit(number);  </summary>  <param name="number">The number to get the lowest set bit of.</param>  <returns>  The integer position of the lowest set bit.  </returns>  <remarks>  1)  Example: 0b00000000000000000000000000000001  Returns: 0  2)  Example: 0b00000000000000000000000000001000  Returns: 3  3)  Example: 0b00010001100011000011100010001000  Returns: 3  NOTE: This function returns "0" for both numbers with the "1" bit set AND  the number "0", which has NO bits set.  Check that the number is valid  before passing it to this function.  See: <a href="http://supertech.csail.mit.edu/papers/debruijn.pdf" />  </remarks> 
		</member>
		<member name="M:Cell_GetLowestBitEx" syntax="Cell_GetLowestBitEx(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestBitEx(number);  </summary>  <param name="number">The number to get the lowest set bit of PLUS ONE.</param>  <returns>  The integer position of the lowest set bit PLUS ONE.  </returns>  <remarks>  This function is identical to "Cell_GetLowestBit", but gives different  results for 0 and non-zero numbers.  The examples below all have a result  one higher than the "Cell_GetLowestBit" function.  1)  Example: 0b00000000000000000000000000000001  Returns: 1  2)  Example: 0b00000000000000000000000000001000  Returns: 4  3)  Example: 0b00010001100011000011100010001000  Returns: 4  4)  Example: 0  Returns: 0  See: <a href="http://supertech.csail.mit.edu/papers/debruijn.pdf" />  </remarks> 
		</member>
		<member name="M:Cell_GetLowestBlank" syntax="Cell_GetLowestBlank(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestBlank(number);  </summary>  <param name="number">The number to get the lowest unset bit of.</param>  <returns>  The integer position of the lowest unset bit.  </returns>  <remarks>  Like Cell_GetLowestBit, but for 0s not 1s.  </remarks> 
		</member>
		<member name="M:Cell_GetLowestBlankEx" syntax="Cell_GetLowestBlankEx(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestBlankEx(number);  </summary>  <param name="number">The number to get the lowest unset bit of PLUS ONE.</param>  <returns>  The integer position of the lowest unset bit PLUS ONE.  </returns>  <remarks>  Like Cell_GetLowestBitEx, but for 0s not 1s.  </remarks> 
		</member>
		<member name="M:Cell_GetLowestComponent" syntax="Cell_GetLowestComponent(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestComponent(number);  </summary>  <param name="number">The number to get the lowest 1 in.</param>  <returns>  The lowest set bit.  </returns>  <remarks>  Similar to Cell_GetLowestBit, but returns the bit, not the position of the  bit.  1)  Example: 0b00000000000000000000000000000001  Returns: 0b00000000000000000000000000000001  2)  Example: 0b00000000000000000000000000001000  Returns: 0b00000000000000000000000000001000  3)  Example: 0b00010001100011000011100010001000  Returns: 0b00000000000000000000000000001000  4)  Example: 0b00000000000000000000000000000000  Returns: 0b00000000000000000000000000000000  </remarks> 
		</member>
		<member name="M:Cell_GetLowestEmpty" syntax="Cell_GetLowestEmpty(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestEmpty(number);  </summary>  <param name="number">The number to get the lowest 0 in.</param>  <returns>  The lowest unset bit.  </returns>  <remarks>  Like Cell_GetLowestComponent, but for 0s not 1s.  </remarks> 
		</member>
		<member name="M:Cell_PrecomputeMaskPermutation" syntax="Cell_PrecomputeMaskPermutation(m)">
			<stacksize value="10"/>
			<referrer name="Cell_CompressRight"/>
			<referrer name="Cell_ExpandLeft"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<param name="m">
				The mask.
			</param>
			<summary>  Cell_PrecomputeMaskPermutation(m)  </summary>    <returns>  Five precomputed constants to help expand or contract this mask.  </returns>  <remarks>  The full maths for generalised expansion and contraction is quite complex;  however, much of the inner loop relies only on the mask and not on the value  being manipulated.  Given this we can do a lot of work in advance, say  outside a loop, to avoid repeated calculations.  </remarks> 
		</member>
		<member name="M:Cell_ReverseBits" syntax="Cell_ReverseBits(data)">
			<stacksize value="1"/>
			<dependency name="swapchars"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_ReverseBits(number);  </summary>  <param name="number">The number to manipulate.</param>  <returns>  All the bits in the input reversed.  </returns>  <remarks>  1)  Example: 0b11110000000000000000000000000000  Becomes: 0b00000000000000000000000000001111  2)  Example: 0b10110011100011110000111110000010  Becomes: 0b01000001111100001111000111001101  3)  Example: 0b01010101010101010101010101010101  Becomes: 0b10101010101010101010101010101010  </remarks> 
		</member>
		<member name="M:Cell_ReverseBytes" syntax="Cell_ReverseBytes(data)">
			<stacksize value="3"/>
			<referrer name="Hooks_CompareNextCell"/>
			<dependency name="swapchars"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_ReverseBytes(number);  </summary>  <param name="number">The number to manipulate.</param>  <returns>  All the bytes in the input reversed.  </returns>  <remarks>  1)  Example: 0x12345678  Becomes: 0x78563412  2)  Example: 0x01020304  Becomes: 0x04030201  3)  Example: 0xFF00FF00  Becomes: 0x00FF00FF  </remarks> 
		</member>
		<member name="M:Cell_ReverseNibbles" syntax="Cell_ReverseNibbles(data)">
			<stacksize value="1"/>
			<dependency name="swapchars"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_ReverseNibbles(number);  </summary>  <param name="number">The number to manipulate.</param>  <returns>  All the nibbles (4-bit chunks) in the input reversed.  </returns>  <remarks>  1)  Example: 0x12345678  Becomes: 0x87654321  2)  Example: 0x010F0703  Becomes: 0x3070F010  3)  Example: 0xF0F0F0F0  Becomes: 0x0F0F0F0F  </remarks> 
		</member>
		<member name="M:CodeScanAddJumpTarget" syntax="CodeScanAddJumpTarget(cip, stk, hea, jumpTargets[], num)">
			<stacksize value="4"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_jump_heap"/>
			<dependency name="CodeScanner_jump_stack"/>
			<dependency name="CodeScanner_jump_switch"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<dependency name="min"/>
			<param name="cip">
			</param>
			<param name="stk">
			</param>
			<param name="hea">
			</param>
			<param name="jumpTargets">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanAddMatcher" syntax="CodeScanAddMatcher(scanner[], searcher[])">
			<stacksize value="4"/>
			<referrer name="AddressofResolve"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="ref"/>
			<param name="scanner">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanAddSwitchTarget" syntax="CodeScanAddSwitchTarget(dctx[], stk, hea, jumpTargets[], num)">
			<stacksize value="6"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="CodeScanner_jump_heap"/>
			<dependency name="CodeScanner_jump_stack"/>
			<dependency name="CodeScanner_jump_switch"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="cellbits"/>
			<dependency name="gBase"/>
			<dependency name="gHdr"/>
			<dependency name="gOP_CASETBL"/>
			<dependency name="min"/>
			<param name="dctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="stk">
			</param>
			<param name="hea">
			</param>
			<param name="jumpTargets">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanCall" syntax="CodeScanCall(cs[], csState[])">
			<stacksize value="3"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_func"/>
			<dependency name="CodeScanMatcher_user_data"/>
			<param name="cs">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="csState">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanCheck" syntax="CodeScanCheck(op, dctx[], cs[], fctx[], &amp;next)">
			<tagname value="bool"/>
			<stacksize value="12"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanMatch_hole_count"/>
			<dependency name="CodeScanMatch_holes"/>
			<dependency name="CodeScanMatch_size"/>
			<dependency name="CodeScanMatcher_code"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_holeidx"/>
			<dependency name="CodeScanMatcher_holes"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanMatcher_offset"/>
			<dependency name="CodeScanMatcher_start"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetNextIp"/>
			<dependency name="DisasmGetNumOperands"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="OP_BOUNDS"/>
			<dependency name="OP_BREAK"/>
			<dependency name="OP_HALT"/>
			<dependency name="OP_NOP"/>
			<dependency name="cellbits"/>
			<dependency name="false"/>
			<dependency name="memcpy"/>
			<dependency name="true"/>
			<param name="op">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="dctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="cs">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="fctx">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanCheckJumpTarget" syntax="CodeScanCheckJumpTarget(cip, deloc, &amp;stk, &amp;hea, jumpTargets[], num)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_jump_heap"/>
			<dependency name="CodeScanner_jump_stack"/>
			<dependency name="CodeScanner_jump_switch"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="cellbits"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="cip">
			</param>
			<param name="deloc">
			</param>
			<param name="stk">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="hea">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="jumpTargets">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanClone" syntax="CodeScanClone(dest[], src[])">
			<stacksize value="1"/>
			<dependency name="CodeScanner_first"/>
			<param name="dest">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="src">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanDeref" syntax="CodeScanDeref(v)">
			<stacksize value="1"/>
			<referrer name="CodeScanFindOneFastPattern2"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanMatcher"/>
			<param name="v">
			</param>
		</member>
		<member name="M:CodeScanFindOneFastPattern2" syntax="CodeScanFindOneFastPattern2(matcher[], &amp;addr)">
			<tagname value="bool"/>
			<stacksize value="180"/>
			<referrer name="CodeScanRunFast"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanFindOneFastPattern3"/>
			<dependency name="CodeScanMatcher_code"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="OP_CALL"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="matcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="addr">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanFindOneFastPattern3" syntax="CodeScanFindOneFastPattern3(matcher[], addr, &amp;cur)">
			<tagname value="bool"/>
			<stacksize value="3"/>
			<referrer name="CodeScanFindOneFastPattern2"/>
			<dependency name="CodeScanMatcher_code"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="OP_CALL"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="matcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="addr">
			</param>
			<param name="cur">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetFuncName" syntax="CodeScanGetFuncName(addr, name[])">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<referrer name="CodeScanGetMatchType"/>
			<dependency name="GetPublicIndexFromAddress"/>
			<dependency name="GetPublicNameFromIndex"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="addr">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetFunctionAsm" syntax="CodeScanGetFunctionAsm(csm[], ctx[], offset)">
			<stacksize value="6"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="cellmax"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetFunctionDisasm" syntax="CodeScanGetFunctionDisasm(csm[], ctx[], offset)">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetFunctionScanner" syntax="CodeScanGetFunctionScanner(csm[], ret[], ctx[])">
			<stacksize value="4"/>
			<referrer name="CodeScanGetMatchScanner"/>
			<dependency name="CodeScanInit"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="CodeScanner_state"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ret">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetHoleCount" syntax="CodeScanGetHoleCount(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_hole_count"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchAddress" syntax="CodeScanGetMatchAddress(csm[])">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="gDat"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchAddressData" syntax="CodeScanGetMatchAddressData(csm[])">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="CodeScanMatch_cip"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchAsm" syntax="CodeScanGetMatchAsm(csm[], ctx[], offset)">
			<stacksize value="6"/>
			<referrer name="AddressofResolveFoundStart"/>
			<referrer name="AddressofResolveFoundEnd"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="cellmax"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetMatchDisasm" syntax="CodeScanGetMatchDisasm(csm[], ctx[], offset)">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetMatchFunc" syntax="CodeScanGetMatchFunc(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="gDat"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchFuncData" syntax="CodeScanGetMatchFuncData(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_func"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchHeap" syntax="CodeScanGetMatchHeap(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_heap"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchHole" syntax="CodeScanGetMatchHole(csm[], idx)">
			<stacksize value="1"/>
			<referrer name="AddressofResolveFoundStart"/>
			<referrer name="AddressofResolveFoundEnd"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_holes"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:CodeScanGetMatchLength" syntax="CodeScanGetMatchLength(csm[])">
			<stacksize value="1"/>
			<referrer name="AddressofResolveFoundEnd"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_size"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchName" syntax="CodeScanGetMatchName(csm[], name[])">
			<stacksize value="5"/>
			<dependency name="CodeScanGetMatchType"/>
			<dependency name="CodeScanMatch_name"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="strcat"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchScanner" syntax="CodeScanGetMatchScanner(csm[], ret[], ctx[], accurate)">
			<stacksize value="7"/>
			<dependency name="CodeScanGetFunctionScanner"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_param"/>
			<dependency name="CodeScanner_state"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ret">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="accurate">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchStack" syntax="CodeScanGetMatchStack(csm[])">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_stack"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchType" syntax="CodeScanGetMatchType(csm[])">
			<stacksize value="5"/>
			<referrer name="CodeScanGetMatchName"/>
			<dependency name="CodeScanGetFuncName"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanMatch_name"/>
			<dependency name="CodeScanMatch_type"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanInit" syntax="CodeScanInit(scanner[])">
			<stacksize value="5"/>
			<referrer name="CodeScanGetFunctionScanner"/>
			<referrer name="AddressofResolve"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanMatch_heap"/>
			<dependency name="CodeScanMatch_name"/>
			<dependency name="CodeScanMatch_params"/>
			<dependency name="CodeScanMatch_stack"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="CodeScanResetJumpTargets"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="CodeScanner_param"/>
			<dependency name="CodeScanner_state"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_NOP"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="gBase"/>
			<dependency name="gCodBase"/>
			<dependency name="gDat"/>
			<dependency name="gHdr"/>
			<dependency name="gOP_CASETBL"/>
			<dependency name="gOP_NOP"/>
			<param name="scanner">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanMatcherData" syntax="CodeScanMatcherData(searcher[], val)">
			<stacksize value="1"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_user_data"/>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="val">
			</param>
		</member>
		<member name="M:CodeScanMatcherInit_" syntax="CodeScanMatcherInit_(searcher[], address, flags)">
			<stacksize value="5"/>
			<referrer name="AddressofResolve"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_func"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanMatcher_user_data"/>
			<dependency name="CodeScanReset"/>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="address">
			</param>
			<param name="flags">
			</param>
		</member>
		<member name="M:CodeScanMatcherPattern_" syntax="CodeScanMatcherPattern_(searcher[], ...)">
			<stacksize value="10"/>
			<referrer name="AddressofResolve"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanMatcher_code"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="GetOpcodeInstructionParameters"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Opcode,Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanNOPMatch" syntax="CodeScanNOPMatch(csm[])">
			<stacksize value="3"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanMatch_size"/>
			<dependency name="cellbits"/>
			<dependency name="gOP_NOP"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanReset" syntax="CodeScanReset(cs[], &amp;next)">
			<stacksize value="1"/>
			<referrer name="CodeScanMatcherInit_"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanMatcher_func"/>
			<dependency name="CodeScanMatcher_holeidx"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanMatcher_offset"/>
			<param name="cs">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanResetJumpTargets" syntax="CodeScanResetJumpTargets(jumpTargets[], num)">
			<stacksize value="1"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanInit"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<param name="jumpTargets">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanRun" syntax="CodeScanRun(csState[])">
			<tagname value="bool"/>
			<stacksize value="188"/>
			<referrer name="CodeScanRunFast"/>
			<dependency name="CodeScanCall"/>
			<dependency name="CodeScanCheck"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanReset"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmInit"/>
			<dependency name="cellmin"/>
			<dependency name="gDat"/>
			<dependency name="true"/>
			<param name="csState">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanRunFast" syntax="CodeScanRunFast(csState[], searchFuncAddr)">
			<tagname value="bool"/>
			<stacksize value="191"/>
			<referrer name="AddressofResolve"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanCall"/>
			<dependency name="CodeScanCheck"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanFindOneFastPattern2"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanReset"/>
			<dependency name="CodeScanRun"/>
			<dependency name="CodeScanRunFastPrescan"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmInit"/>
			<dependency name="OP_PROC"/>
			<dependency name="cellmin"/>
			<dependency name="false"/>
			<dependency name="printf"/>
			<dependency name="true"/>
			<param name="csState">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="searchFuncAddr">
			</param>
		</member>
		<member name="M:CodeScanRunFastPrescan" syntax="CodeScanRunFastPrescan(&amp;proc, &amp;nextaddr, searchFuncAddr)">
			<stacksize value="6"/>
			<referrer name="CodeScanRunFast"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_PROC"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="UnrelocateOpcode"/>
			<dependency name="false"/>
			<dependency name="gCodBase"/>
			<dependency name="gOpArgCount"/>
			<dependency name="true"/>
			<param name="proc">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="nextaddr">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="searchFuncAddr">
			</param>
		</member>
		<member name="M:CodeScanStep" syntax="CodeScanStep(dctx[], csState[])">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_param"/>
			<dependency name="CodeScanner_state"/>
			<param name="dctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="csState">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanStepInternal" syntax="CodeScanStepInternal(dctx[], csState[], &amp;parseState, &amp;parseParam)">
			<tagname value="bool"/>
			<stacksize value="13"/>
			<referrer name="CodeScanStep"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="CodeScanGetMatchScanner"/>
			<dependency name="CodeScanAddJumpTarget"/>
			<dependency name="CodeScanAddSwitchTarget"/>
			<dependency name="CodeScanCheckJumpTarget"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanMatch_heap"/>
			<dependency name="CodeScanMatch_stack"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="CodeScanResetJumpTargets"/>
			<dependency name="DISASM_DONE"/>
			<dependency name="DISASM_NOP"/>
			<dependency name="DISASM_OK"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmNext"/>
			<dependency name="OP_ADD_C"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CALL_PRI"/>
			<dependency name="OP_HALT"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_JEQ"/>
			<dependency name="OP_JGEQ"/>
			<dependency name="OP_JGRTR"/>
			<dependency name="OP_JLEQ"/>
			<dependency name="OP_JLESS"/>
			<dependency name="OP_JNEQ"/>
			<dependency name="OP_JNZ"/>
			<dependency name="OP_JREL"/>
			<dependency name="OP_JSGEQ"/>
			<dependency name="OP_JSGRTR"/>
			<dependency name="OP_JSLEQ"/>
			<dependency name="OP_JSLESS"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_JZER"/>
			<dependency name="OP_LCTRL"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_POP_ALT"/>
			<dependency name="OP_POP_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_PUSH"/>
			<dependency name="OP_PUSH_ADR"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="OP_PUSH_PRI"/>
			<dependency name="OP_PUSH_R"/>
			<dependency name="OP_PUSH_S"/>
			<dependency name="OP_SCTRL"/>
			<dependency name="OP_STACK"/>
			<dependency name="OP_SWITCH"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="false"/>
			<dependency name="gBase"/>
			<dependency name="true"/>
			<param name="dctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="csState">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="parseState">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="parseParam">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CreateActor" syntax="CreateActor(modelid, X, Y, Z, Rotation)">
			<attribute name="native"/>
			<referrer name="Iter_CreateActor"/>
			<param name="modelid">
			</param>
			<param name="X">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Rotation">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:CreateDynamicObject" syntax="CreateDynamicObject(modelid, x, y, z, rx, ry, rz, worldid, interiorid, playerid, streamdistance, drawdistance, areaid, priority)">
			<attribute name="native"/>
			<referrer name="KreirajMape"/>
			<param name="modelid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rx">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="ry">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rz">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="worldid">
			</param>
			<param name="interiorid">
			</param>
			<param name="playerid">
			</param>
			<param name="streamdistance">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="drawdistance">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="areaid">
			</param>
			<param name="priority">
			</param>
		</member>
		<member name="M:CreatePlayerTextDraw" syntax="CreatePlayerTextDraw(playerid, x, y, text[])">
			<tagname value="PlayerText"/>
			<attribute name="native"/>
			<referrer name="va_CreatePlayerTextDraw"/>
			<referrer name="KreirajPlayerTD"/>
			<param name="playerid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CreateVehicle" syntax="CreateVehicle(vehicletype, x, y, z, rotation, color1, color2, respawn_delay, addsiren)">
			<attribute name="native"/>
			<referrer name="Iter_CreateVehicle"/>
			<param name="vehicletype">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rotation">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
			<param name="respawn_delay">
			</param>
			<param name="addsiren">
			</param>
		</member>
		<member name="M:D@" syntax="D@(function[], fmat[], ...)">
			<stacksize value="9"/>
			<referrer name="_@Iter_ActorDo"/>
			<referrer name="_@Iter_VehicleDo"/>
			<dependency name="@_"/>
			<dependency name="CallLocalFunction"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="YSI_g_sCallData"/>
			<dependency name="YSI_g_sPropCaller"/>
			<dependency name="YSI_g_sPropEmpty"/>
			<dependency name="YSI_g_sPropReturn"/>
			<dependency name="YSI_g_sPropVarArg"/>
			<dependency name="getproperty"/>
			<dependency name="setarg"/>
			<dependency name="setproperty"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Debug_Code1" syntax="Debug_Code1(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code1(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:1(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 1</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code2" syntax="Debug_Code2(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code2(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:2(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 2</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code3" syntax="Debug_Code3(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code3(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:3(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 3</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code4" syntax="Debug_Code4(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code4(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:4(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 4</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code5" syntax="Debug_Code5(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code5(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:5(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 5</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code6" syntax="Debug_Code6(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code6(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:6(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 6</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code7" syntax="Debug_Code7(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code7(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:7(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 7</c>.  </remarks> 
		</member>
		<member name="M:Debug_Disable" syntax="Debug_Disable()">
			<stacksize value="1"/>
			<remarks>  Turn off level 0 prints.  </remarks>  <transition target="off"/>

		</member>
		<member name="M:Debug_Enable" syntax="Debug_Enable()">
			<stacksize value="1"/>
			<remarks>  Turn on level 0 prints.  </remarks>  <transition target="on"/>

		</member>
		<member name="M:Debug_ErrorHandler" syntax="Debug_ErrorHandler(asmError)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<dependency name="Debug_Print0"/>
			<param name="asmError">
			</param>
		</member>
		<member name="M:Debug_Level" syntax="Debug_Level(level)">
			<stacksize value="1"/>
			<dependency name="YSI_gDebugLevel"/>
			<param name="level">
			</param>
			<remarks>  Set the debug level when the code is compiled with <c>_DEBUG=-1</c>, which  means full run-time selection.  </remarks> 
		</member>
		<member name="M:Debug_OnCodeInit" syntax="Debug_OnCodeInit()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetGlobal"/>
			<dependency name="AMX_HEADER_AMX_VERSION"/>
			<dependency name="AMX_HEADER_CIP"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_DAT"/>
			<dependency name="AMX_HEADER_DEFSIZE"/>
			<dependency name="AMX_HEADER_FILE_VERSION"/>
			<dependency name="AMX_HEADER_FLAGS"/>
			<dependency name="AMX_HEADER_HEA"/>
			<dependency name="AMX_HEADER_LIBRARIES"/>
			<dependency name="AMX_HEADER_MAGIC"/>
			<dependency name="AMX_HEADER_NAMETABLE"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_HEADER_PUBVARS"/>
			<dependency name="AMX_HEADER_SIZE"/>
			<dependency name="AMX_HEADER_STP"/>
			<dependency name="AMX_HEADER_TAGS"/>
			<dependency name="AMX_REAL_ADDRESS"/>
			<dependency name="AMX_REAL_DATA"/>
		</member>
		<member name="M:Debug_Print0" syntax="Debug_Print0(str[], ...)">
			<stacksize value="1"/>
			<automaton name="ysi_debug"/>
			<referrer name="OnJITCompile"/>
			<referrer name="Debug_ErrorHandler"/>
			<referrer name="ScriptInit_OnCodeInit"/>
			<referrer name="y_profile_WTF"/>
			<referrer name="LevenshteinDistance"/>
			<referrer name="YVA2_DummyPush"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="CGen_OOM"/>
			<referrer name="CGen_AddCodeSpace"/>
			<referrer name="Hooks_IsolateName"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GetStubEntry"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Iter_YieldEnter"/>
			<dependency name="printf"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				
			</param>
			<param name="format">str.</param>    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print0("variables: %d, %d", i, j);  </code>  Or:  <code>  P:0("variables: %d, %d", i, j);  </code>  <c>_DEBUG</c> level 0 prints are ALWAYS compiled, but are runtime switched  using the automata <c>ysi_debug</c>.  When then state is <c>ysi_debug :  on</c>, the prints are executed.  When then state is <c>ysi_debug : off</c>,  they aren't.  </remarks> 
		</member>
		<member name="M:Debug_Print1" syntax="Debug_Print1(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print1("variables: %d, %d", i, j);  </code>  Or:  <code>  P:1("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 1</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print2" syntax="Debug_Print2(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print2("variables: %d, %d", i, j);  </code>  Or:  <code>  P:2("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 2</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print3" syntax="Debug_Print3(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print3("variables: %d, %d", i, j);  </code>  Or:  <code>  P:3("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 3</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print4" syntax="Debug_Print4(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print4("variables: %d, %d", i, j);  </code>  Or:  <code>  P:4("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 4</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print5" syntax="Debug_Print5(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print5("variables: %d, %d", i, j);  </code>  Or:  <code>  P:5("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 5</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print6" syntax="Debug_Print6(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print6("variables: %d, %d", i, j);  </code>  Or:  <code>  P:6("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 6</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print7" syntax="Debug_Print7(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print7("variables: %d, %d", i, j);  </code>  Or:  <code>  P:7("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 7</c>.  </remarks> 
		</member>
		<member name="M:Debug_PrintArray" syntax="Debug_PrintArray(arr[], size)">
			<stacksize value="108"/>
			<dependency name="Debug_PrintArray"/>
			<dependency name="format"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Debug_SetState" syntax="Debug_SetState()">
			<stacksize value="1"/>
			<automaton name="ysi_debug"/>
			<referrer name="ScriptInit_OnCodeInit"/>
			<transition keep="true" target="ysi_debug : on" source="ysi_debug : "/>  <remarks>  Mostly exists to define the full range of <c>ysi_debug</c> states.  </remarks> <p/> <transition target="on"/>

		</member>
		<member name="M:DestroyActor" syntax="DestroyActor(actorid)">
			<attribute name="native"/>
			<referrer name="Iter_DestroyActor"/>
			<param name="actorid">
			</param>
		</member>
		<member name="M:DestroyVehicle" syntax="DestroyVehicle(vehicleid)">
			<attribute name="native"/>
			<referrer name="Iter_DestroyVehicle"/>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:DisableInteriorEnterExits" syntax="DisableInteriorEnterExits()">
			<attribute name="native"/>
			<referrer name="PawnCmd_OnGameModeInit"/>
		</member>
		<member name="M:DisasmDecodeInsn" syntax="DisasmDecodeInsn(ctx[])">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<referrer name="DisasmNext"/>
			<referrer name="DisasmNextInsn"/>
			<referrer name="DisasmWriteCode"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="GetOpcodeInstructionParameters"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_NONE"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="UnrelocateOpcode"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmDump" syntax="DisasmDump(filename[])">
			<stacksize value="4"/>
			<dependency name="DisasmWrite"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetCurIp" syntax="DisasmGetCurIp(ctx[])">
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="DisasmContext_cip"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetInsnName" syntax="DisasmGetInsnName(ctx[], name[], size)">
			<stacksize value="21"/>
			<referrer name="DisasmWriteCode"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="GetOpcodeInstructionName"/>
			<dependency name="GetOpcodeInstructionName"/>
			<dependency name="strcat"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:DisasmGetNextIp" syntax="DisasmGetNextIp(ctx[])">
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanCheck"/>
			<dependency name="DisasmContext_nip"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetNumOperands" syntax="DisasmGetNumOperands(ctx[])">
			<stacksize value="5"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="Hooks_GetStubEntry"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="GetOpcodeInstructionParameters"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="ReadAmxMemory"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetOpcode" syntax="DisasmGetOpcode(ctx[])">
			<tagname value="Opcode"/>
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="_yH@"/>
			<dependency name="DisasmContext_opcode"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetOperand" syntax="DisasmGetOperand(ctx[], index)">
			<stacksize value="4"/>
			<referrer name="DisasmGetOperandReloc"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="Hooks_GetStubEntry"/>
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="ReadAmxMemory"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:DisasmGetOperandReloc" syntax="DisasmGetOperandReloc(ctx[], index)">
			<stacksize value="6"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmNeedReloc"/>
			<dependency name="DisasmReloc"/>
			<dependency name="OP_CASETBL"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:DisasmGetRemaining" syntax="DisasmGetRemaining(ctx[])">
			<stacksize value="1"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmInit" syntax="DisasmInit(ctx[], start, end)">
			<stacksize value="21"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="VA_OnCodeInit"/>
			<referrer name="Hooks_GetStubEntry"/>
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="gCodBase"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="end">
			</param>
		</member>
		<member name="M:DisasmNeedReloc" syntax="DisasmNeedReloc(ctx[])">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="DisasmGetOperandReloc"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="GetOpcodeInstructionRelocatable"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmNext" syntax="DisasmNext(ctx[])">
			<tagname value="DisasmResult"/>
			<stacksize value="4"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="_yH@"/>
			<dependency name="DISASM_DONE"/>
			<dependency name="DISASM_NOP"/>
			<dependency name="DISASM_OK"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="NUM_OPCODES"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmNextInsn" syntax="DisasmNextInsn(ctx[])">
			<tagname value="Opcode"/>
			<stacksize value="4"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="VA_OnCodeInit"/>
			<referrer name="Hooks_GetStubEntry"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="OP_NONE"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmReloc" syntax="DisasmReloc(addr)">
			<stacksize value="1"/>
			<referrer name="DisasmGetOperandReloc"/>
			<dependency name="gCodBase"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:DisasmWrite" syntax="DisasmWrite(filename[])">
			<tagname value="bool"/>
			<stacksize value="5"/>
			<referrer name="DisasmDump"/>
			<dependency name="DisasmWriteFile"/>
			<dependency name="false"/>
			<dependency name="fclose"/>
			<dependency name="fopen"/>
			<dependency name="io_write"/>
			<dependency name="true"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmWriteCode" syntax="DisasmWriteCode(file)">
			<stacksize value="159"/>
			<referrer name="DisasmWriteFile"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetInsnName"/>
			<dependency name="DisasmGetNextIp"/>
			<dependency name="DisasmGetNumOperands"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="DisasmInit"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="GetNativeIndexFromAddress"/>
			<dependency name="GetNativeNameFromIndex"/>
			<dependency name="GetPublicIndexFromAddress"/>
			<dependency name="GetPublicNameFromIndex"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ToHexStr"/>
			<dependency name="ToHexStr"/>
			<dependency name="fwrite"/>
			<dependency name="gCodBase"/>
			<dependency name="strcat"/>
			<dependency name="strlen"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:DisasmWriteData" syntax="DisasmWriteData(file)">
			<stacksize value="38"/>
			<referrer name="DisasmWriteFile"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_HEA"/>
			<dependency name="DisasmWriteDataRowChar"/>
			<dependency name="DisasmWriteDataRowHex"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="ToHexStr"/>
			<dependency name="ToHexStr"/>
			<dependency name="fwrite"/>
			<dependency name="min"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:DisasmWriteDataRowChar" syntax="DisasmWriteDataRowChar(file, start, num, max)">
			<stacksize value="13"/>
			<referrer name="DisasmWriteData"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ToPrintableAscii"/>
			<dependency name="fwrite"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="num">
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:DisasmWriteDataRowHex" syntax="DisasmWriteDataRowHex(file, start, num, max)">
			<stacksize value="19"/>
			<referrer name="DisasmWriteData"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ToHexStr"/>
			<dependency name="ToHexStr"/>
			<dependency name="fwrite"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="num">
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:DisasmWriteFile" syntax="DisasmWriteFile(file)">
			<stacksize value="4"/>
			<referrer name="DisasmWrite"/>
			<dependency name="DisasmWriteCode"/>
			<dependency name="DisasmWriteData"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:DoLevenshteinDistance" syntax="DoLevenshteinDistance(a[], lenA, b[], lenB)">
			<stacksize value="42"/>
			<referrer name="LevenshteinDistance"/>
			<dependency name="min"/>
			<param name="a">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="lenA">
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="lenB">
			</param>
		</member>
		<member name="M:E@" syntax="E@()">
			<stacksize value="6"/>
			<dependency name="@_"/>
			<dependency name="setproperty"/>
		</member>
		<member name="M:EnableStuntBonusForAll" syntax="EnableStuntBonusForAll(enable)">
			<attribute name="native"/>
			<referrer name="PawnCmd_OnGameModeInit"/>
			<param name="enable">
			</param>
		</member>
		<member name="M:ExchangeArraySlots" syntax="ExchangeArraySlots(array[][], slot1, slot2)">
			<stacksize value="3"/>
			<referrer name="_SortDeepArray"/>
			<referrer name="SortArrayUsingComparator_QS"/>
			<param name="array">
				<paraminfo> [][] </paraminfo>
			</param>
			<param name="slot1">
			</param>
			<param name="slot2">
			</param>
		</member>
		<member name="M:F@" syntax="F@(calltype, master, heapptr)">
			<stacksize value="1"/>
			<referrer name="_@Iter_ActorDo"/>
			<referrer name="_@Iter_VehicleDo"/>
			<dependency name="YSI_g_sCallData"/>
			<param name="calltype">
			</param>
			<param name="master">
			</param>
			<param name="heapptr">
			</param>
		</member>
		<member name="M:G@" syntax="G@(...)">
			<stacksize value="1"/>
			<dependency name="G@"/>
			<dependency name="Q@"/>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:GameTextForAll" syntax="GameTextForAll(string[], time, style)">
			<attribute name="native"/>
			<referrer name="va_GameTextForAll"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="style">
			</param>
		</member>
		<member name="M:GameTextForPlayer" syntax="GameTextForPlayer(playerid, string[], time, style)">
			<attribute name="native"/>
			<referrer name="va_GameTextForPlayer"/>
			<param name="playerid">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="style">
			</param>
		</member>
		<member name="M:GetAmxAddress" syntax="GetAmxAddress()">
			<stacksize value="5"/>
			<referrer name="ReadAmxCell"/>
			<referrer name="WriteAmxCell"/>
			<dependency name="RunShellcode"/>
			<dependency name="refabs"/>
		</member>
		<member name="M:GetAmxBaseAddress" syntax="GetAmxBaseAddress()">
			<stacksize value="3"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmInit"/>
			<referrer name="AsmGetJumpAddressFromOffset"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="CodeScanInit"/>
			<referrer name="AddressofResolveFoundStart"/>
			<referrer name="AbsToRel"/>
			<referrer name="RelToAbs"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="GetAmxBaseAddressNow"/>
		</member>
		<member name="M:GetAmxBaseAddressNow" syntax="GetAmxBaseAddressNow()">
			<stacksize value="9"/>
			<referrer name="GetAmxBaseAddress"/>
			<dependency name="GetAmxBaseAddress_helper"/>
		</member>
		<member name="M:GetAmxBaseAddress_helper" syntax="GetAmxBaseAddress_helper()">
			<stacksize value="1"/>
			<referrer name="GetAmxBaseAddressNow"/>
		</member>
		<member name="M:GetAmxFrame" syntax="GetAmxFrame()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxHeader" syntax="GetAmxHeader(amxhdr[])">
			<stacksize value="3"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmInit"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="AsmGetJumpAddressFromOffset"/>
			<referrer name="AsmGetCode"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="CodeScanInit"/>
			<referrer name="AddressofResolveFoundStart"/>
			<referrer name="Indirect_Init"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetAmxHeaderComponent" syntax="GetAmxHeaderComponent(comp)">
			<stacksize value="3"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="comp">
				<paraminfo>AMX_HDR </paraminfo>
			</param>
		</member>
		<member name="M:GetAmxHeaderNow" syntax="GetAmxHeaderNow(amxhdr[])">
			<stacksize value="21"/>
			<referrer name="ResetStaticAmxHeader"/>
			<dependency name="AMX_HDR_AMX_VERSION"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_FILE_VERSION"/>
			<dependency name="AMX_HDR_FLAGS"/>
			<dependency name="AMX_HDR_HEA"/>
			<dependency name="AMX_HDR_LIBRARIES"/>
			<dependency name="AMX_HDR_MAGIC"/>
			<dependency name="AMX_HDR_NAMETABLE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_OFFSET_AMX_VERSION"/>
			<dependency name="AMX_HDR_OFFSET_CIP"/>
			<dependency name="AMX_HDR_OFFSET_COD"/>
			<dependency name="AMX_HDR_OFFSET_DAT"/>
			<dependency name="AMX_HDR_OFFSET_DEFSIZE"/>
			<dependency name="AMX_HDR_OFFSET_FILE_VERSION"/>
			<dependency name="AMX_HDR_OFFSET_FLAGS"/>
			<dependency name="AMX_HDR_OFFSET_HEA"/>
			<dependency name="AMX_HDR_OFFSET_LIBRARIES"/>
			<dependency name="AMX_HDR_OFFSET_MAGIC"/>
			<dependency name="AMX_HDR_OFFSET_NAMETABLE"/>
			<dependency name="AMX_HDR_OFFSET_NATIVES"/>
			<dependency name="AMX_HDR_OFFSET_PUBLICS"/>
			<dependency name="AMX_HDR_OFFSET_PUBVARS"/>
			<dependency name="AMX_HDR_OFFSET_SIZE"/>
			<dependency name="AMX_HDR_OFFSET_STP"/>
			<dependency name="AMX_HDR_OFFSET_TAGS"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="AMX_HDR_SIZE"/>
			<dependency name="AMX_HDR_STP"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetRawAmxHeader"/>
			<dependency name="copy_1"/>
			<dependency name="copy_2"/>
			<dependency name="copy_4"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetAmxHeapBase" syntax="GetAmxHeapBase()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxHeapTop" syntax="GetAmxHeapTop()">
			<stacksize value="1"/>
			<referrer name="Hooks_OnCodeInit"/>
		</member>
		<member name="M:GetAmxJITBaseAddress" syntax="GetAmxJITBaseAddress()">
			<stacksize value="1"/>
			<referrer name="AddressofResolve"/>
		</member>
		<member name="M:GetAmxNextInstructionPointer" syntax="GetAmxNextInstructionPointer()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxStackBase" syntax="GetAmxStackBase()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxStackBottom" syntax="GetAmxStackBottom()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetCallerFrame" syntax="GetCallerFrame()">
			<stacksize value="1"/>
			<referrer name="GetCurrentFramePreviousFrame"/>
			<referrer name="GetCurrentFrameReturn"/>
			<referrer name="GetCurrentFrameTotalSize"/>
			<referrer name="GetCurrentFrameTotalCount"/>
			<referrer name="GetCurrentFrameLocalSize"/>
			<referrer name="GetCurrentFrameLocalCount"/>
			<referrer name="GetCurrentFrameHeaderSize"/>
			<referrer name="GetCurrentFrameHeaderCount"/>
			<referrer name="GetCurrentFrameParameterSize"/>
			<referrer name="GetCurrentFrameParameter"/>
			<referrer name="GetCurrentFrameLocal"/>
			<referrer name="GetCurrentFrameParameterCount"/>
			<referrer name="SetCurrentFrameReturn"/>
			<referrer name="SetCurrentFramePreviousFrame"/>
			<referrer name="SetCurrentParameterSize"/>
			<referrer name="SetCurrentParameterCount"/>
			<referrer name="GetCurrentFrameFunction"/>
		</member>
		<member name="M:GetCurrentFrame" syntax="GetCurrentFrame()">
			<stacksize value="1"/>
			<referrer name="GetFrameNextFrame"/>
		</member>
		<member name="M:GetCurrentFrameFunction" syntax="GetCurrentFrameFunction()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameFunction"/>
		</member>
		<member name="M:GetCurrentFrameHeaderCount" syntax="GetCurrentFrameHeaderCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameHeaderCount"/>
		</member>
		<member name="M:GetCurrentFrameHeaderSize" syntax="GetCurrentFrameHeaderSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameHeaderSize"/>
		</member>
		<member name="M:GetCurrentFrameLocal" syntax="GetCurrentFrameLocal(param)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameLocal"/>
			<param name="param">
			</param>
		</member>
		<member name="M:GetCurrentFrameLocalCount" syntax="GetCurrentFrameLocalCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameLocalCount"/>
		</member>
		<member name="M:GetCurrentFrameLocalSize" syntax="GetCurrentFrameLocalSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameLocalSize"/>
		</member>
		<member name="M:GetCurrentFrameParameter" syntax="GetCurrentFrameParameter(param, idx)">
			<stacksize value="6"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameParameter"/>
			<param name="param">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:GetCurrentFrameParameterCount" syntax="GetCurrentFrameParameterCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameParameterCount"/>
		</member>
		<member name="M:GetCurrentFrameParameterSize" syntax="GetCurrentFrameParameterSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameParameterSize"/>
		</member>
		<member name="M:GetCurrentFramePreviousFrame" syntax="GetCurrentFramePreviousFrame()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFramePreviousFrame"/>
		</member>
		<member name="M:GetCurrentFrameReturn" syntax="GetCurrentFrameReturn()">
			<stacksize value="4"/>
			<referrer name="O@A_"/>
			<referrer name="_yH@"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameReturn"/>
		</member>
		<member name="M:GetCurrentFrameTotalCount" syntax="GetCurrentFrameTotalCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameTotalCount"/>
		</member>
		<member name="M:GetCurrentFrameTotalSize" syntax="GetCurrentFrameTotalSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameTotalSize"/>
		</member>
		<member name="M:GetDat" syntax="GetDat()">
			<stacksize value="1"/>
			<referrer name="AbsToRel"/>
			<referrer name="RelToAbs"/>
		</member>
		<member name="M:GetFrameFunction" syntax="GetFrameFunction(frm_addr)">
			<stacksize value="29"/>
			<referrer name="GetCurrentFrameFunction"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="GetFrameNextFrame"/>
			<dependency name="GetFramePreviousFrame"/>
			<dependency name="GetFrameReturn"/>
			<dependency name="GetFrameVariable"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_LOAD_S_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_RETN"/>
			<dependency name="OP_SCTRL"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="UnrelocateOpcode"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameHeaderCount" syntax="GetFrameHeaderCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameHeaderCount"/>
			<dependency name="GetFrameHeaderSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameHeaderSize" syntax="GetFrameHeaderSize(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetFrameTotalSize"/>
			<referrer name="GetFrameLocalSize"/>
			<referrer name="GetFrameHeaderCount"/>
			<referrer name="GetCurrentFrameHeaderSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameLocal" syntax="GetFrameLocal(frm_addr, param)">
			<stacksize value="1"/>
			<referrer name="GetCurrentFrameLocal"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
		</member>
		<member name="M:GetFrameLocalCount" syntax="GetFrameLocalCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameLocalCount"/>
			<dependency name="GetFrameLocalSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameLocalSize" syntax="GetFrameLocalSize(frm_addr)">
			<stacksize value="6"/>
			<referrer name="GetFrameTotalSize"/>
			<referrer name="GetFrameLocalCount"/>
			<referrer name="GetCurrentFrameLocalSize"/>
			<dependency name="GetFrameHeaderSize"/>
			<dependency name="GetFrameNextFrame"/>
			<dependency name="GetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameNextFrame" syntax="GetFrameNextFrame(frm_addr)">
			<stacksize value="6"/>
			<referrer name="GetFrameLocalSize"/>
			<referrer name="GetFrameFunction"/>
			<dependency name="GetCurrentFrame"/>
			<dependency name="GetFramePreviousFrame"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameParameter" syntax="GetFrameParameter(frm_addr, param, idx)">
			<stacksize value="1"/>
			<referrer name="GetCurrentFrameParameter"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:GetFrameParameterCount" syntax="GetFrameParameterCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameParameterCount"/>
			<dependency name="GetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameParameterSize" syntax="GetFrameParameterSize(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetFrameTotalSize"/>
			<referrer name="GetFrameLocalSize"/>
			<referrer name="GetFrameParameterCount"/>
			<referrer name="GetCurrentFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFramePreviousFrame" syntax="GetFramePreviousFrame(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetFrameNextFrame"/>
			<referrer name="GetCurrentFramePreviousFrame"/>
			<referrer name="GetFrameFunction"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameReturn" syntax="GetFrameReturn(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetCurrentFrameReturn"/>
			<referrer name="GetFrameFunction"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameTotalCount" syntax="GetFrameTotalCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameTotalCount"/>
			<dependency name="GetFrameTotalSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameTotalSize" syntax="GetFrameTotalSize(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetFrameTotalCount"/>
			<referrer name="GetCurrentFrameTotalSize"/>
			<dependency name="GetFrameHeaderSize"/>
			<dependency name="GetFrameLocalSize"/>
			<dependency name="GetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameVariable" syntax="GetFrameVariable(frm_addr, param, idx)">
			<stacksize value="1"/>
			<referrer name="GetFrameFunction"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:GetFunctionAddress" syntax="GetFunctionAddress(funcname[])">
			<stacksize value="5"/>
			<referrer name="SortArrayUsingComparator_Entry"/>
			<referrer name="SortArrayUsingCompInto_Entry"/>
			<dependency name="funcidx"/>
			<param name="funcname">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetIP" syntax="GetIP(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				Player to get IP of.
			</param>
			  <returns>  IP as a 32bit int.  </returns> 
		</member>
		<member name="M:GetJITGeneratorVersion" syntax="GetJITGeneratorVersion()">
			<stacksize value="1"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
			<referrer name="CallNative"/>
			<referrer name="CallNativeByAddress"/>
		</member>
		<member name="M:GetMaxPlayers" syntax="GetMaxPlayers()">
			<attribute name="native"/>
			<referrer name="Indirection_OnFilterScriptInit"/>
			<referrer name="Indirection_OnGameModeInit"/>
		</member>
		<member name="M:GetName" syntax="GetName(playerid)">
			<stacksize value="29"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
			<referrer name="ProvjeriBAN"/>
			<referrer name="ProvjeriBANIP"/>
			<referrer name="OnPlayerText"/>
			<referrer name="pc_cmd_me"/>
			<referrer name="pc_cmd_do"/>
			<referrer name="pc_cmd_b"/>
			<referrer name="pc_cmd_aduty"/>
			<referrer name="pc_cmd_kick"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<referrer name="ProvjeriUNBAN"/>
			<referrer name="OnPlayerClickTextDraw"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="IgracRegistrovan"/>
			<referrer name="SQL_ProvjeraAccounta"/>
			<dependency name="GetName"/>
			<dependency name="GetPlayerName"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:GetNativeAddressFromIndex" syntax="GetNativeAddressFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetNativeAddressFromName"/>
			<referrer name="YHNPS_Push"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetNativeInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetNativeAddressFromName" syntax="GetNativeAddressFromName(name[])">
			<stacksize value="4"/>
			<dependency name="GetNativeAddressFromIndex"/>
			<dependency name="GetNativeIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetNativeIndexFromAddress" syntax="GetNativeIndexFromAddress(address)">
			<stacksize value="7"/>
			<referrer name="GetNativeNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="address">
			</param>
		</member>
		<member name="M:GetNativeIndexFromName" syntax="GetNativeIndexFromName(name[])">
			<stacksize value="10"/>
			<referrer name="GetNativeAddressFromName"/>
			<referrer name="AsmEmitSysreq"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetNativeInfo" syntax="GetNativeInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetNativeAddressFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetNativeNameFromAddress" syntax="GetNativeNameFromAddress(address, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="GetNativeIndexFromAddress"/>
			<dependency name="GetNativeNameFromIndex"/>
			<param name="address">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetNativeNameFromIndex" syntax="GetNativeNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetNativeNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetNativeInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetNumNatives" syntax="GetNumNatives(amxhdr[])">
			<stacksize value="1"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_LIBRARIES"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumPubVars" syntax="GetNumPubVars(amxhdr[])">
			<stacksize value="1"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="AMX_HDR_TAGS"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumPublics" syntax="GetNumPublics(amxhdr[])">
			<stacksize value="2"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumTags" syntax="GetNumTags(amxhdr[])">
			<stacksize value="1"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NAMETABLE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionInformation" syntax="GetOpcodeInstructionInformation(opcode)">
			<stacksize value="1"/>
			<dependency name="GetOpcodeInstructionInformation"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionName" syntax="GetOpcodeInstructionName(opcode)">
			<stacksize value="1"/>
			<referrer name="DisasmGetInsnName"/>
			<dependency name="GetOpcodeInstructionName"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionParameters" syntax="GetOpcodeInstructionParameters(opcode)">
			<stacksize value="1"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmGetNumOperands"/>
			<referrer name="AsmEmitPadding"/>
			<referrer name="CodeScanMatcherPattern_"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="OpcodeInsnInfo_num_opers"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionRelocatable" syntax="GetOpcodeInstructionRelocatable(opcode)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="DisasmNeedReloc"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="OpcodeInsnInfo_needs_reloc"/>
			<dependency name="false"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetPlayerIp" syntax="GetPlayerIp(playerid, name[], len)">
			<attribute name="native"/>
			<referrer name="OnPlayerConnect"/>
			<referrer name="ProvjeriBAN"/>
			<referrer name="pc_cmd_banip"/>
			<param name="playerid">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:GetPlayerName" syntax="GetPlayerName(playerid, name[], len)">
			<attribute name="native"/>
			<referrer name="ReturnPlayerName"/>
			<referrer name="Indirection_OnFilterScriptInit"/>
			<referrer name="Indirection_OnGameModeInit"/>
			<referrer name="_y_utils_OnPlayerConnect"/>
			<referrer name="GetName"/>
			<param name="playerid">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:GetPlayerPos" syntax="GetPlayerPos(playerid, &amp;x, &amp;y, &amp;z)">
			<attribute name="native"/>
			<referrer name="ProxDetector"/>
			<param name="playerid">
			</param>
			<param name="x">
				<paraminfo>Float &amp; </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float &amp; </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float &amp; </paraminfo>
			</param>
		</member>
		<member name="M:GetPlayerVirtualWorld" syntax="GetPlayerVirtualWorld(playerid)">
			<attribute name="native"/>
			<referrer name="ProxDetector"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:GetPubVarAddressFromIndex" syntax="GetPubVarAddressFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetPubVarAddressFromName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetPubVarInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetPubVarAddressFromName" syntax="GetPubVarAddressFromName(name[])">
			<stacksize value="4"/>
			<dependency name="GetPubVarAddressFromIndex"/>
			<dependency name="GetPubVarIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPubVarIndexFromAddress" syntax="GetPubVarIndexFromAddress(address)">
			<stacksize value="7"/>
			<referrer name="GetPubVarNameFromAddress"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="GetNumPubVars"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="address">
			</param>
		</member>
		<member name="M:GetPubVarIndexFromName" syntax="GetPubVarIndexFromName(name[])">
			<stacksize value="10"/>
			<referrer name="GetPubVarAddressFromName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="GetNumPubVars"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPubVarInfo" syntax="GetPubVarInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetPubVarAddressFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="GetNumPubVars"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetPubVarNameFromAddress" syntax="GetPubVarNameFromAddress(address, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="GetPubVarIndexFromAddress"/>
			<dependency name="GetPubVarNameFromIndex"/>
			<param name="address">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetPubVarNameFromIndex" syntax="GetPubVarNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetPubVarNameFromAddress"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetPubVarInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetPublicAddressFromIndex" syntax="GetPublicAddressFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetPublicAddressFromName"/>
			<referrer name="Indirect_Call"/>
			<referrer name="Indirect_Callstring"/>
			<referrer name="Indirect_Callvoid"/>
			<referrer name="Indirect_Array"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetPublicInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetPublicAddressFromName" syntax="GetPublicAddressFromName(name[])">
			<stacksize value="4"/>
			<referrer name="AsmSetErrorHandlerName"/>
			<referrer name="Hooks_RepairJITInit"/>
			<dependency name="GetPublicAddressFromIndex"/>
			<dependency name="GetPublicIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPublicIndexFromAddress" syntax="GetPublicIndexFromAddress(address)">
			<stacksize value="7"/>
			<referrer name="GetPublicNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanGetFuncName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="address">
			</param>
		</member>
		<member name="M:GetPublicIndexFromName" syntax="GetPublicIndexFromName(name[])">
			<stacksize value="12"/>
			<referrer name="GetPublicAddressFromName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPublicInfo" syntax="GetPublicInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetPublicAddressFromIndex"/>
			<referrer name="GetPublicNameFromIndex"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetPublicNameFromAddress" syntax="GetPublicNameFromAddress(address, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="GetPublicIndexFromAddress"/>
			<dependency name="GetPublicNameFromIndex"/>
			<param name="address">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetPublicNameFromIndex" syntax="GetPublicNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetPublicNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanGetFuncName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetPublicInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetRawAmxHeader" syntax="GetRawAmxHeader(plain_amxhdr[])">
			<stacksize value="6"/>
			<referrer name="GetAmxHeaderNow"/>
			<dependency name="ReadAmxMemory"/>
			<param name="plain_amxhdr">
				<paraminfo> [15] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagIDFromIndex" syntax="GetTagIDFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetTagIDFromName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetTagInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetTagIDFromName" syntax="GetTagIDFromName(name[])">
			<stacksize value="4"/>
			<dependency name="GetTagIDFromIndex"/>
			<dependency name="GetTagIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagIndexFromID" syntax="GetTagIndexFromID(id)">
			<stacksize value="7"/>
			<referrer name="GetTagNameFromID"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetNumTags"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="id">
			</param>
		</member>
		<member name="M:GetTagIndexFromName" syntax="GetTagIndexFromName(name[])">
			<stacksize value="10"/>
			<referrer name="GetTagIDFromName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetNumTags"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagInfo" syntax="GetTagInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetTagIDFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="IsTagIndexStrong"/>
			<referrer name="IsTagIndexWeak"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetNumTags"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagNameFromID" syntax="GetTagNameFromID(id, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="Indirect_Call"/>
			<referrer name="Indirect_Callstring"/>
			<referrer name="Indirect_Callvoid"/>
			<referrer name="Indirect_Array"/>
			<referrer name="Indirect_Tag"/>
			<dependency name="GetTagIndexFromID"/>
			<dependency name="GetTagNameFromIndex"/>
			<dependency name="true"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetTagNameFromIndex" syntax="GetTagNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetTagNameFromID"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetTagInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetVehicleModel" syntax="GetVehicleModel(vehicleid)">
			<attribute name="native"/>
			<referrer name="@yH_OnScriptInit@001"/>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:GivePlayerMoney" syntax="GivePlayerMoney(playerid, money)">
			<attribute name="native"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="IgracRegistrovan"/>
			<param name="playerid">
			</param>
			<param name="money">
			</param>
		</member>
		<member name="M:H@" syntax="H@(...)">
			<stacksize value="1"/>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:HaveToRelocateOpcodes" syntax="HaveToRelocateOpcodes()">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="RelocateOpcodeNow"/>
			<dependency name="OP_CALL"/>
			<dependency name="ReadOpcodeNearThis"/>
		</member>
		<member name="M:HeapAllocBytes" syntax="HeapAllocBytes(nbytes)">
			<stacksize value="2"/>
			<referrer name="HeapAllocCells"/>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:HeapAllocCells" syntax="HeapAllocCells(ncells)">
			<stacksize value="4"/>
			<referrer name="YHNPS_Push"/>
			<dependency name="HeapAllocBytes"/>
			<param name="ncells">
			</param>
		</member>
		<member name="M:HeapRelease" syntax="HeapRelease(address)">
			<stacksize value="1"/>
			<referrer name="Hooks_OnCodeInit"/>
			<param name="address">
			</param>
		</member>
		<member name="M:HookNative" syntax="HookNative(index, address)">
			<stacksize value="8"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="WriteAmxMemory"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="index">
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:HookPublic" syntax="HookPublic(index, address)">
			<stacksize value="8"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="WriteAmxMemory"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="index">
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:Hooks_Collate" syntax="Hooks_Collate(preloads[][], precount, name[], idx)">
			<stacksize value="30"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="Hooks_GenerateCode"/>
			<dependency name="Hooks_GetAllHooks"/>
			<dependency name="Hooks_GetPointerRewrite"/>
			<dependency name="Hooks_GetPreHooks"/>
			<dependency name="Hooks_IsolateName"/>
			<dependency name="Hooks_MakeLongName"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<param name="preloads">
				<paraminfo> [][17] </paraminfo>
			</param>
			<param name="precount">
			</param>
			<param name="name">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:Hooks_CompareNextCell" syntax="Hooks_CompareNextCell(addr0, addr1)">
			<stacksize value="6"/>
			<referrer name="Hooks_ComparePublics"/>
			<dependency name="AMX_Read"/>
			<dependency name="Cell_ReverseBytes"/>
			<param name="addr0">
				The 1st address to read.
			</param>
			<param name="addr1">
				The 2nd address to read.
			</param>
			    <returns>  -1 - The first address is bigger.  0  - The addresses are the same  1  - The second address is bigger.  </returns>  <remarks>  Reads two addresses, converts them to big endian, and compares them as four  characters of a string at once.  </remarks> 
		</member>
		<member name="M:Hooks_ComparePublics" syntax="Hooks_ComparePublics(idx0, idx1)">
			<stacksize value="9"/>
			<referrer name="Hooks_SortPublics"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="Hooks_CompareNextCell"/>
			<param name="idx0">
				The index of the 1st public.
			</param>
			<param name="idx1">
				The index of the 2nd public.
			</param>
			    <remarks>  Compares two public function entries, and if need-be, swaps them over.  </remarks> 
		</member>
		<member name="M:Hooks_Continue_" syntax="Hooks_Continue_(...)">
			<stacksize value="1"/>
			<referrer name="Hooks_GenerateContinue"/>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Hooks_CountInvalidPublics" syntax="Hooks_CountInvalidPublics()">
			<stacksize value="10"/>
			<referrer name="Hooks_SortPublics"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<remarks>  Counts the number of public functions that have had their names erased.  </remarks> 
		</member>
		<member name="M:Hooks_DoAllHooks" syntax="Hooks_DoAllHooks()">
			<stacksize value="617"/>
			<referrer name="CGen_OnCodeInit"/>
			<dependency name="AMX_GetNamePrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="E_CHAIN_HOOK"/>
			<dependency name="Hooks_Collate"/>
			<dependency name="Hooks_GetPreloadLibraries"/>
		</member>
		<member name="M:Hooks_GenerateCode" syntax="Hooks_GenerateCode(name[], hooks[], count, write, hasprehooks)">
			<stacksize value="7"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_DATA"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="CGen_AddCodeSpace"/>
			<dependency name="CGen_GetCodeSpace"/>
			<dependency name="Hooks_GetDefaultReturn"/>
			<dependency name="Hooks_WriteFunction"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Name of the function to generate.
			</param>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				All the functions to call.
			</param>
			<param name="count">
				Number of functions to call.
			</param>
			<param name="write">
				Where to write the new function's pointer.
			</param>
			<param name="hasprehooks">
				<paraminfo>bool </paraminfo>
				Needs to call other stuff first.
			</param>
			         
		</member>
		<member name="M:Hooks_GenerateContinue" syntax="Hooks_GenerateContinue(...)">
			<stacksize value="39"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitAddC"/>
			<dependency name="AsmEmitAddrPri"/>
			<dependency name="AsmEmitAnd"/>
			<dependency name="AsmEmitConstPri"/>
			<dependency name="AsmEmitJgrtrLabelStringize"/>
			<dependency name="AsmEmitJsleqLabelStringize"/>
			<dependency name="AsmEmitJumpLabelStringize"/>
			<dependency name="AsmEmitJzerLabelStringize"/>
			<dependency name="AsmEmitLabelStringize"/>
			<dependency name="AsmEmitLctrl"/>
			<dependency name="AsmEmitLoadI"/>
			<dependency name="AsmEmitLoadPri"/>
			<dependency name="AsmEmitLrefSPri"/>
			<dependency name="AsmEmitMoveAlt"/>
			<dependency name="AsmEmitMovePri"/>
			<dependency name="AsmEmitNeg"/>
			<dependency name="AsmEmitPadding"/>
			<dependency name="AsmEmitPopAlt"/>
			<dependency name="AsmEmitPopPri"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitPushPri"/>
			<dependency name="AsmEmitSctrl"/>
			<dependency name="AsmEmitShrCAlt"/>
			<dependency name="AsmEmitSrefSPri"/>
			<dependency name="AsmEmitStorAlt"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="Hooks_Continue_"/>
			<dependency name="O@A_"/>
			<dependency name="O@V_"/>
			<dependency name="YSI_g_sNPSStack"/>
			<dependency name="YSI_g_sTempRet"/>
			<dependency name="_@yH"/>
			<dependency name="ref"/>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Hooks_GetAllHooks" syntax="Hooks_GetAllHooks(name[], hooks[], idx, &amp;namelen, size)">
			<stacksize value="74"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_GetStringFromEntry"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Hooks_InvalidateName"/>
			<dependency name="Hooks_IsolateName"/>
			<dependency name="Hooks_MakeLongName"/>
			<dependency name="strcmp"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The name of the callback (with y_hooks prefix).
			</param>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				Array in which to store the function headers.
			</param>
			<param name="idx">
				Current position in the AMX header.
			</param>
			<param name="namelen">
				<paraminfo> &amp; </paraminfo>
				Min bound of space used by all these names.
			</param>
			<param name="size">
			</param>
			        <returns>  The number of hooks found.  </returns>  <remarks>  The name of the function currently being processed is derived from the first  found hook.  This means we already know of one hook, but to simplify the  code we get that one again here.  Above we only know the name not the  address.  Hence the "- 1" in "i = idx - 1" (to go back one function name).  Our "namelen" variable already contains the full length of the first found  hook - this is the length of "name", plus N extra characters.  The following  are all valid, and may occur when orders are played with:  @yH_OnX@  @yH_OnX@1  @yH_OnX@01  @yH_OnX@024  @yH_OnX@ZZZ  @yH_OnX@999@024  If we want to get the EXACT space taken up by all these hook names we would  need to get the string of the name in this function then measure it.  There  is really no point in doing this - if we have a second we will always have  enough space for our new names.  Instead, we assume that they are all just  @yH_OnX@  And add on that minimum length accordingly (plus 1 for the NULL character).  This length is used if the original callback doesn't exist but hooks do.  In  that case we need to add the callback to the AMX header, and there is a tiny  chance that the original name will be longer than one hook's name.  In that  case, having two or more hooks will (AFAIK) always ensure that we have  enough space to write the longer name.  If there is only one hook, no original function, and the name of the hook is  shorter than the name of the original function then we have an issue and  will have to do something else instead.  </remarks> 
		</member>
		<member name="M:Hooks_GetDefaultReturn" syntax="Hooks_GetDefaultReturn(name[])">
			<stacksize value="73"/>
			<referrer name="Hooks_GenerateCode"/>
			<dependency name="AMX_GetEntry"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="CallFunction"/>
			<dependency name="Hooks_MakeShortName"/>
			<dependency name="strcat"/>
			<dependency name="true"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				The function to get the default return of.
			</param>
			  <returns>  The default return for a callback, normally 1.  </returns> 
		</member>
		<member name="M:Hooks_GetFunctionWritePoint" syntax="Hooks_GetFunctionWritePoint(name[], &amp;write)">
			<stacksize value="8"/>
			<dependency name="AMX_GetEntry"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="true"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The function to get the address pointer of.
			</param>
			<param name="write">
				<paraminfo> &amp; </paraminfo>
				Destination variable.
			</param>
			    <returns>  The address at which this function's pointer is stored in the AMX header, if  the function exists of course.  </returns> 
		</member>
		<member name="M:Hooks_GetPointerRewrite" syntax="Hooks_GetPointerRewrite(hooks[], num, &amp;ptr, &amp;next, name[], nlen)">
			<stacksize value="39"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_DATA"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="AMX_WriteString"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Hooks_GetStubEntry"/>
			<dependency name="OP_JUMP"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="strlen"/>
			<dependency name="strpack"/>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				All the prehooks for this callback.
			</param>
			<param name="num">
				The number of prehooks.
			</param>
			<param name="ptr">
				<paraminfo> &amp; </paraminfo>
				A pointer to write the new stub address to.
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
				The pointer for the function called after y_hooks.
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The name of the callback being processed.
			</param>
			<param name="nlen">
				Space available in the header to write text in.
			</param>
			           
		</member>
		<member name="M:Hooks_GetPreHooks" syntax="Hooks_GetPreHooks(preloads[][], precount, name[], hooks[], &amp;count)">
			<stacksize value="73"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_GetEntry"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="E_CHAIN_HOOK_NAME"/>
			<dependency name="Hooks_MakeShortName"/>
			<dependency name="strcat"/>
			<dependency name="true"/>
			<param name="preloads">
				<paraminfo> [][17] </paraminfo>
				Names of libraries that come before y_hooks.
			</param>
			<param name="precount">
				Number of pre libraries.
			</param>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Name of the callback.
			</param>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				Destination in which to store the headers.
			</param>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of headers found.
			</param>
			          <remarks>  Finds all the AMX file headers for functions with a similar name to the  given callback that should be called before (or near) the given callback.  </remarks> 
		</member>
		<member name="M:Hooks_GetPreloadLibraries" syntax="Hooks_GetPreloadLibraries(preloads[][], &amp;precount, size)">
			<stacksize value="161"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="CallFunction"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_CHAIN_HOOK"/>
			<dependency name="E_CHAIN_HOOK_NAME"/>
			<dependency name="E_CHAIN_HOOK_VALUE"/>
			<dependency name="Hooks_InvalidateName"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<dependency name="unpack"/>
			<dependency name="unpack"/>
			<param name="preloads">
				<paraminfo> [][17] </paraminfo>
				Desination in which to store all the preloads.
			</param>
			<param name="precount">
				<paraminfo> &amp; </paraminfo>
				Number of found preload libraries.
			</param>
			<param name="size">
				Maximum number of libraries to store.
			</param>
			      <remarks>  Some includes, like "fixes.inc" and anti-cheats MUST come before all other  includes in order for everything to function correctly (at least fixes.inc  must).  This function looks for these definitions:  PRE_HOOK(FIXES)  Which tell y_hooks that any "FIXES_" prefixed callbacks are part of one of  these chains.  </remarks> 
		</member>
		<member name="M:Hooks_GetStubEntry" syntax="Hooks_GetStubEntry(stub)">
			<stacksize value="13"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmGetNumOperands"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmInit"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_SWITCH"/>
			<param name="stub">
				Starting address of the function.
			</param>
			  <returns>  The address at which the actual code in this function starts.  </returns>  <remarks>  This handles three cases.  Regular functions end instantly as found.  Functions that start with a switch (even before "PROC") are assumed to be  state-based functions, and we find the most likely state to be used (i.e. we  remove all future state changes).  </remarks> 
		</member>
		<member name="M:Hooks_InvalidateName" syntax="Hooks_InvalidateName(entry)">
			<stacksize value="5"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="CGen_OnCodeInit"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<param name="entry">
				The public function slot to destroy.
			</param>
			  <remarks>  Basically, once we know a function has been included, wipe it from the AMX  header.  </remarks> 
		</member>
		<member name="M:Hooks_IsolateName" syntax="Hooks_IsolateName(name[])">
			<stacksize value="152"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="Debug_Print0"/>
			<dependency name="false"/>
			<dependency name="strdel"/>
			<dependency name="strfind"/>
			<dependency name="unpack"/>
			<dependency name="unpack"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The string to get the hooked function name from.
			</param>
			  <returns>  The input string without y_hooks name decorations.  </returns> 
		</member>
		<member name="M:Hooks_MakeLongName" syntax="Hooks_MakeLongName(name[])">
			<stacksize value="10"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_LONG"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MIN"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_SHORT"/>
			<dependency name="Hooks_MakeShortName"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsShortOrder"/>
			<dependency name="false"/>
			<dependency name="strdel"/>
			<dependency name="strfind"/>
			<dependency name="strins"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Function name to modify.
			</param>
			  <remarks>  Expands all name parts like "CP" and "Obj" to their full versions (in this  example "Checkpoint" and "Object").  </remarks> 
		</member>
		<member name="M:Hooks_MakeShortName" syntax="Hooks_MakeShortName(name[])">
			<stacksize value="10"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_LONG"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_SHORT"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsLongOrder"/>
			<dependency name="false"/>
			<dependency name="strdel"/>
			<dependency name="strfind"/>
			<dependency name="strins"/>
			<dependency name="strlen"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Function name to modify.
			</param>
			  <remarks>  Compresses function names when required to fit within 32 characters  according to well defined rules (see "YSI_g_sReplacements").  </remarks> 
		</member>
		<member name="M:Hooks_NumArgs" syntax="Hooks_NumArgs()">
			<stacksize value="1"/>
		</member>
		<member name="M:Hooks_OnCodeInit" syntax="Hooks_OnCodeInit()">
			<attribute name="public"/>
			<stacksize value="28"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="AMX_Write"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="DisasmInit"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="GetAmxHeapTop"/>
			<dependency name="HeapRelease"/>
			<dependency name="Hooks_GenerateContinue"/>
			<dependency name="Indirect_Call"/>
			<dependency name="Indirect_Init"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_NONE"/>
			<dependency name="OP_NOP"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_STACK"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="YHNPS_Find"/>
			<dependency name="YHNPS_Push"/>
			<dependency name="YSI_g_sNPSBaseCall"/>
			<dependency name="YSI_g_sNPSReplace"/>
			<dependency name="YSI_g_sNPSStack"/>
			<dependency name="YSI_g_sNPSTrampoline"/>
			<dependency name="cellmin"/>
		</member>
		<member name="M:Hooks_Ordinal" syntax="Hooks_Ordinal(n)">
			<stacksize value="13"/>
			<referrer name="ScriptInit_OnRuntimeError"/>
			<dependency name="Hooks_Ordinal"/>
			<dependency name="strcat"/>
			<dependency name="valstr"/>
			<param name="n">
			</param>
		</member>
		<member name="M:Hooks_RepairJITInit" syntax="Hooks_RepairJITInit()">
			<stacksize value="7"/>
			<referrer name="CGen_OnCodeInit"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="FALSE"/>
			<dependency name="GetPublicAddressFromName"/>
			<dependency name="YSI_g_sInitFSIdx"/>
			<dependency name="YSI_g_sInitFSPtr"/>
			<dependency name="YSI_g_sInitFSRep"/>
			<dependency name="YSI_g_sInitGMIdx"/>
			<dependency name="YSI_g_sInitGMPtr"/>
			<dependency name="YSI_g_sInitGMRep"/>
			<dependency name="_Hooks_RepairStubFS"/>
			<dependency name="_Hooks_RepairStubGM"/>
		</member>
		<member name="M:Hooks_SortPublics" syntax="Hooks_SortPublics()">
			<stacksize value="8"/>
			<referrer name="CGen_OnCodeInit"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="Hooks_ComparePublics"/>
			<dependency name="Hooks_CountInvalidPublics"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="Server_JITExists"/>
			<dependency name="YSI_g_sInitPublicDiff"/>
			<dependency name="YSI_g_sSortedOnce"/>
			<dependency name="true"/>
			<remarks>  Goes through the whole of the public functions table and sorts them all in  to alphabetical order.  This is done as we move and rename some so we need  to fix the virtual machine's binary search.  </remarks> 
		</member>
		<member name="M:Hooks_SortReplacements" syntax="Hooks_SortReplacements()">
			<stacksize value="6"/>
			<referrer name="CGen_OnCodeInit"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MIN"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsLongOrder"/>
			<dependency name="YSI_g_sReplacementsShortOrder"/>
			<remarks>  Once all the replacement strings have been found, sort them by the length of  the short versions of the strings.  This is so that the longest (and special  case, e.g. "DynamicCP"-> "DynamicCP") replacements are always done first.  </remarks> 
		</member>
		<member name="M:Hooks_WriteFunction" syntax="Hooks_WriteFunction(pointers[], size, ret, skipable)">
			<stacksize value="29"/>
			<referrer name="Hooks_GenerateCode"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_ADDRESS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitAddC"/>
			<dependency name="AsmEmitAddrPri"/>
			<dependency name="AsmEmitAnd"/>
			<dependency name="AsmEmitCall"/>
			<dependency name="AsmEmitInvert"/>
			<dependency name="AsmEmitJsgeqLabelStringize"/>
			<dependency name="AsmEmitJslessLabelStringize"/>
			<dependency name="AsmEmitJumpLabelStringize"/>
			<dependency name="AsmEmitJzerLabelStringize"/>
			<dependency name="AsmEmitLabelStringize"/>
			<dependency name="AsmEmitLctrl"/>
			<dependency name="AsmEmitLoadSAlt"/>
			<dependency name="AsmEmitLoadSPri"/>
			<dependency name="AsmEmitMoveAlt"/>
			<dependency name="AsmEmitMovePri"/>
			<dependency name="AsmEmitMovs"/>
			<dependency name="AsmEmitOr"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitPush"/>
			<dependency name="AsmEmitPushAlt"/>
			<dependency name="AsmEmitPushC"/>
			<dependency name="AsmEmitPushPri"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitSctrl"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="AsmEmitStorPri"/>
			<dependency name="AsmEmitStorSPri"/>
			<dependency name="AsmEmitSub"/>
			<dependency name="AsmEmitSysreq"/>
			<dependency name="AsmEmitXchg"/>
			<dependency name="AsmEmitZeroAlt"/>
			<dependency name="CGen_GetCodeSpace"/>
			<dependency name="CGen_UseCodeSpace"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Server_JITExists"/>
			<dependency name="YSI_g_sActiveHooks"/>
			<dependency name="ref"/>
			<param name="pointers">
				<paraminfo> [] </paraminfo>
				The hooks to link together.
			</param>
			<param name="size">
				The number of functions in the array.
			</param>
			<param name="ret">
				The default return.
			</param>
			<param name="skipable">
				Can future hooks be ignored on -1?
			</param>
			        <returns>  The number of bytes written to memory.  </returns>  <remarks>  Generate some new code, very nicely :D.  </remarks> 
		</member>
		<member name="M:IPToInt" syntax="IPToInt(ip[])">
			<stacksize value="5"/>
			<referrer name="OnPlayerConnect"/>
			<dependency name="strval"/>
			<param name="ip">
				<paraminfo> [] </paraminfo>
				Dot notation IP to convert to an integer.
			</param>
			 
		</member>
		<member name="M:IS_IN_RANGE" syntax="IS_IN_RANGE(value, lower, upper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				The number to compare.
			</param>
			<param name="lower">
				The lower limit.
			</param>
			<param name="upper">
				The upper limit.
			</param>
			      <returns>  Is the value in the given range.  </returns>  <remarks>  Equivalent to:  <code>		(%1) &lt;= (%0) &lt; (%2)</code>  </remarks> 
		</member>
		<member name="M:ITER_SAFE_REMOVE" syntax="ITER_SAFE_REMOVE(iter[], &amp;index)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to deal with safely.
			</param>
			<param name="index">
				<paraminfo> &amp; </paraminfo>
				Index.
			</param>
			    <remarks>  Call functions that modify an iterator safely from inside a loop:  <code>  DestroyVehicle(vehicleid)  {  Iter_Remove(Vehicle, vehicleid);  }  foreach (new vehicleid : Vehicle)  {  ITER_SAFE_REMOVE(Vehicle, vehicleid)  {  DestroyVehicle(vehicleid);  }  }  </code>  </remarks> 
		</member>
		<member name="M:IgracRegistrovan" syntax="IgracRegistrovan(playerid)">
			<attribute name="public"/>
			<stacksize value="32"/>
			<dependency name="GetName"/>
			<dependency name="GetName"/>
			<dependency name="GivePlayerMoney"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracUlogovan"/>
			<dependency name="Level"/>
			<dependency name="Novac"/>
			<dependency name="OcistiChat"/>
			<dependency name="SQLID"/>
			<dependency name="SacuvajNalog"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SetPlayerScore"/>
			<dependency name="SetSpawnInfo"/>
			<dependency name="Skin"/>
			<dependency name="SpawnPlayer"/>
			<dependency name="TogglePlayerSpectating"/>
			<dependency name="cache_insert_id"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<dependency name="va_SendClientMessage"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Indirect_Array" syntax="Indirect_Array(func, tag, params[], size)">
			<stacksize value="6"/>
			<dependency name="GetPublicAddressFromIndex"/>
			<dependency name="GetTagNameFromID"/>
			<dependency name="INDIRECTION_DATA"/>
			<dependency name="INDIRECTION_TAG"/>
			<dependency name="funcidx"/>
			<dependency name="gsCodSize"/>
			<dependency name="memcpy"/>
			<param name="func">
			</param>
			<param name="tag">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Indirect_Call" syntax="Indirect_Call(func, tag, ...)">
			<stacksize value="6"/>
			<referrer name="Indirect_FromCallback"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="GetPublicAddressFromIndex"/>
			<dependency name="GetTagNameFromID"/>
			<dependency name="INDIRECTION_DATA"/>
			<dependency name="INDIRECTION_TAG"/>
			<dependency name="funcidx"/>
			<dependency name="gsCodSize"/>
			<param name="func">
			</param>
			<param name="tag">
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Indirect_Callstring" syntax="Indirect_Callstring(func, tag, ...)">
			<stacksize value="145"/>
			<dependency name="GetPublicAddressFromIndex"/>
			<dependency name="GetTagNameFromID"/>
			<dependency name="INDIRECTION_DATA"/>
			<dependency name="INDIRECTION_TAG"/>
			<dependency name="Indirect_Callstring"/>
			<dependency name="funcidx"/>
			<dependency name="gsCodSize"/>
			<param name="func">
			</param>
			<param name="tag">
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Indirect_Callvoid" syntax="Indirect_Callvoid(func, tag, ...)">
			<stacksize value="6"/>
			<dependency name="GetPublicAddressFromIndex"/>
			<dependency name="GetTagNameFromID"/>
			<dependency name="INDIRECTION_DATA"/>
			<dependency name="INDIRECTION_TAG"/>
			<dependency name="funcidx"/>
			<dependency name="gsCodSize"/>
			<param name="func">
			</param>
			<param name="tag">
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Indirect_Claim_" syntax="Indirect_Claim_(func)">
			<stacksize value="1"/>
			<dependency name="gsCodSize"/>
			<param name="func">
				The function pointer you want to use later.
			</param>
			  <remarks>  If a function pointer is used within one function, that is not a problem.  However, if you want to store the function pointer for use later, you must  first "claim" it, so that any associated data is not cleared when the  parent function ends (i.e. the function that called your function).  After  use it must be released, and the number of claims must match the number of  releases.  </remarks> 
		</member>
		<member name="M:Indirect_DePtr_" syntax="Indirect_DePtr_(ptr)">
			<stacksize value="2"/>
			<dependency name="gsCodSize"/>
			<dependency name="numargs"/>
			<param name="ptr">
			</param>
			<param name="">The array to convert to an offset pointer.</param>  <remarks>  Strings and arrays are passed relative to `COD` not `DAT` so they can be  distinguished from normal function pointers.  This function does the offset.  </remarks> 
		</member>
		<member name="M:Indirect_DeRef_" syntax="Indirect_DeRef_(...)">
			<stacksize value="2"/>
			<dependency name="gsCodSize"/>
			<dependency name="numargs"/>
			<param name="...">
				The array to convert to an offset pointer.
			</param>
			  <remarks>  Strings and arrays are passed relative to `COD` not `DAT` so they can be  distinguished from normal function pointers.  This function does the offset.  </remarks> 
		</member>
		<member name="M:Indirect_FromCallback" syntax="Indirect_FromCallback(cb, release)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<dependency name="Indirect_Call"/>
			<dependency name="Indirect_Release_"/>
			<param name="cb">
				<paraminfo>F@_@ </paraminfo>
			</param>
			<param name="release">
				<paraminfo>bool </paraminfo>
			</param>
			<remarks>  A generic public wrapper for calling inline functions.  </remarks> 
		</member>
		<member name="M:Indirect_GetMeta_" syntax="Indirect_GetMeta_(func)">
			<stacksize value="1"/>
			<dependency name="gsCodSize"/>
			<param name="func">
				The function pointer with attached metadata.
			</param>
			  <remarks>  Gets extra data from the pointer.  </remarks> 
		</member>
		<member name="M:Indirect_Init" syntax="Indirect_Init()">
			<stacksize value="21"/>
			<referrer name="ScriptInit_OnJITCompile"/>
			<referrer name="ScriptInit_OnFilterScriptInit"/>
			<referrer name="ScriptInit_OnGameModeInit"/>
			<referrer name="AMX_OnCodeInit"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AddressofResolve"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="gsCodSize"/>
			<remarks>  Get the size of the COD AMX segment.  </remarks> 
		</member>
		<member name="M:Indirect_Ptr_" syntax="Indirect_Ptr_(ptr)">
			<stacksize value="2"/>
			<dependency name="gsCodSize"/>
			<dependency name="numargs"/>
			<param name="ptr">
			</param>
			<param name="">The array to convert to an offset pointer.</param>  <remarks>  Strings and arrays are passed relative to `COD` not `DAT` so they can be  distinguished from normal function pointers.  This function does the offset.  </remarks> 
		</member>
		<member name="M:Indirect_Ref_" syntax="Indirect_Ref_(...)">
			<stacksize value="2"/>
			<dependency name="gsCodSize"/>
			<dependency name="numargs"/>
			<param name="...">
				The array to convert to an offset pointer.
			</param>
			  <remarks>  Strings and arrays are passed relative to `COD` not `DAT` so they can be  distinguished from normal function pointers.  This function does the offset.  </remarks> 
		</member>
		<member name="M:Indirect_Release_" syntax="Indirect_Release_(func)">
			<stacksize value="1"/>
			<referrer name="Indirect_FromCallback"/>
			<dependency name="gsCodSize"/>
			<param name="func">
				The function pointer you had previously stored.
			</param>
			  <remarks>  If a function pointer is used within one function, that is not a problem.  However, if you want to store the function pointer for use later, you must  first "claim" it, so that any associated data is not cleared when the  parent function ends (i.e. the function that called your function).  After  use it must be released, and the number of claims must match the number of  releases.  </remarks> 
		</member>
		<member name="M:Indirect_SetMeta_" syntax="Indirect_SetMeta_(func, data)">
			<stacksize value="1"/>
			<dependency name="gsCodSize"/>
			<param name="func">
				The function pointer to attach metadata to.
			</param>
			<param name="data">
				The metadata.
			</param>
			   
		</member>
		<member name="M:Indirect_Tag" syntax="Indirect_Tag(id, dest[])">
			<stacksize value="6"/>
			<dependency name="GetTagNameFromID"/>
			<dependency name="strcat"/>
			<param name="id">
				The ID of the tag to get the specifiers from the name of.  
			</param>
			<param name="dest">
				<paraminfo> [32] </paraminfo>
				Where to store the name.
			</param>
			    <remarks>  Functions are tagged with a special tag containing their specifiers.  Get  the string value of that tag from the AMX header.  </remarks> 
		</member>
		<member name="M:Indirection_OnFilterScriptInit" syntax="Indirection_OnFilterScriptInit()">
			<attribute name="public"/>
			<stacksize value="31"/>
			<dependency name="GetMaxPlayers"/>
			<dependency name="GetPlayerName"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="IsPlayerNPC"/>
			<dependency name="SSCANF_Init"/>
			<dependency name="SSCANF_IsConnected"/>
			<dependency name="SSCANF_Join"/>
			<dependency name="SSCANF_gInit"/>
			<dependency name="true"/>
		</member>
		<member name="M:Indirection_OnGameModeInit" syntax="Indirection_OnGameModeInit()">
			<attribute name="public"/>
			<stacksize value="31"/>
			<dependency name="GetMaxPlayers"/>
			<dependency name="GetPlayerName"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="IsPlayerNPC"/>
			<dependency name="SSCANF_Init"/>
			<dependency name="SSCANF_IsConnected"/>
			<dependency name="SSCANF_Join"/>
			<dependency name="SSCANF_gInit"/>
			<dependency name="true"/>
		</member>
		<member name="M:InitOpcodeTable" syntax="InitOpcodeTable()">
			<stacksize value="5"/>
			<referrer name="RelocateOpcode"/>
			<referrer name="UnrelocateOpcode"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="RelocateOpcodeNow"/>
			<dependency name="opcode_table"/>
			<dependency name="opcode_table_is_ready"/>
			<dependency name="true"/>
		</member>
		<member name="M:InterpolateColour" syntax="InterpolateColour(startcolor, endcolor, value, maxvalue, minvalue)">
			<stacksize value="3"/>
			<param name="startcolor">
				One of the two colours.
			</param>
			<param name="endcolor">
				The other of the two colours.
			</param>
			<param name="value">
				The interpolation value between the endpoints.
			</param>
			<param name="maxvalue">
				One of the two numbers.
			</param>
			<param name="minvalue">
				The other of the two numbers.
			</param>
			<summary>  InterpolateColour(startcolor, endcolor, value, maxvalue, minvalue = 0);  </summary>            <remarks>  This function takes two endpoint values (minvalue and maxvalue, with  minvalue defaulting to 0), along with a third value (value) whose distance  between the two endpoints is calculated (as a percentage).  This percentage  value is then applied to the two colours given to find a third colour at  some point between those two colours.  For example, if the endpoints given are "0" and "10", and the value given is  "3", then that is "30%" of the way between the two endpoints.  We therefore  want to find a colour that is 30% of the way between the two given colours.  </remarks> 
		</member>
		<member name="M:IsOpcodeValid" syntax="IsOpcodeValid(opcode)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="AsmEmitPadding"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:IsPlayerConnected" syntax="IsPlayerConnected(playerid)">
			<attribute name="native"/>
			<referrer name="SortArrayUsingCompInto_Entry"/>
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="Iter_OPDCInternal"/>
			<referrer name="Indirection_OnFilterScriptInit"/>
			<referrer name="Indirection_OnGameModeInit"/>
			<referrer name="ProxDetector"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:IsPlayerNPC" syntax="IsPlayerNPC(playerid)">
			<attribute name="native"/>
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="@yH_OnPlayerConnect@001"/>
			<referrer name="Iter_OPDCInternal"/>
			<referrer name="Indirection_OnFilterScriptInit"/>
			<referrer name="Indirection_OnGameModeInit"/>
			<referrer name="_y_utils_OnPlayerConnect"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:IsPrintableAscii" syntax="IsPrintableAscii(c)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="ToPrintableAscii"/>
			<param name="c">
			</param>
		</member>
		<member name="M:IsTagIDEmpty" syntax="IsTagIDEmpty(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIDStrong" syntax="IsTagIDStrong(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="IsTagIndexStrong"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIDWeak" syntax="IsTagIDWeak(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="IsTagIndexWeak"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIndexEmpty" syntax="IsTagIndexEmpty(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIndexStrong" syntax="IsTagIndexStrong(tag)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetTagInfo"/>
			<dependency name="IsTagIDStrong"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIndexWeak" syntax="IsTagIndexWeak(tag)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetTagInfo"/>
			<dependency name="IsTagIDWeak"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagNameEmpty" syntax="IsTagNameEmpty(tag[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:IsTagNameStrong" syntax="IsTagNameStrong(tag[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:IsTagNameWeak" syntax="IsTagNameWeak(tag[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:IsValidActor" syntax="IsValidActor(actorid)">
			<attribute name="native"/>
			<referrer name="@yH_OnScriptInit@001"/>
			<param name="actorid">
			</param>
		</member>
		<member name="M:Iter_ActorDo" syntax="Iter_ActorDo(add, actorid)">
			<stacksize value="7"/>
			<referrer name="@@Iter_ActorDo"/>
			<dependency name="operator*(_no_itertag:,_:)"/>
			<dependency name="FALSE"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Remove_InternalC"/>
			<dependency name="Iter_Single@Actor"/>
			<dependency name="Iterator@Actor"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="actorid">
			</param>
		</member>
		<member name="M:Iter_Add" syntax="Iter_Add(iter[], value)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to add the data to.
			</param>
			<param name="value">
				Value to add to the iterator.
			</param>
			    <remarks>  Wrapper for Iter_AddInternal.  native Iter_Add(Iterator:Name&lt;&gt;, value);  </remarks> 
		</member>
		<member name="M:Iter_AddStaticVehicle" syntax="Iter_AddStaticVehicle(modelid, spawn_x, spawn_y, spawn_z, angle, color1, color2)">
			<stacksize value="10"/>
			<dependency name="operator*(_no_itertag:,_:)"/>
			<dependency name="AddStaticVehicle"/>
			<dependency name="FALSE"/>
			<dependency name="I@"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Single@LocalVehicle"/>
			<dependency name="Iterator@LocalVehicle"/>
			<dependency name="J@"/>
			<dependency name="_@Iter_VehicleDo"/>
			<dependency name="true"/>
			<param name="modelid">
			</param>
			<param name="spawn_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="angle">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
		</member>
		<member name="M:Iter_AddStaticVehicleEx" syntax="Iter_AddStaticVehicleEx(modelid, spawn_x, spawn_y, spawn_z, angle, color1, color2, respawn_delay, addsiren)">
			<stacksize value="12"/>
			<dependency name="operator*(_no_itertag:,_:)"/>
			<dependency name="AddStaticVehicleEx"/>
			<dependency name="FALSE"/>
			<dependency name="I@"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Single@LocalVehicle"/>
			<dependency name="Iterator@LocalVehicle"/>
			<dependency name="J@"/>
			<dependency name="_@Iter_VehicleDo"/>
			<dependency name="true"/>
			<param name="modelid">
			</param>
			<param name="spawn_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="angle">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
			<param name="respawn_delay">
			</param>
			<param name="addsiren">
			</param>
		</member>
		<member name="M:Iter_Add_InternalC" syntax="Iter_Add_InternalC(&amp;count, array[], size, value)">
			<stacksize value="3"/>
			<referrer name="Iter_RandomAdd_InternalC"/>
			<referrer name="@yH_OnScriptInit@001"/>
			<referrer name="@yH_OnPlayerConnect@001"/>
			<referrer name="Iter_ActorDo"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_VehicleDo"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Array start index.
			</param>
			<param name="value">
				Item to add.
			</param>
			        <remarks>  Adds a value to a given iterator set.  Now detects when you try and add the  last item multiple times, as well as all the other items.  Now simplified  even further with the new internal representation.  The modulo code is for  iterator reversal.  </remarks> 
		</member>
		<member name="M:Iter_Add_InternalD" syntax="Iter_Add_InternalD(&amp;count, array[], start, size, value)">
			<stacksize value="3"/>
			<referrer name="Iter_RandomAdd_InternalD"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="size">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:Iter_All_Internal" syntax="Iter_All_Internal(array[], size, value)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:Iter_Alloc" syntax="Iter_Alloc(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the first free slot in.
			</param>
			  <remarks>  Finds an empty slot in an iterator, adds that slot to the iterator, and  returns the now added slot.  native Iter_Alloc(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_Alloc_InternalC" syntax="Iter_Alloc_InternalC(&amp;count, array[], size, ...)">
			<stacksize value="4"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Array start index.
			</param>
			<param name="...">
			</param>
			      <remarks>  Finds the first free slot in the iterator and add it.  Excepting requested  values.  </remarks> 
		</member>
		<member name="M:Iter_Alloc_InternalD" syntax="Iter_Alloc_InternalD(&amp;count, array[], start, size, ...)">
			<stacksize value="4"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="size">
			</param>
			<param name="...">
			</param>
		</member>
		<member name="M:Iter_Begin" syntax="Iter_Begin(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the start of.
			</param>
			  <remarks>  Gets a point BEFORE the start of the iterator (the theoretical beginning).  </remarks> 
		</member>
		<member name="M:Iter_Clear" syntax="Iter_Clear(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to empty.
			</param>
			  <remarks>  Wrapper for Iter_Clear_Internal.  Although it doesn't fit my normal strict spacing, the end of "B" is correct,  namely: "_:F@s(%0),%2)".  This uses the "_:%0,)" macro to consume  a trailing comma when nothing is given in "%2", so I can't have a leading  space sadly.  "- 2" in place of the normal "- 1" is CORRECT!  native Iter_Clear(IteratorArray:Name[]&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_Clear_InternalC" syntax="Iter_Clear_InternalC(array[], size, entries, ...)">
			<stacksize value="5"/>
			<referrer name="@yH_OnScriptInit@001"/>
			<dependency name="setarg"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Size of information.
			</param>
			<param name="entries">
				Size of the count data.
			</param>
			<param name="...">
				Optional single multi-iterator to clear.
			</param>
			        <remarks>  Resets an iterator.  </remarks> 
		</member>
		<member name="M:Iter_Clear_InternalD" syntax="Iter_Clear_InternalD(array[], size, entries, elems, counts[], start)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Size of base array.
			</param>
			<param name="entries">
				Size of the count data.
			</param>
			<param name="elems">
				Number of iterator elements.
			</param>
			<param name="counts">
				<paraminfo> [] </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="start">
				Optional single multi-iterator to clear.
			</param>
			            <remarks>  Resets an iterator.  </remarks> 
		</member>
		<member name="M:Iter_Contains" syntax="Iter_Contains(iter[], value)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to check membership of.
			</param>
			<param name="value">
				Value to check.
			</param>
			    <remarks>  Checks if the given value is in the given iterator.  native Iter_Contains(Iterator:Name&lt;&gt;, value);  </remarks> 
		</member>
		<member name="M:Iter_Contains_InternalC" syntax="Iter_Contains_InternalC(array[], size, value)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Size of the iterator.
			</param>
			<param name="value">
				Item to check.
			</param>
			      <remarks>  Checks if this item is in the iterator.  </remarks> 
		</member>
		<member name="M:Iter_Contains_InternalD" syntax="Iter_Contains_InternalD(count, array[], size, start, value)">
			<stacksize value="1"/>
			<param name="count">
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="start">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:Iter_Count" syntax="Iter_Count(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get a random slot from.
			</param>
			  <remarks>  Returns the number of items in this iterator.  native Iter_Count(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_CreateActor" syntax="Iter_CreateActor(modelid, X, Y, Z, Rotation)">
			<stacksize value="8"/>
			<dependency name="operator*(_no_itertag:,_:)"/>
			<dependency name="CreateActor"/>
			<dependency name="FALSE"/>
			<dependency name="I@"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Single@LocalActor"/>
			<dependency name="Iterator@LocalActor"/>
			<dependency name="J@"/>
			<dependency name="_@Iter_ActorDo"/>
			<dependency name="true"/>
			<param name="modelid">
			</param>
			<param name="X">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Rotation">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:Iter_CreateVehicle" syntax="Iter_CreateVehicle(modelid, x, y, z, angle, color1, color2, respawn_delay, addsiren)">
			<stacksize value="12"/>
			<dependency name="operator*(_no_itertag:,_:)"/>
			<dependency name="CreateVehicle"/>
			<dependency name="FALSE"/>
			<dependency name="I@"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Single@LocalVehicle"/>
			<dependency name="Iterator@LocalVehicle"/>
			<dependency name="J@"/>
			<dependency name="_@Iter_VehicleDo"/>
			<dependency name="true"/>
			<param name="modelid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="angle">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
			<param name="respawn_delay">
			</param>
			<param name="addsiren">
			</param>
		</member>
		<member name="M:Iter_DestroyActor" syntax="Iter_DestroyActor(actorid)">
			<stacksize value="7"/>
			<dependency name="operator*(_no_itertag:,_:)"/>
			<dependency name="DestroyActor"/>
			<dependency name="FALSE"/>
			<dependency name="I@"/>
			<dependency name="Iter_Remove_InternalC"/>
			<dependency name="Iter_Single@LocalActor"/>
			<dependency name="Iterator@LocalActor"/>
			<dependency name="J@"/>
			<dependency name="_@Iter_ActorDo"/>
			<dependency name="false"/>
			<param name="actorid">
			</param>
		</member>
		<member name="M:Iter_DestroyVehicle" syntax="Iter_DestroyVehicle(vehicleid)">
			<stacksize value="7"/>
			<dependency name="operator*(_no_itertag:,_:)"/>
			<dependency name="DestroyVehicle"/>
			<dependency name="FALSE"/>
			<dependency name="I@"/>
			<dependency name="Iter_Remove_InternalC"/>
			<dependency name="Iter_Single@LocalVehicle"/>
			<dependency name="Iterator@LocalVehicle"/>
			<dependency name="J@"/>
			<dependency name="_@Iter_VehicleDo"/>
			<dependency name="false"/>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:Iter_End" syntax="Iter_End(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the end of.
			</param>
			  <remarks>  Gets a point AFTER the end of the iterator (think "MAX_PLAYERS").  </remarks> 
		</member>
		<member name="M:Iter_FastClear" syntax="Iter_FastClear(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to empty.
			</param>
			  <remarks>  Uses a static array copy to blank the iterator instead of a loop.  BROKEN!  native Iter_FastClear(IteratorArray:Name[]&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_First" syntax="Iter_First(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the first valid element in.
			</param>
			  <remarks>  Gets the first element in an iterator.  </remarks> 
		</member>
		<member name="M:Iter_Free" syntax="Iter_Free(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the first free slot in.
			</param>
			  <remarks>  Wrapper for Iter_Free_Internal.  Returns a slot NOT in the current  iterator.  native Iter_Free(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_FreeMulti" syntax="Iter_FreeMulti(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the multi-iterator to get the first free slot in.
			</param>
			  <remarks>  Wrapper for Iter_FreeMulti_Internal.  Returns a slot NOT in the current  multi-iterator.  native Iter_FreeMulti(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_FreeMulti_Internal" syntax="Iter_FreeMulti_Internal(array[], trueSize, start)">
			<stacksize value="2"/>
			<dependency name="cellmin"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				multi-iterator data.
			</param>
			<param name="trueSize">
				Size of the multi-iterator.
			</param>
			<param name="start">
				End [?, since start points are backwards] of the multi-iterator.
			</param>
			      <remarks>  Finds the first free multi index in the multi-iterator.  </remarks> 
		</member>
		<member name="M:Iter_Free_Internal" syntax="Iter_Free_Internal(array[], size)">
			<stacksize value="2"/>
			<dependency name="cellmin"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Size of the iterator.
			</param>
			    <remarks>  Finds the first free slot in the iterator.  </remarks> 
		</member>
		<member name="M:Iter_Func@Fib" syntax="Iter_Func@Fib(&amp;iterstart, cur)">
			<stacksize value="1"/>
			<param name="iterstart">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="cur">
			</param>
		</member>
		<member name="M:Iter_Func@Filter" syntax="Iter_Func@Filter(cur, val, arr[], size)">
			<stacksize value="1"/>
			<param name="cur">
			</param>
			<param name="val">
			</param>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_Func@NonNull" syntax="Iter_Func@NonNull(cur, arr[], size)">
			<stacksize value="1"/>
			<param name="cur">
			</param>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_Func@Null" syntax="Iter_Func@Null(cur, arr[], size)">
			<stacksize value="1"/>
			<param name="cur">
			</param>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_Func@Powers" syntax="Iter_Func@Powers(&amp;iterstart, cur, base)">
			<stacksize value="1"/>
			<param name="iterstart">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="cur">
			</param>
			<param name="base">
			</param>
		</member>
		<member name="M:Iter_Func@Random" syntax="Iter_Func@Random(&amp;iterstart, cur, count, min, max)">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<dependency name="random"/>
			<param name="iterstart">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="cur">
			</param>
			<param name="count">
			</param>
			<param name="min">
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:Iter_Func@Range" syntax="Iter_Func@Range(cur, min, max, step)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="cur">
			</param>
			<param name="min">
			</param>
			<param name="max">
			</param>
			<param name="step">
			</param>
		</member>
		<member name="M:Iter_Func@Until" syntax="Iter_Func@Until(cur, val, arr[], size)">
			<stacksize value="1"/>
			<param name="cur">
			</param>
			<param name="val">
			</param>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_GetMulti" syntax="Iter_GetMulti(iter[], value)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to check membership of.
			</param>
			<param name="value">
				Value to check.
			</param>
			    <returns>  Index in which the value is contained in the multi-iterator.  </returns>  <remarks>  Checks if the given value is in the given iterator, and if it is return which index it is contained.  native Iter_GetMulti(Iterator:Name&lt;&gt;, value);  </remarks> 
		</member>
		<member name="M:Iter_GetMulti_Internal" syntax="Iter_GetMulti_Internal(array[], trueSize, size, value)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				multi-iterator data.
			</param>
			<param name="trueSize">
				Size of the multi-iterator per index.
			</param>
			<param name="size">
				Size of the multi-iterator.
			</param>
			<param name="value">
				Item to check.
			</param>
			        <returns>  INVALID_ITERATOR_SLOT on failure.  Index of the multi-iterator the value is contained.  </returns>  <remarks>  Checks if this item is in the multi-iterator at all, and if it is returns which index it is in.  </remarks> 
		</member>
		<member name="M:Iter_Index" syntax="Iter_Index(iter[], index, wrap)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get a slot in by index.
			</param>
			<param name="index">
				Index.
			</param>
			<param name="wrap">
				<paraminfo>bool </paraminfo>
				Keep going around until a value is found?
			</param>
			      <remarks>  Wrapper for Iter_Index_Internal.  Returns the Nth value in the iterator  (requires looping due to the way iterators are stored and optimised for  loops not direct access).  native Iter_Index(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_Index_Internal" syntax="Iter_Index_Internal(count, array[], start, size, index, wrap)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="count">
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="start">
				Array start index.
			</param>
			<param name="size">
				Array size.
			</param>
			<param name="index">
				Index to find Nth value.
			</param>
			<param name="wrap">
				<paraminfo>bool </paraminfo>
				Keep going around until a value is found?
			</param>
			            <remarks>  Allows you to find the Nth value in the iterator.  DO NOT call this in a  loop to get all values - that totally defeats the purpose of "foreach", just  use a normal "foreach" loop with an index counter for that case.  </remarks> 
		</member>
		<member name="M:Iter_Init" syntax="Iter_Init(iter[][])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [][] </paraminfo>
				Name of the iterator array to initialise.
			</param>
			  <remarks>  Wrapper for Iter_Init_Internal.  When <c>__COMPILER_NESTED_ELLIPSIS</c> is  set, this isn't needed because multi-dimensional iterators can be  initialised with the new <c>{{0, 1, ...), ...}</c> feature.  In that case  <c>I@ = 0</c> is called as a <c>void</c> function that does nothing but ends  in a semi-colon (<c>I@</c> is used a lot in YSI as a <c>do nothing</c>  enabler).  <code>native Iter_Init(IteratorArray:Name[]&lt;&gt;);</code>  </remarks> 
		</member>
		<member name="M:Iter_Init_Internal" syntax="Iter_Init_Internal(array[][], first[], s0, s1, entries)">
			<stacksize value="9"/>
			<dependency name="memcpy"/>
			<param name="array">
				<paraminfo> [][] </paraminfo>
				Iterator array to initialise.
			</param>
			<param name="first">
				<paraminfo> [] </paraminfo>
				First iterator slot.
			</param>
			<param name="s0">
				Size of first dimension.
			</param>
			<param name="s1">
				Size of second dimension.
			</param>
			<param name="entries">
				Number of start points.
			</param>
			          <remarks>  Multi-dimensional arrays can't be initialised at compile time, so need to be  done at run time, which is slightly annoying.  </remarks> 
		</member>
		<member name="M:Iter_Last" syntax="Iter_Last(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to
			</param>
			  <remarks>  Gets the last element in an iterator.  Works by getting the previous item  from the one BEFORE the first element (i.e. the one before the sentinel).  </remarks> 
		</member>
		<member name="M:Iter_Next" syntax="Iter_Next(iter[], cur)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the next element in.
			</param>
			<param name="cur">
				The current element.
			</param>
			    <remarks>  Gets the element in an iterator after the current one.  </remarks> 
		</member>
		<member name="M:Iter_None_Internal" syntax="Iter_None_Internal(array[], size, value)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:Iter_OPDCInternal" syntax="Iter_OPDCInternal(playerid)">
			<attribute name="public"/>
			<stacksize value="7"/>
			<dependency name="operator*(_no_itertag:,_:)"/>
			<dependency name="FALSE"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="IsPlayerNPC"/>
			<dependency name="Iter_Remove_InternalC"/>
			<dependency name="Iter_Single@Bot"/>
			<dependency name="Iter_Single@Character"/>
			<dependency name="Iter_Single@Player"/>
			<dependency name="Iterator@Bot"/>
			<dependency name="Iterator@Character"/>
			<dependency name="Iterator@Player"/>
			<param name="playerid">
				Player who left.
			</param>
			  <remarks>  Called AFTER "OnPlayerDisconnect" so that using "Kick" inside a  "foreach" loop doesn't crash the server due to an OOB error.  </remarks> 
		</member>
		<member name="M:Iter_Prev" syntax="Iter_Prev(iter[], cur)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the previous element in.
			</param>
			<param name="cur">
				The current element.
			</param>
			    <remarks>  Gets the element in an iterator before the current one.  Slow.  </remarks> 
		</member>
		<member name="M:Iter_Prev_Internal" syntax="Iter_Prev_Internal(array[], elems, size, slot)">
			<stacksize value="2"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="elems">
				Number of elements in the iterator.
			</param>
			<param name="size">
				Size of the iterator.
			</param>
			<param name="slot">
				The current slot.
			</param>
			        <remarks>  Gets the element in an iterator that points to the current element.  </remarks> 
		</member>
		<member name="M:Iter_Random" syntax="Iter_Random(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get a random slot from.
			</param>
			  <remarks>  Wrapper for Iter_RandomInternal.  native Iter_Random(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_RandomAdd" syntax="Iter_RandomAdd(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to add a random slot to.
			</param>
			  <remarks>  Wrapper for Iter_RandomAddInternal.  native Iter_RandomAdd(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_RandomAdd_InternalC" syntax="Iter_RandomAdd_InternalC(&amp;count, array[], start, ...)">
			<stacksize value="18"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_RandomFree_InternalC"/>
			<dependency name="YVA2_DummyPush"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="start">
				Size of the iterator.
			</param>
			<param name="...">
			</param>
			      <remarks>  Adds a random value to an iterator.  </remarks> 
		</member>
		<member name="M:Iter_RandomAdd_InternalD" syntax="Iter_RandomAdd_InternalD(counts[], array[], size, slots, start, slot, ...)">
			<stacksize value="20"/>
			<dependency name="Iter_Add_InternalD"/>
			<dependency name="Iter_RandomFree_InternalC"/>
			<dependency name="YVA2_DummyPush"/>
			<param name="counts">
				<paraminfo> [] </paraminfo>
				Number of items in each iterator part.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Size of the iterator.
			</param>
			<param name="slots">
				Number of multi-iterator values.
			</param>
			<param name="start">
				
			</param>
			<param name="slot">
				Multi-iterator slot to add to.
			</param>
			<param name="...">
			</param>
			            <remarks>  Adds a random value to an iterator.  </remarks> 
		</member>
		<member name="M:Iter_RandomFree" syntax="Iter_RandomFree(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get a random unused slot for.
			</param>
			  <remarks>  Wrapper for Iter_RandomFree_Internal.  native Iter_RandomFree(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_RandomFree_InternalC" syntax="Iter_RandomFree_InternalC(count, array[], start, ...)">
			<stacksize value="9"/>
			<referrer name="Iter_RandomAdd_InternalC"/>
			<referrer name="Iter_RandomAdd_InternalD"/>
			<referrer name="Iter_RandomFree_InternalD"/>
			<dependency name="cellmin"/>
			<dependency name="random"/>
			<param name="count">
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="start">
				Size of the iterator.
			</param>
			<param name="...">
			</param>
			      <remarks>  Returns a random unused value from an iterator.  </remarks> 
		</member>
		<member name="M:Iter_RandomFree_InternalD" syntax="Iter_RandomFree_InternalD(counts[], array[], start, slots, ...)">
			<stacksize value="16"/>
			<dependency name="Iter_RandomFree_InternalC"/>
			<dependency name="YVA2_DummyPush"/>
			<param name="counts">
				<paraminfo> [] </paraminfo>
				Number of items in each iterator part.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="start">
				Size of the iterator.
			</param>
			<param name="slots">
				Number of multi-iterator values.
			</param>
			<param name="...">
			</param>
			        <remarks>  Returns a random unused value from an iterator.  </remarks> 
		</member>
		<member name="M:Iter_RandomRemove" syntax="Iter_RandomRemove(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to remove a random slot from.
			</param>
			  <remarks>  Wrapper for Iter_RandomRemoveInternal.  native Iter_RandomRemove(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:Iter_RandomRemove_InternalC" syntax="Iter_RandomRemove_InternalC(&amp;count, array[], start, ...)">
			<stacksize value="18"/>
			<dependency name="Iter_Random_Internal"/>
			<dependency name="Iter_Remove_InternalC"/>
			<dependency name="YVA2_DummyPush"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="start">
				Size of the iterator.
			</param>
			<param name="...">
			</param>
			      <remarks>  Removes a random value from an iterator.  </remarks> 
		</member>
		<member name="M:Iter_RandomRemove_InternalD" syntax="Iter_RandomRemove_InternalD(&amp;count, array[], size, start, ...)">
			<stacksize value="19"/>
			<dependency name="Iter_Random_Internal"/>
			<dependency name="Iter_Remove_InternalD"/>
			<dependency name="YVA2_DummyPush"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
			</param>
			<param name="start">
				Size of the iterator.
			</param>
			<param name="...">
			</param>
			      <param name="slots">Number of multi-iterator values.</param>  <remarks>  Removes a random value from an iterator.  </remarks> 
		</member>
		<member name="M:Iter_Random_Internal" syntax="Iter_Random_Internal(count, array[], start, ...)">
			<stacksize value="9"/>
			<referrer name="Iter_RandomRemove_InternalC"/>
			<referrer name="Iter_RandomRemove_InternalD"/>
			<dependency name="cellmin"/>
			<dependency name="random"/>
			<param name="count">
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="start">
				Size of the iterator.
			</param>
			<param name="...">
				Excluded elements.
			</param>
			        <remarks>  Returns a random value from an iterator.  If additional parameters are given they are excluded from consideration.  This allows you to chain calls to get multiple random values so follows:  new president     = Iter_Random(Player);  new vicePresident = Iter_Random(Player, president);  new primeMinister = Iter_Random(Player, president, vicePresident);  new minister      = Iter_Random(Player, president, vicePresident, primeMinister);  None of those values can be the same, and this saves horrible random-  dependent loops.  </remarks> 
		</member>
		<member name="M:Iter_Remove" syntax="Iter_Remove(iter[], value)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to remove data from.
			</param>
			<param name="value">
				Data to remove.
			</param>
			    <remarks>  Wrapper for Iter_RemoveInternal.  native Iter_Remove(Iterator:Name&lt;&gt;, value);  </remarks> 
		</member>
		<member name="M:Iter_Remove_InternalC" syntax="Iter_Remove_InternalC(&amp;count, array[], size, value)">
			<stacksize value="8"/>
			<referrer name="Iter_RandomRemove_InternalC"/>
			<referrer name="Iter_OPDCInternal"/>
			<referrer name="Iter_ActorDo"/>
			<referrer name="Iter_DestroyActor"/>
			<referrer name="Iter_VehicleDo"/>
			<referrer name="Iter_DestroyVehicle"/>
			<dependency name="Iter_SafeRemove_InternalC"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Number of iterator elements.
			</param>
			<param name="value">
				Item to remove.
			</param>
			        <remarks>  Removes a value from an iterator.  </remarks> 
		</member>
		<member name="M:Iter_Remove_InternalD" syntax="Iter_Remove_InternalD(&amp;count, array[], start, size, value)">
			<stacksize value="9"/>
			<referrer name="Iter_RandomRemove_InternalD"/>
			<dependency name="Iter_SafeRemove_InternalD"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="size">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:Iter_SafeRemove" syntax="Iter_SafeRemove(iter[], value, &amp;next)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to remove data from.
			</param>
			<param name="value">
				Data to remove.
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
				Container for the pointer to the next element.
			</param>
			      <remarks>  Wrapper for Iter_SafeRemoveInternal.  Common use:  Iter_SafeRemove(iter, i, i);  native Iter_SafeRemove(Iterator:Name&lt;&gt;, value, &amp;next);  </remarks> 
		</member>
		<member name="M:Iter_SafeRemove_InternalC" syntax="Iter_SafeRemove_InternalC(&amp;count, array[], size, value, &amp;last)">
			<stacksize value="1"/>
			<referrer name="Iter_Remove_InternalC"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				Iterator data.
			</param>
			<param name="size">
				Number of iterator elements.
			</param>
			<param name="value">
				Item to remove.
			</param>
			<param name="last">
				<paraminfo> &amp; </paraminfo>
				Pointer in which to store the last pointer.
			</param>
			          <remarks>  Removes a value from an iterator safely.  </remarks> 
		</member>
		<member name="M:Iter_SafeRemove_InternalD" syntax="Iter_SafeRemove_InternalD(&amp;count, array[], start, size, value, &amp;last)">
			<stacksize value="1"/>
			<referrer name="Iter_Remove_InternalD"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="size">
			</param>
			<param name="value">
			</param>
			<param name="last">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:Iter_Size" syntax="Iter_Size(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the size of.
			</param>
			  <remarks>  Accesses the size of an iterator.  </remarks> 
		</member>
		<member name="M:Iter_Starts" syntax="Iter_Starts(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the true starts of.
			</param>
			  <remarks>  Accesses the number of starts in a multi-iterator.  </remarks> 
		</member>
		<member name="M:Iter_TrueArray" syntax="Iter_TrueArray(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the true array of.
			</param>
			  <remarks>  Accesses the internal array of an iterator.  </remarks> 
		</member>
		<member name="M:Iter_TrueCount" syntax="Iter_TrueCount(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the true count of.
			</param>
			  <remarks>  Accesses the internal count of an iterator.  </remarks> 
		</member>
		<member name="M:Iter_TrueMulti" syntax="Iter_TrueMulti(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Multi iterator to get the true count of.
			</param>
			  <remarks>  Accesses the internal count of a multi-iterator.  </remarks> 
		</member>
		<member name="M:Iter_TrueSize" syntax="Iter_TrueSize(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the true size of.
			</param>
			  <remarks>  Accesses the internal size of an iterator.  </remarks> 
		</member>
		<member name="M:Iter_VehicleDo" syntax="Iter_VehicleDo(add, vehicleid)">
			<stacksize value="7"/>
			<referrer name="@@Iter_VehicleDo"/>
			<dependency name="operator*(_no_itertag:,_:)"/>
			<dependency name="FALSE"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Remove_InternalC"/>
			<dependency name="Iter_Single@Vehicle"/>
			<dependency name="Iterator@Vehicle"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:Iter_YieldEnter" syntax="Iter_YieldEnter()">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="Debug_Print0"/>
			<dependency name="YSI_gIteratorDepth"/>
			<dependency name="YSI_g_sIteratorStack"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<remarks>  </remarks> 
		</member>
		<member name="M:Iter_YieldLoop" syntax="Iter_YieldLoop()">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="E_ITER_YIELD_FIRST"/>
			<dependency name="E_ITER_YIELD_STACK_SIZE"/>
			<dependency name="YSI_gIteratorDepth"/>
			<dependency name="YSI_g_sIteratorStack"/>
			<dependency name="YSI_g_sIteratorStack"/>
			<dependency name="YSI_g_sPtr"/>
			<dependency name="YSI_g_sStackPtr"/>
			<dependency name="false"/>
			<dependency name="memcpy"/>
			<dependency name="true"/>
		</member>
		<member name="M:Iter_YieldReturn" syntax="Iter_YieldReturn(value)">
			<stacksize value="1"/>
			<dependency name="I@"/>
			<dependency name="YSI_gIteratorDepth"/>
			<dependency name="YSI_g_sIteratorStack"/>
			<dependency name="YSI_g_sPtr"/>
			<dependency name="YSI_g_sStackPtr"/>
			<dependency name="memcpy"/>
			<param name="value">
			</param>
		</member>
		<member name="M:Iterator" syntax="Iterator(name)">
			<tagname value="Iterator"/>
			<stacksize value="1"/>
			<param name="name">
			</param>
			<remarks>  Creates a new iterator start/array pair.  </remarks> 
		</member>
		<member name="M:Iterator@Reverse" syntax="Iterator@Reverse(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Iterator to run backwards.
			</param>
			  <remarks>  Run an iterator backwards.  </remarks> 
		</member>
		<member name="M:Kick" syntax="Kick(playerid)">
			<attribute name="native"/>
			<referrer name="pc_cmd_kick"/>
			<referrer name="OnDialogResponse"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:KreirajGlobalneTD" syntax="KreirajGlobalneTD()">
			<stacksize value="5"/>
			<referrer name="PawnCmd_OnGameModeInit"/>
			<dependency name="LOGREG_TD"/>
			<dependency name="TextDrawAlignment"/>
			<dependency name="TextDrawBackgroundColor"/>
			<dependency name="TextDrawColor"/>
			<dependency name="TextDrawCreate"/>
			<dependency name="TextDrawFont"/>
			<dependency name="TextDrawLetterSize"/>
			<dependency name="TextDrawSetOutline"/>
			<dependency name="TextDrawSetProportional"/>
			<dependency name="TextDrawSetSelectable"/>
			<dependency name="TextDrawSetShadow"/>
			<dependency name="TextDrawTextSize"/>
			<dependency name="false"/>
			<dependency name="true"/>
		</member>
		<member name="M:KreirajMape" syntax="KreirajMape()">
			<stacksize value="17"/>
			<referrer name="PawnCmd_OnGameModeInit"/>
			<dependency name="CreateDynamicObject"/>
			<dependency name="SetDynamicObjectMaterial"/>
			<dependency name="SetDynamicObjectMaterialText"/>
		</member>
		<member name="M:KreirajPlayerTD" syntax="KreirajPlayerTD(playerid)">
			<stacksize value="6"/>
			<referrer name="ProvjeriBANIP"/>
			<dependency name="CreatePlayerTextDraw"/>
			<dependency name="PlayerTextDrawAlignment"/>
			<dependency name="PlayerTextDrawBackgroundColor"/>
			<dependency name="PlayerTextDrawColor"/>
			<dependency name="PlayerTextDrawFont"/>
			<dependency name="PlayerTextDrawLetterSize"/>
			<dependency name="PlayerTextDrawSetOutline"/>
			<dependency name="PlayerTextDrawSetProportional"/>
			<dependency name="PlayerTextDrawSetShadow"/>
			<dependency name="USERNAME_TD"/>
			<dependency name="USERNAME_TD"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:L@" syntax="L@(ret, ...)">
			<stacksize value="8"/>
			<referrer name="@@Iter_ActorDo"/>
			<referrer name="@@Iter_VehicleDo"/>
			<dependency name="YSI_g_sPropReturn"/>
			<dependency name="YSI_g_sPropVarArg"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<dependency name="setproperty"/>
			<param name="ret">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:LevenshteinDistance" syntax="LevenshteinDistance(a[], b[])">
			<stacksize value="9"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DoLevenshteinDistance"/>
			<dependency name="strcmp"/>
			<dependency name="strlen"/>
			<param name="a">
				<paraminfo> [] </paraminfo>
				First string to compare.
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
				Second string to compare.
			</param>
			    <returns>  The levenshtein difference (0 if the same).  </returns> 
		</member>
		<member name="M:Mean" syntax="Mean(arr[], num)">
			<stacksize value="5"/>
			<dependency name="Sum"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical mean value of the array.  </returns> 
		</member>
		<member name="M:Median" syntax="Median(arr[], num)">
			<stacksize value="5"/>
			<dependency name="Utils_PreSort"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical median value of the array.  </returns> 
		</member>
		<member name="M:Mode" syntax="Mode(arr[], num)">
			<stacksize value="6"/>
			<dependency name="Utils_PreSort"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical modal value of the array.  </returns> 
		</member>
		<member name="M:NOT_IN_RANGE" syntax="NOT_IN_RANGE(value, lower, upper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				The number to compare.
			</param>
			<param name="lower">
				The lower limit.
			</param>
			<param name="upper">
				The upper limit.
			</param>
			      <returns>  Is the value outside the given range.  </returns>  <remarks>  Equivalent to:  <code>		(%1) &lt;= (%0) &lt; (%2)</code>  </remarks> 
		</member>
		<member name="M:NtCompare" syntax="NtCompare(s1, s2[])">
			<stacksize value="8"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetTagIndexFromName"/>
			<dependency name="ReadAmxMemory"/>
			<param name="s1">
			</param>
			<param name="s2">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:NtCopy" syntax="NtCopy(src, dest[], size)">
			<stacksize value="6"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<dependency name="ReadAmxMemory"/>
			<param name="src">
			</param>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:O@A_" syntax="O@A_()">
			<tagname value="bool"/>
			<stacksize value="11"/>
			<referrer name="AddressofResolve"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="YVA2_Initalise"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="DisasmInit"/>
			<dependency name="DisasmNext"/>
			<dependency name="GetCurrentFrameReturn"/>
			<dependency name="O@V_"/>
			<dependency name="OP_CALL"/>
			<dependency name="false"/>
		</member>
		<member name="M:OcistiChat" syntax="OcistiChat(playerid, brojlinija)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="IgracRegistrovan"/>
			<dependency name="SendClientMessage"/>
			<param name="playerid">
			</param>
			<param name="brojlinija">
			</param>
		</member>
		<member name="M:OnActorStreamIn" syntax="OnActorStreamIn(actorid, forplayerid)">
			<stacksize value="1"/>
			<param name="actorid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnActorStreamOut" syntax="OnActorStreamOut(actorid, forplayerid)">
			<stacksize value="1"/>
			<param name="actorid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnDialogResponse" syntax="OnDialogResponse(playerid, dialogid, response, listitem, inputtext[])">
			<attribute name="public"/>
			<stacksize value="509"/>
			<dependency name="CancelSelectTextDraw"/>
			<dependency name="GetName"/>
			<dependency name="GivePlayerMoney"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracUlogovan"/>
			<dependency name="Kick"/>
			<dependency name="Level"/>
			<dependency name="Novac"/>
			<dependency name="OcistiChat"/>
			<dependency name="Password"/>
			<dependency name="SQL"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SetCameraBehindPlayer"/>
			<dependency name="SetPlayerScore"/>
			<dependency name="ShowPlayerDialog"/>
			<dependency name="SpawnPlayer"/>
			<dependency name="TogglePlayerSpectating"/>
			<dependency name="false"/>
			<dependency name="format"/>
			<dependency name="mysql_format"/>
			<dependency name="mysql_tquery"/>
			<dependency name="strlen"/>
			<dependency name="true"/>
			<dependency name="udb_hash"/>
			<dependency name="va_SendClientMessage"/>
			<param name="playerid">
			</param>
			<param name="dialogid">
			</param>
			<param name="response">
			</param>
			<param name="listitem">
			</param>
			<param name="inputtext">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:OnDynamicActorStreamIn" syntax="OnDynamicActorStreamIn(actorid, forplayerid)">
			<stacksize value="1"/>
			<param name="actorid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnDynamicActorStreamOut" syntax="OnDynamicActorStreamOut(actorid, forplayerid)">
			<stacksize value="1"/>
			<param name="actorid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnDynamicObjectMoved" syntax="OnDynamicObjectMoved(objectid)">
			<stacksize value="1"/>
			<param name="objectid">
			</param>
		</member>
		<member name="M:OnEnterExitModShop" syntax="OnEnterExitModShop(playerid, enterexit, interiorid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="enterexit">
			</param>
			<param name="interiorid">
			</param>
		</member>
		<member name="M:OnFilterScriptExit" syntax="OnFilterScriptExit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="ScriptInit_OnFilterScriptExit"/>
			<dependency name="ScriptInit_OnScriptExit"/>
			<dependency name="ScriptInit_PostExitFuncs_"/>
			<dependency name="ScriptInit_PreExitFuncs_"/>
			<dependency name="YSI_FILTERSCRIPT"/>
		</member>
		<member name="M:OnFilterScriptInit" syntax="OnFilterScriptInit()">
			<attribute name="public"/>
			<stacksize value="4"/>
			<dependency name="ScriptInit_CallOnCodeInit"/>
			<dependency name="ScriptInit_OnFilterScriptInit"/>
			<dependency name="ScriptInit_PostInitFuncs_"/>
			<dependency name="ScriptInit_PreInitFuncs_"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<dependency name="YSI_g_sCodeJITing"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<transition keep="true" target="_script_init_fix_state : true"/>  <transition keep="true" target="_ALS : _ALS_go"/>  <transition target="_ALS_go"/>

		</member>
		<member name="M:OnGameModeExit" syntax="OnGameModeExit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="ScriptInit_OnGameModeExit"/>
			<dependency name="ScriptInit_OnScriptExit"/>
			<dependency name="ScriptInit_PostExitFuncs_"/>
			<dependency name="ScriptInit_PreExitFuncs_"/>
			<dependency name="YSI_FILTERSCRIPT"/>
		</member>
		<member name="M:OnGameModeInit" syntax="OnGameModeInit()">
			<attribute name="public"/>
			<stacksize value="4"/>
			<dependency name="ScriptInit_CallOnCodeInit"/>
			<dependency name="ScriptInit_OnGameModeInit"/>
			<dependency name="ScriptInit_PostInitFuncs_"/>
			<dependency name="ScriptInit_PreInitFuncs_"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<dependency name="YSI_g_sCodeJITing"/>
			<dependency name="false"/>
			<transition keep="true" target="_script_init_fix_state : false"/>  <transition keep="true" target="_ALS : _ALS_go"/>  <transition target="_ALS_go"/>

		</member>
		<member name="M:OnIncomingConnection" syntax="OnIncomingConnection(playerid, ip_address[], port)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="ip_address">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="port">
			</param>
		</member>
		<member name="M:OnJITCompile" syntax="OnJITCompile()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="Debug_Print0"/>
			<dependency name="ScriptInit_CallOnCodeInit"/>
			<dependency name="ScriptInit_OnJITCompile"/>
			<dependency name="YSI_g_sCodeJITed"/>
			<dependency name="YSI_g_sCodeJITing"/>
			<dependency name="true"/>
			<transition target="_ALS_go"/>

		</member>
		<member name="M:OnObjectMoved" syntax="OnObjectMoved(objectid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="objectid">
			</param>
		</member>
		<member name="M:OnPlayerClickMap" syntax="OnPlayerClickMap(playerid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerClickPlayer" syntax="OnPlayerClickPlayer(playerid, clickedplayerid, source)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="clickedplayerid">
			</param>
			<param name="source">
			</param>
		</member>
		<member name="M:OnPlayerClickPlayerTextDraw" syntax="OnPlayerClickPlayerTextDraw(playerid, playertextid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="playertextid">
				<paraminfo>PlayerText </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerClickTextDraw" syntax="OnPlayerClickTextDraw(playerid, clickedid)">
			<attribute name="public"/>
			<stacksize value="158"/>
			<dependency name="GetName"/>
			<dependency name="LOGREG_TD"/>
			<dependency name="SQL"/>
			<dependency name="mysql_format"/>
			<dependency name="mysql_tquery"/>
			<param name="playerid">
			</param>
			<param name="clickedid">
				<paraminfo>Text </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerCommandText" syntax="OnPlayerCommandText(playerid, cmdtext[])">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="cmdtext">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerConnect" syntax="OnPlayerConnect(playerid)">
			<attribute name="public"/>
			<stacksize value="21"/>
			<dependency name="GetPlayerIp"/>
			<dependency name="IPToInt"/>
			<dependency name="YSI_gPlayerIP"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerDeath" syntax="OnPlayerDeath(playerid, killerid, reason)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="killerid">
			</param>
			<param name="reason">
			</param>
		</member>
		<member name="M:OnPlayerDisconnect" syntax="OnPlayerDisconnect(playerid, reason)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<dependency name="YSI_gPlayerIP"/>
			<param name="playerid">
			</param>
			<param name="reason">
			</param>
		</member>
		<member name="M:OnPlayerEditAttachedObject" syntax="OnPlayerEditAttachedObject(playerid, response, index, modelid, boneid, fOffsetX, fOffsetY, fOffsetZ, fRotX, fRotY, fRotZ, fScaleX, fScaleY, fScaleZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="response">
			</param>
			<param name="index">
			</param>
			<param name="modelid">
			</param>
			<param name="boneid">
			</param>
			<param name="fOffsetX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fOffsetY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fOffsetZ">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotZ">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fScaleX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fScaleY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fScaleZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerEditDynamicObject" syntax="OnPlayerEditDynamicObject(playerid, objectid, response, x, y, z, rx, ry, rz)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="objectid">
			</param>
			<param name="response">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rx">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="ry">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rz">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerEditObject" syntax="OnPlayerEditObject(playerid, playerobject, objectid, response, fX, fY, fZ, fRotX, fRotY, fRotZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="playerobject">
			</param>
			<param name="objectid">
			</param>
			<param name="response">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerEnterCheckpoint" syntax="OnPlayerEnterCheckpoint(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerEnterDynamicArea" syntax="OnPlayerEnterDynamicArea(playerid, areaid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="areaid">
			</param>
		</member>
		<member name="M:OnPlayerEnterDynamicCP" syntax="OnPlayerEnterDynamicCP(playerid, checkpointid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="checkpointid">
			</param>
		</member>
		<member name="M:OnPlayerEnterDynamicRaceCP" syntax="OnPlayerEnterDynamicRaceCP(playerid, checkpointid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="checkpointid">
			</param>
		</member>
		<member name="M:OnPlayerEnterRaceCheckpoint" syntax="OnPlayerEnterRaceCheckpoint(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerEnterVehicle" syntax="OnPlayerEnterVehicle(playerid, vehicleid, ispassenger)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="ispassenger">
			</param>
		</member>
		<member name="M:OnPlayerExitVehicle" syntax="OnPlayerExitVehicle(playerid, vehicleid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:OnPlayerExitedMenu" syntax="OnPlayerExitedMenu(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerGiveDamage" syntax="OnPlayerGiveDamage(playerid, damagedid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="damagedid">
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weaponid">
			</param>
			<param name="bodypart">
			</param>
		</member>
		<member name="M:OnPlayerGiveDamageActor" syntax="OnPlayerGiveDamageActor(playerid, damaged_actorid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="damaged_actorid">
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weaponid">
			</param>
			<param name="bodypart">
			</param>
		</member>
		<member name="M:OnPlayerGiveDamageDynamicActor" syntax="OnPlayerGiveDamageDynamicActor(playerid, actorid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="actorid">
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weaponid">
			</param>
			<param name="bodypart">
			</param>
		</member>
		<member name="M:OnPlayerInteriorChange" syntax="OnPlayerInteriorChange(playerid, newinteriorid, oldinteriorid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="newinteriorid">
			</param>
			<param name="oldinteriorid">
			</param>
		</member>
		<member name="M:OnPlayerKeyStateChange" syntax="OnPlayerKeyStateChange(playerid, newkeys, oldkeys)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="newkeys">
			</param>
			<param name="oldkeys">
			</param>
		</member>
		<member name="M:OnPlayerLeaveCheckpoint" syntax="OnPlayerLeaveCheckpoint(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerLeaveDynamicArea" syntax="OnPlayerLeaveDynamicArea(playerid, areaid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="areaid">
			</param>
		</member>
		<member name="M:OnPlayerLeaveDynamicCP" syntax="OnPlayerLeaveDynamicCP(playerid, checkpointid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="checkpointid">
			</param>
		</member>
		<member name="M:OnPlayerLeaveDynamicRaceCP" syntax="OnPlayerLeaveDynamicRaceCP(playerid, checkpointid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="checkpointid">
			</param>
		</member>
		<member name="M:OnPlayerLeaveRaceCheckpoint" syntax="OnPlayerLeaveRaceCheckpoint(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerObjectMoved" syntax="OnPlayerObjectMoved(playerid, objectid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="objectid">
			</param>
		</member>
		<member name="M:OnPlayerPickUpDynamicPickup" syntax="OnPlayerPickUpDynamicPickup(playerid, pickupid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="pickupid">
			</param>
		</member>
		<member name="M:OnPlayerPickUpPickup" syntax="OnPlayerPickUpPickup(playerid, pickupid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="pickupid">
			</param>
		</member>
		<member name="M:OnPlayerRequestClass" syntax="OnPlayerRequestClass(playerid, classid)">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="IgracUlogovan"/>
			<dependency name="SpawnPlayer"/>
			<dependency name="true"/>
			<param name="playerid">
			</param>
			<param name="classid">
			</param>
		</member>
		<member name="M:OnPlayerRequestSpawn" syntax="OnPlayerRequestSpawn(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerSelectDynamicObject" syntax="OnPlayerSelectDynamicObject(playerid, objectid, modelid, x, y, z)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="objectid">
			</param>
			<param name="modelid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerSelectObject" syntax="OnPlayerSelectObject(playerid, type, objectid, modelid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="type">
			</param>
			<param name="objectid">
			</param>
			<param name="modelid">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerSelectedMenuRow" syntax="OnPlayerSelectedMenuRow(playerid, row)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="row">
			</param>
		</member>
		<member name="M:OnPlayerShootDynamicObject" syntax="OnPlayerShootDynamicObject(playerid, weaponid, objectid, x, y, z)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="weaponid">
			</param>
			<param name="objectid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerSpawn" syntax="OnPlayerSpawn(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerStateChange" syntax="OnPlayerStateChange(playerid, newstate, oldstate)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="newstate">
			</param>
			<param name="oldstate">
			</param>
		</member>
		<member name="M:OnPlayerStreamIn" syntax="OnPlayerStreamIn(playerid, forplayerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnPlayerStreamOut" syntax="OnPlayerStreamOut(playerid, forplayerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnPlayerTakeDamage" syntax="OnPlayerTakeDamage(playerid, issuerid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="issuerid">
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weaponid">
			</param>
			<param name="bodypart">
			</param>
		</member>
		<member name="M:OnPlayerText" syntax="OnPlayerText(playerid, text[])">
			<attribute name="public"/>
			<stacksize value="267"/>
			<dependency name="GetName"/>
			<dependency name="IC_CHAT"/>
			<dependency name="ProxDetector"/>
			<dependency name="false"/>
			<dependency name="format"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerUpdate" syntax="OnPlayerUpdate(playerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerWeaponShot" syntax="OnPlayerWeaponShot(playerid, weaponid, hittype, hitid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="weaponid">
			</param>
			<param name="hittype">
			</param>
			<param name="hitid">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnQueryError" syntax="OnQueryError(errorid, error[], callback[], query[], handle)">
			<stacksize value="1"/>
			<param name="errorid">
			</param>
			<param name="error">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="callback">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="query">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="handle">
				<paraminfo>MySQL </paraminfo>
			</param>
		</member>
		<member name="M:OnRconCommand" syntax="OnRconCommand(cmd[])">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:OnRconLoginAttempt" syntax="OnRconLoginAttempt(ip[], password[], success)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="ip">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="password">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="success">
			</param>
		</member>
		<member name="M:OnRuntimeError" syntax="OnRuntimeError(code, &amp;suppress)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="ScriptInit_OnRuntimeError"/>
			<dependency name="YSI_g_sCrashdetect"/>
			<dependency name="true"/>
			<param name="code">
			</param>
			<param name="suppress">
				<paraminfo>bool &amp; </paraminfo>
			</param>
		</member>
		<member name="M:OnTrailerUpdate" syntax="OnTrailerUpdate(playerid, vehicleid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:OnUnoccupiedVehicleUpdate" syntax="OnUnoccupiedVehicleUpdate(vehicleid, playerid, passenger_seat, new_x, new_y, new_z, vel_x, vel_y, vel_z)">
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="playerid">
			</param>
			<param name="passenger_seat">
			</param>
			<param name="new_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="new_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="new_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="vel_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="vel_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="vel_z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnVehicleDamageStatusUpdate" syntax="OnVehicleDamageStatusUpdate(vehicleid, playerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnVehicleDeath" syntax="OnVehicleDeath(vehicleid, killerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="killerid">
			</param>
		</member>
		<member name="M:OnVehicleMod" syntax="OnVehicleMod(playerid, vehicleid, componentid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="componentid">
			</param>
		</member>
		<member name="M:OnVehiclePaintjob" syntax="OnVehiclePaintjob(playerid, vehicleid, paintjobid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="paintjobid">
			</param>
		</member>
		<member name="M:OnVehicleRespray" syntax="OnVehicleRespray(playerid, vehicleid, color1, color2)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
		</member>
		<member name="M:OnVehicleSirenStateChange" syntax="OnVehicleSirenStateChange(playerid, vehicleid, newstate)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="newstate">
			</param>
		</member>
		<member name="M:OnVehicleSpawn" syntax="OnVehicleSpawn(vehicleid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:OnVehicleStreamIn" syntax="OnVehicleStreamIn(vehicleid, forplayerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnVehicleStreamOut" syntax="OnVehicleStreamOut(vehicleid, forplayerid)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:PC_Init" syntax="PC_Init()">
			<attribute name="native"/>
			<referrer name="SSCANF_OnGameModeInit"/>
		</member>
		<member name="M:PC_RegAlias" syntax="PC_RegAlias(cmd[], alias[], ...)">
			<attribute name="native"/>
			<referrer name="pc_alias_aduty"/>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="alias">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
			</param>
		</member>
		<member name="M:PawnCmd_OnGameModeInit" syntax="PawnCmd_OnGameModeInit()">
			<attribute name="public"/>
			<stacksize value="59"/>
			<dependency name="AddPlayerClass"/>
			<dependency name="AllowInteriorWeapons"/>
			<dependency name="DisableInteriorEnterExits"/>
			<dependency name="EnableStuntBonusForAll"/>
			<dependency name="KreirajGlobalneTD"/>
			<dependency name="KreirajMape"/>
			<dependency name="SQL"/>
			<dependency name="SendRconCommand"/>
			<dependency name="SetGameModeText"/>
			<dependency name="ShowPlayerMarkers"/>
			<dependency name="false"/>
			<dependency name="format"/>
			<dependency name="mysql_connect"/>
			<dependency name="mysql_errno"/>
			<dependency name="print"/>
		</member>
		<member name="M:PlayerTextDrawAlignment" syntax="PlayerTextDrawAlignment(playerid, text, alignment)">
			<attribute name="native"/>
			<referrer name="KreirajPlayerTD"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="alignment">
			</param>
		</member>
		<member name="M:PlayerTextDrawBackgroundColor" syntax="PlayerTextDrawBackgroundColor(playerid, text, color)">
			<attribute name="native"/>
			<referrer name="KreirajPlayerTD"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="color">
			</param>
		</member>
		<member name="M:PlayerTextDrawColor" syntax="PlayerTextDrawColor(playerid, text, color)">
			<attribute name="native"/>
			<referrer name="KreirajPlayerTD"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="color">
			</param>
		</member>
		<member name="M:PlayerTextDrawFont" syntax="PlayerTextDrawFont(playerid, text, font)">
			<attribute name="native"/>
			<referrer name="KreirajPlayerTD"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="font">
			</param>
		</member>
		<member name="M:PlayerTextDrawHide" syntax="PlayerTextDrawHide(playerid, text)">
			<attribute name="native"/>
			<referrer name="SQL_ProvjeraAccounta"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
		</member>
		<member name="M:PlayerTextDrawLetterSize" syntax="PlayerTextDrawLetterSize(playerid, text, x, y)">
			<attribute name="native"/>
			<referrer name="KreirajPlayerTD"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:PlayerTextDrawSetOutline" syntax="PlayerTextDrawSetOutline(playerid, text, size)">
			<attribute name="native"/>
			<referrer name="KreirajPlayerTD"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:PlayerTextDrawSetProportional" syntax="PlayerTextDrawSetProportional(playerid, text, set)">
			<attribute name="native"/>
			<referrer name="KreirajPlayerTD"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="set">
			</param>
		</member>
		<member name="M:PlayerTextDrawSetShadow" syntax="PlayerTextDrawSetShadow(playerid, text, size)">
			<attribute name="native"/>
			<referrer name="KreirajPlayerTD"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:PlayerTextDrawSetString" syntax="PlayerTextDrawSetString(playerid, text, string[])">
			<attribute name="native"/>
			<referrer name="ProvjeriBANIP"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:PlayerTextDrawShow" syntax="PlayerTextDrawShow(playerid, text)">
			<attribute name="native"/>
			<referrer name="ProvjeriBANIP"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>PlayerText </paraminfo>
			</param>
		</member>
		<member name="M:Pop" syntax="Pop(&amp;arg)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="false"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<dependency name="true"/>
			<param name="arg">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:PrintAmxHeader" syntax="PrintAmxHeader()">
			<stacksize value="4"/>
			<dependency name="AMX_HDR_AMX_VERSION"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_FILE_VERSION"/>
			<dependency name="AMX_HDR_FLAGS"/>
			<dependency name="AMX_HDR_HEA"/>
			<dependency name="AMX_HDR_LIBRARIES"/>
			<dependency name="AMX_HDR_MAGIC"/>
			<dependency name="AMX_HDR_NAMETABLE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="AMX_HDR_SIZE"/>
			<dependency name="AMX_HDR_STP"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="printf"/>
		</member>
		<member name="M:PrintArg" syntax="PrintArg(n)">
			<stacksize value="1"/>
			<dependency name="print"/>
			<param name="n">
				The numeric parameter position to print.
			</param>
			  <returns>  Prints a string passed as a vararg to the calling function.  </returns> 
		</member>
		<member name="M:ProvjeriBAN" syntax="ProvjeriBAN(playerid)">
			<attribute name="public"/>
			<stacksize value="158"/>
			<dependency name="GetName"/>
			<dependency name="GetPlayerIp"/>
			<dependency name="SQL"/>
			<dependency name="SetTimerEx"/>
			<dependency name="cache_get_row_count"/>
			<dependency name="false"/>
			<dependency name="mysql_format"/>
			<dependency name="mysql_tquery"/>
			<dependency name="va_SendClientMessage"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:ProvjeriBANIP" syntax="ProvjeriBANIP(playerid, IP)">
			<attribute name="public"/>
			<stacksize value="31"/>
			<dependency name="GetName"/>
			<dependency name="KreirajPlayerTD"/>
			<dependency name="LOGREG_TD"/>
			<dependency name="PlayerTextDrawSetString"/>
			<dependency name="PlayerTextDrawShow"/>
			<dependency name="ResetPlayerMoney"/>
			<dependency name="SelectTextDraw"/>
			<dependency name="SetTimerEx"/>
			<dependency name="TextDrawShowForPlayer"/>
			<dependency name="USERNAME_TD"/>
			<dependency name="USERNAME_TD"/>
			<dependency name="cache_get_row_count"/>
			<dependency name="false"/>
			<dependency name="format"/>
			<dependency name="va_SendClientMessage"/>
			<param name="playerid">
			</param>
			<param name="IP">
			</param>
		</member>
		<member name="M:ProvjeriUNBAN" syntax="ProvjeriUNBAN(playerid, IME_IGRACA)">
			<attribute name="public"/>
			<stacksize value="107"/>
			<dependency name="GetName"/>
			<dependency name="SQL"/>
			<dependency name="cache_get_row_count"/>
			<dependency name="mysql_format"/>
			<dependency name="mysql_tquery"/>
			<dependency name="printf"/>
			<dependency name="va_SendClientMessage"/>
			<dependency name="va_SendClientMessageToAll"/>
			<param name="playerid">
			</param>
			<param name="IME_IGRACA">
			</param>
		</member>
		<member name="M:ProxDetector" syntax="ProxDetector(radi, playerid, string[], col1, col2, col3, col4, col5)">
			<attribute name="public"/>
			<stacksize value="16"/>
			<referrer name="OnPlayerText"/>
			<referrer name="pc_cmd_me"/>
			<referrer name="pc_cmd_do"/>
			<referrer name="pc_cmd_b"/>
			<dependency name="operator/(Float:,_:)"/>
			<dependency name="operator-(Float:)"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator&gt;(Float:,Float:)"/>
			<dependency name="operator&lt;(Float:,Float:)"/>
			<dependency name="_:operator=(_no_itertag:)"/>
			<dependency name="GetPlayerPos"/>
			<dependency name="GetPlayerVirtualWorld"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="Iterator@Player"/>
			<dependency name="SendClientMessage"/>
			<param name="radi">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="playerid">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="col1">
			</param>
			<param name="col2">
			</param>
			<param name="col3">
			</param>
			<param name="col4">
			</param>
			<param name="col5">
			</param>
		</member>
		<member name="M:Push" syntax="Push(arg)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="PushString"/>
			<dependency name="false"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<dependency name="true"/>
			<param name="arg">
			</param>
		</member>
		<member name="M:PushString" syntax="PushString(string[])">
			<tagname value="bool"/>
			<stacksize value="5"/>
			<dependency name="Push"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:R@" syntax="R@(buffer[])">
			<stacksize value="6"/>
			<dependency name="setproperty"/>
			<param name="buffer">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Random" syntax="Random(min, max)">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<dependency name="random"/>
			<param name="min">
			</param>
			<param name="max">
				Upper bound.
			</param>
			<param name="minmax">Lower bound, or upper bound when only parameter.</param>    <remarks>  Generate a random float between the given numbers (min &lt;= n &lt; max).  Default minimum is 0 (changes the parameter order).  </remarks> 
		</member>
		<member name="M:RandomFloat" syntax="RandomFloat(min, max, dp)">
			<tagname value="Float"/>
			<stacksize value="5"/>
			<dependency name="operator!=(Float:,Float:)"/>
			<dependency name="operator-(Float:)"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="operator&lt;(Float:,Float:)"/>
			<dependency name="float"/>
			<dependency name="floatpower"/>
			<dependency name="floatround"/>
			<dependency name="random"/>
			<param name="min">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="max">
				<paraminfo>Float </paraminfo>
				Upper bound.
			</param>
			<param name="dp">
				How small to make the differences
			</param>
			<param name="minmax">Lower bound, or upper bound when only parameter.</param>      <remarks>  Generate a random float between the given numbers (min &lt;= n &lt; max).  Default  minimum is 0.0 (changes the parameter order).  </remarks> 
		</member>
		<member name="M:Range" syntax="Range(arr[], num)">
			<stacksize value="4"/>
			<dependency name="cellmax"/>
			<dependency name="cellmin"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical range of the values of the array.  </returns> 
		</member>
		<member name="M:ReadAmxCell" syntax="ReadAmxCell(offset)">
			<stacksize value="5"/>
			<dependency name="GetAmxAddress"/>
			<dependency name="ReadPhysMemoryCell"/>
			<param name="offset">
			</param>
		</member>
		<member name="M:ReadAmxMemory" syntax="ReadAmxMemory(address)">
			<stacksize value="1"/>
			<referrer name="ReadAmxMemoryArray"/>
			<referrer name="GetRawAmxHeader"/>
			<referrer name="NtCompare"/>
			<referrer name="NtCopy"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmGetOperand"/>
			<referrer name="DisasmGetNumOperands"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteDataRowChar"/>
			<referrer name="DisasmWriteDataRowHex"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanRunFastPrescan"/>
			<referrer name="YVA2_FoundCall"/>
			<param name="address">
			</param>
		</member>
		<member name="M:ReadAmxMemoryArray" syntax="ReadAmxMemoryArray(address, values[], size)">
			<stacksize value="5"/>
			<dependency name="ReadAmxMemory"/>
			<param name="address">
			</param>
			<param name="values">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:ReadOpcodeNearThis" syntax="ReadOpcodeNearThis(offset)">
			<tagname value="Opcode"/>
			<stacksize value="2"/>
			<referrer name="HaveToRelocateOpcodes"/>
			<referrer name="RelocateOpcodeNow"/>
			<dependency name="OP_NONE"/>
			<param name="offset">
			</param>
		</member>
		<member name="M:ReadPhysMemory" syntax="ReadPhysMemory(address, dest[], num)">
			<stacksize value="5"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:ReadPhysMemoryCell" syntax="ReadPhysMemoryCell(address)">
			<stacksize value="5"/>
			<referrer name="ReadAmxCell"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
		</member>
		<member name="M:RelToAbs" syntax="RelToAbs(address)">
			<stacksize value="3"/>
			<referrer name="refabs"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetDat"/>
			<param name="address">
			</param>
		</member>
		<member name="M:RelocateOpcode" syntax="RelocateOpcode(opcode)">
			<tagname value="Opcode"/>
			<stacksize value="3"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
			<referrer name="CallNative"/>
			<referrer name="CallNativeByAddress"/>
			<referrer name="AsmEmitOpcode"/>
			<referrer name="AsmEmitPadding"/>
			<referrer name="CodeScanInit"/>
			<referrer name="YVA2_CodeGenShiftCode"/>
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="VA_OnCodeInit"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="InitOpcodeTable"/>
			<dependency name="opcode_table"/>
			<dependency name="opcode_table_is_ready"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:RelocateOpcodeNow" syntax="RelocateOpcodeNow(opcode)">
			<tagname value="Opcode"/>
			<stacksize value="5"/>
			<referrer name="RelocateOpcodeNow"/>
			<referrer name="InitOpcodeTable"/>
			<dependency name="HaveToRelocateOpcodes"/>
			<dependency name="OP_ADD"/>
			<dependency name="OP_ADDR_ALT"/>
			<dependency name="OP_ADDR_PRI"/>
			<dependency name="OP_ADD_C"/>
			<dependency name="OP_ALIGN_ALT"/>
			<dependency name="OP_ALIGN_PRI"/>
			<dependency name="OP_AND"/>
			<dependency name="OP_BOUNDS"/>
			<dependency name="OP_BREAK"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_CMPS"/>
			<dependency name="OP_CONST_ALT"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_DEC"/>
			<dependency name="OP_DEC_ALT"/>
			<dependency name="OP_DEC_I"/>
			<dependency name="OP_DEC_PRI"/>
			<dependency name="OP_DEC_S"/>
			<dependency name="OP_EQ"/>
			<dependency name="OP_EQ_C_ALT"/>
			<dependency name="OP_EQ_C_PRI"/>
			<dependency name="OP_FILL"/>
			<dependency name="OP_GEQ"/>
			<dependency name="OP_GRTR"/>
			<dependency name="OP_HALT"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_IDXADDR"/>
			<dependency name="OP_IDXADDR_B"/>
			<dependency name="OP_INC"/>
			<dependency name="OP_INC_ALT"/>
			<dependency name="OP_INC_I"/>
			<dependency name="OP_INC_PRI"/>
			<dependency name="OP_INC_S"/>
			<dependency name="OP_INVERT"/>
			<dependency name="OP_JEQ"/>
			<dependency name="OP_JGEQ"/>
			<dependency name="OP_JGRTR"/>
			<dependency name="OP_JLEQ"/>
			<dependency name="OP_JLESS"/>
			<dependency name="OP_JNEQ"/>
			<dependency name="OP_JNZ"/>
			<dependency name="OP_JSGEQ"/>
			<dependency name="OP_JSGRTR"/>
			<dependency name="OP_JSLEQ"/>
			<dependency name="OP_JSLESS"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_JZER"/>
			<dependency name="OP_LCTRL"/>
			<dependency name="OP_LEQ"/>
			<dependency name="OP_LESS"/>
			<dependency name="OP_LIDX"/>
			<dependency name="OP_LIDX_B"/>
			<dependency name="OP_LOAD_ALT"/>
			<dependency name="OP_LOAD_I"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_LOAD_S_ALT"/>
			<dependency name="OP_LOAD_S_PRI"/>
			<dependency name="OP_LODB_I"/>
			<dependency name="OP_LREF_ALT"/>
			<dependency name="OP_LREF_PRI"/>
			<dependency name="OP_LREF_S_ALT"/>
			<dependency name="OP_LREF_S_PRI"/>
			<dependency name="OP_MOVE_ALT"/>
			<dependency name="OP_MOVE_PRI"/>
			<dependency name="OP_MOVS"/>
			<dependency name="OP_NEG"/>
			<dependency name="OP_NEQ"/>
			<dependency name="OP_NOP"/>
			<dependency name="OP_NOT"/>
			<dependency name="OP_OR"/>
			<dependency name="OP_POP_ALT"/>
			<dependency name="OP_POP_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_PUSH"/>
			<dependency name="OP_PUSH_ADR"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="OP_PUSH_PRI"/>
			<dependency name="OP_PUSH_S"/>
			<dependency name="OP_RET"/>
			<dependency name="OP_RETN"/>
			<dependency name="OP_SCTRL"/>
			<dependency name="OP_SDIV"/>
			<dependency name="OP_SDIV_ALT"/>
			<dependency name="OP_SGEQ"/>
			<dependency name="OP_SGRTR"/>
			<dependency name="OP_SHL"/>
			<dependency name="OP_SHL_C_ALT"/>
			<dependency name="OP_SHL_C_PRI"/>
			<dependency name="OP_SHR"/>
			<dependency name="OP_SHR_C_ALT"/>
			<dependency name="OP_SHR_C_PRI"/>
			<dependency name="OP_SIGN_ALT"/>
			<dependency name="OP_SIGN_PRI"/>
			<dependency name="OP_SLEQ"/>
			<dependency name="OP_SLESS"/>
			<dependency name="OP_SMUL"/>
			<dependency name="OP_SMUL_C"/>
			<dependency name="OP_SREF_ALT"/>
			<dependency name="OP_SREF_PRI"/>
			<dependency name="OP_SREF_S_ALT"/>
			<dependency name="OP_SREF_S_PRI"/>
			<dependency name="OP_SSHR"/>
			<dependency name="OP_STACK"/>
			<dependency name="OP_STOR_ALT"/>
			<dependency name="OP_STOR_I"/>
			<dependency name="OP_STOR_PRI"/>
			<dependency name="OP_STOR_S_ALT"/>
			<dependency name="OP_STOR_S_PRI"/>
			<dependency name="OP_STRB_I"/>
			<dependency name="OP_SUB"/>
			<dependency name="OP_SUB_ALT"/>
			<dependency name="OP_SWAP_ALT"/>
			<dependency name="OP_SWAP_PRI"/>
			<dependency name="OP_SWITCH"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="OP_UDIV"/>
			<dependency name="OP_UDIV_ALT"/>
			<dependency name="OP_UMUL"/>
			<dependency name="OP_XCHG"/>
			<dependency name="OP_XOR"/>
			<dependency name="OP_ZERO"/>
			<dependency name="OP_ZERO_ALT"/>
			<dependency name="OP_ZERO_PRI"/>
			<dependency name="OP_ZERO_S"/>
			<dependency name="ReadOpcodeNearThis"/>
			<dependency name="debug"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:ResetDeepArray_Entry" syntax="ResetDeepArray_Entry(...)">
			<stacksize value="8"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<param name="...">
			</param>
		</member>
		<member name="M:ResetPlayerMoney" syntax="ResetPlayerMoney(playerid)">
			<attribute name="native"/>
			<referrer name="ProvjeriBANIP"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:ResetStaticAmxHeader" syntax="ResetStaticAmxHeader()">
			<stacksize value="4"/>
			<referrer name="GetAmxHeader"/>
			<referrer name="GetAmxHeaderComponent"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="_Hooks_RepairStub"/>
			<dependency name="GetAmxHeaderNow"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
		</member>
		<member name="M:ResetujVarijable" syntax="ResetujVarijable(playerid)">
			<stacksize value="1"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracInfo"/>
			<dependency name="Level"/>
			<dependency name="Novac"/>
			<dependency name="SQLID"/>
			<dependency name="Skin"/>
			<dependency name="true"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:ResolveJITAddress" syntax="ResolveJITAddress(addr)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:ReturnPlayerName" syntax="ReturnPlayerName(playerid)">
			<stacksize value="29"/>
			<dependency name="GetPlayerName"/>
			<dependency name="ReturnPlayerName"/>
			<param name="playerid">
				Player whose name you want to get.
			</param>
			<summary>  ReturnPlayerName  </summary>    <remarks>  Now uses a global array to avoid repeated function calls.  Actually doesn't  because that causes issues with multiple scripts.  </remarks> 
		</member>
		<member name="M:RunShellcode" syntax="RunShellcode(code_ptr, align)">
			<stacksize value="5"/>
			<referrer name="GetAmxAddress"/>
			<dependency name="SysreqD"/>
			<param name="code_ptr">
			</param>
			<param name="align">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:S@" syntax="S@(v)">
			<stacksize value="6"/>
			<dependency name="Q@"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<dependency name="strunpack"/>
			<param name="v">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:SQL_ProvjeraAccounta" syntax="SQL_ProvjeraAccounta(playerid)">
			<attribute name="public"/>
			<stacksize value="288"/>
			<dependency name="Admin"/>
			<dependency name="GetName"/>
			<dependency name="GetName"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracInfo"/>
			<dependency name="LOGREG_TD"/>
			<dependency name="Level"/>
			<dependency name="Novac"/>
			<dependency name="Password"/>
			<dependency name="PlayerTextDrawHide"/>
			<dependency name="SQLID"/>
			<dependency name="ShowPlayerDialog"/>
			<dependency name="Skin"/>
			<dependency name="TextDrawHideForPlayer"/>
			<dependency name="USERNAME_TD"/>
			<dependency name="USERNAME_TD"/>
			<dependency name="cache_get_row_count"/>
			<dependency name="cache_get_value_name_int"/>
			<dependency name="format"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:SSCANF_Init" syntax="SSCANF_Init(players, invalid, len)">
			<attribute name="native"/>
			<referrer name="Indirection_OnFilterScriptInit"/>
			<referrer name="Indirection_OnGameModeInit"/>
			<param name="players">
			</param>
			<param name="invalid">
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:SSCANF_IsConnected" syntax="SSCANF_IsConnected(playerid)">
			<attribute name="native"/>
			<referrer name="Indirection_OnFilterScriptInit"/>
			<referrer name="Indirection_OnGameModeInit"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:SSCANF_Join" syntax="SSCANF_Join(playerid, name[], npc)">
			<attribute name="native"/>
			<referrer name="Indirection_OnFilterScriptInit"/>
			<referrer name="Indirection_OnGameModeInit"/>
			<referrer name="_y_utils_OnPlayerConnect"/>
			<param name="playerid">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="npc">
			</param>
		</member>
		<member name="M:SSCANF_Leave" syntax="SSCANF_Leave(playerid)">
			<attribute name="native"/>
			<referrer name="_y_utils_OnPlayerDisconnect"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:SSCANF_OnGameModeInit" syntax="SSCANF_OnGameModeInit()">
			<attribute name="public"/>
			<stacksize value="2"/>
			<dependency name="PC_Init"/>
		</member>
		<member name="M:SSCANF_OnPlayerConnect" syntax="SSCANF_OnPlayerConnect(playerid)">
			<attribute name="public"/>
			<stacksize value="108"/>
			<dependency name="GetName"/>
			<dependency name="IgracUlogovan"/>
			<dependency name="OcistiChat"/>
			<dependency name="ResetujVarijable"/>
			<dependency name="SQL"/>
			<dependency name="false"/>
			<dependency name="mysql_format"/>
			<dependency name="mysql_tquery"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:SSCANF_OnPlayerDisconnect" syntax="SSCANF_OnPlayerDisconnect(playerid, reason)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracUlogovan"/>
			<dependency name="SQLID"/>
			<dependency name="false"/>
			<param name="playerid">
			</param>
			<param name="reason">
			</param>
		</member>
		<member name="M:SacuvajNalog" syntax="SacuvajNalog(playerid)">
			<stacksize value="511"/>
			<referrer name="IgracRegistrovan"/>
			<dependency name="Admin"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracUlogovan"/>
			<dependency name="Level"/>
			<dependency name="Novac"/>
			<dependency name="SQL"/>
			<dependency name="SQLID"/>
			<dependency name="Skin"/>
			<dependency name="mysql_format"/>
			<dependency name="mysql_tquery"/>
			<dependency name="true"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:ScriptInit_CallOnCodeInit" syntax="ScriptInit_CallOnCodeInit(jit)">
			<stacksize value="1"/>
			<referrer name="OnJITCompile"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="OnGameModeInit"/>
			<param name="jit">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:ScriptInit_OnCodeInit" syntax="ScriptInit_OnCodeInit()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Debug_SetState"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<remarks>  Does some strange mangling of <c>YSI_FILTERSCRIPT</c> because at one point I  found a compiler bug where the first automata in the script could conflict  with the first variable in the script.  I don't know what triggered it, and  it has never shown up since I messed about with this file to try mangle some  things.  Never the less, if it ever happens again this code might detect it.  Actually, that's less likely now, since that variable is now very unlikely  to be the first in the script ever.  </remarks> 
		</member>
		<member name="M:ScriptInit_OnFilterScriptExit" syntax="ScriptInit_OnFilterScriptExit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="OnFilterScriptExit"/>
		</member>
		<member name="M:ScriptInit_OnFilterScriptInit" syntax="ScriptInit_OnFilterScriptInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="_ALS"/>
			<referrer name="OnFilterScriptInit"/>
			<dependency name="Indirect_Init"/>
		</member>
		<member name="M:ScriptInit_OnGameModeExit" syntax="ScriptInit_OnGameModeExit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="_ALS"/>
			<referrer name="OnGameModeExit"/>
			<dependency name="SQL"/>
			<dependency name="mysql_close"/>
		</member>
		<member name="M:ScriptInit_OnGameModeInit" syntax="ScriptInit_OnGameModeInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="_ALS"/>
			<referrer name="OnGameModeInit"/>
			<dependency name="Indirect_Init"/>
		</member>
		<member name="M:ScriptInit_OnJITCompile" syntax="ScriptInit_OnJITCompile()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="_ALS"/>
			<referrer name="OnJITCompile"/>
			<dependency name="Indirect_Init"/>
		</member>
		<member name="M:ScriptInit_OnRuntimeError" syntax="ScriptInit_OnRuntimeError(code, &amp;suppress)">
			<attribute name="public"/>
			<stacksize value="16"/>
			<automaton name="_ALS"/>
			<referrer name="OnRuntimeError"/>
			<dependency name="AMX_Read"/>
			<dependency name="Hooks_Ordinal"/>
			<dependency name="Hooks_Ordinal"/>
			<dependency name="YSI_g_sActiveHooks"/>
			<dependency name="printf"/>
			<param name="code">
			</param>
			<param name="suppress">
				<paraminfo>bool &amp; </paraminfo>
			</param>
		</member>
		<member name="M:ScriptInit_OnScriptExit" syntax="ScriptInit_OnScriptExit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="OnFilterScriptExit"/>
			<referrer name="OnGameModeExit"/>
		</member>
		<member name="M:ScriptInit_OnScriptInit" syntax="ScriptInit_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="_ALS"/>
			<dependency name="YSIPrint"/>
			<dependency name="YVers_OnScriptInit"/>
		</member>
		<member name="M:ScriptInit_PostExitFuncs_" syntax="ScriptInit_PostExitFuncs_()">
			<stacksize value="9"/>
			<referrer name="OnFilterScriptExit"/>
			<referrer name="OnGameModeExit"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
		</member>
		<member name="M:ScriptInit_PostInitFuncs_" syntax="ScriptInit_PostInitFuncs_()">
			<stacksize value="9"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="OnGameModeInit"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
		</member>
		<member name="M:ScriptInit_PreExitFuncs_" syntax="ScriptInit_PreExitFuncs_()">
			<stacksize value="9"/>
			<referrer name="OnFilterScriptExit"/>
			<referrer name="OnGameModeExit"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
		</member>
		<member name="M:ScriptInit_PreInitFuncs_" syntax="ScriptInit_PreInitFuncs_()">
			<stacksize value="9"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="OnGameModeInit"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
		</member>
		<member name="M:SelectTextDraw" syntax="SelectTextDraw(playerid, hovercolor)">
			<attribute name="native"/>
			<referrer name="ProvjeriBANIP"/>
			<param name="playerid">
			</param>
			<param name="hovercolor">
			</param>
		</member>
		<member name="M:SendClientMessage" syntax="SendClientMessage(playerid, color, message[])">
			<attribute name="native"/>
			<referrer name="va_SendClientMessage"/>
			<referrer name="pc_cmd_me"/>
			<referrer name="pc_cmd_do"/>
			<referrer name="pc_cmd_b"/>
			<referrer name="pc_cmd_aduty"/>
			<referrer name="pc_cmd_kick"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<referrer name="pc_cmd_unban"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="IgracRegistrovan"/>
			<referrer name="OcistiChat"/>
			<referrer name="ProxDetector"/>
			<param name="playerid">
			</param>
			<param name="color">
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SendClientMessageToAll" syntax="SendClientMessageToAll(color, message[])">
			<attribute name="native"/>
			<referrer name="va_SendClientMessageToAll"/>
			<param name="color">
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SendPlayerMessageToAll" syntax="SendPlayerMessageToAll(senderid, message[])">
			<attribute name="native"/>
			<referrer name="va_SendPlayerMessageToAll"/>
			<param name="senderid">
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SendPlayerMessageToPlayer" syntax="SendPlayerMessageToPlayer(playerid, senderid, message[])">
			<attribute name="native"/>
			<referrer name="va_SendPlayerMessageToPlayer"/>
			<param name="playerid">
			</param>
			<param name="senderid">
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SendRconCommand" syntax="SendRconCommand(command[])">
			<attribute name="native"/>
			<referrer name="va_SendRconCommand"/>
			<referrer name="PawnCmd_OnGameModeInit"/>
			<param name="command">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Server_CrashDetectExists" syntax="Server_CrashDetectExists()">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="YSI_g_sCrashdetect"/>
		</member>
		<member name="M:Server_IsFilterscript" syntax="Server_IsFilterscript()">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="YSI_FILTERSCRIPT"/>
		</member>
		<member name="M:Server_IsGameMode" syntax="Server_IsGameMode()">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="YSI_FILTERSCRIPT"/>
		</member>
		<member name="M:Server_JITComplete" syntax="Server_JITComplete()">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="YSI_g_sCodeJITed"/>
		</member>
		<member name="M:Server_JITExists" syntax="Server_JITExists()">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="CGen_OnCodeInit"/>
			<dependency name="YSI_g_sCodeJITing"/>
		</member>
		<member name="M:SetAmxFrame" syntax="SetAmxFrame(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetAmxHeapTop" syntax="SetAmxHeapTop(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetAmxNextInstructionPointer" syntax="SetAmxNextInstructionPointer(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetAmxStackBottom" syntax="SetAmxStackBottom(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetCameraBehindPlayer" syntax="SetCameraBehindPlayer(playerid)">
			<attribute name="native"/>
			<referrer name="OnDialogResponse"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:SetCurrentFramePreviousFrame" syntax="SetCurrentFramePreviousFrame(addr)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFramePreviousFrame"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetCurrentFrameReturn" syntax="SetCurrentFrameReturn(addr)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFrameReturn"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetCurrentParameterCount" syntax="SetCurrentParameterCount(count)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFrameParameterCount"/>
			<param name="count">
			</param>
		</member>
		<member name="M:SetCurrentParameterSize" syntax="SetCurrentParameterSize(size)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFrameParameterSize"/>
			<param name="size">
			</param>
		</member>
		<member name="M:SetDynamicObjectMaterial" syntax="SetDynamicObjectMaterial(objectid, materialindex, modelid, txdname[], texturename[], materialcolor)">
			<attribute name="native"/>
			<referrer name="KreirajMape"/>
			<param name="objectid">
			</param>
			<param name="materialindex">
			</param>
			<param name="modelid">
			</param>
			<param name="txdname">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="texturename">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="materialcolor">
			</param>
		</member>
		<member name="M:SetDynamicObjectMaterialText" syntax="SetDynamicObjectMaterialText(objectid, materialindex, text[], materialsize, fontface[], fontsize, bold, fontcolor, backcolor, textalignment)">
			<attribute name="native"/>
			<referrer name="KreirajMape"/>
			<param name="objectid">
			</param>
			<param name="materialindex">
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="materialsize">
			</param>
			<param name="fontface">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="fontsize">
			</param>
			<param name="bold">
			</param>
			<param name="fontcolor">
			</param>
			<param name="backcolor">
			</param>
			<param name="textalignment">
			</param>
		</member>
		<member name="M:SetFrameLocal" syntax="SetFrameLocal(frm_addr, param, value)">
			<stacksize value="1"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:SetFrameParameter" syntax="SetFrameParameter(frm_addr, param, value, idx)">
			<stacksize value="1"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="value">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:SetFrameParameterCount" syntax="SetFrameParameterCount(frm_addr, count)">
			<stacksize value="5"/>
			<referrer name="SetCurrentParameterCount"/>
			<dependency name="SetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
			<param name="count">
			</param>
		</member>
		<member name="M:SetFrameParameterSize" syntax="SetFrameParameterSize(frm_addr, size)">
			<stacksize value="1"/>
			<referrer name="SetFrameParameterCount"/>
			<referrer name="SetCurrentParameterSize"/>
			<param name="frm_addr">
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:SetFramePreviousFrame" syntax="SetFramePreviousFrame(frm_addr, addr)">
			<stacksize value="1"/>
			<referrer name="SetCurrentFramePreviousFrame"/>
			<param name="frm_addr">
			</param>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetFrameReturn" syntax="SetFrameReturn(frm_addr, addr)">
			<stacksize value="1"/>
			<referrer name="SetCurrentFrameReturn"/>
			<param name="frm_addr">
			</param>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetFrameVariable" syntax="SetFrameVariable(frm_addr, param, value, idx)">
			<stacksize value="1"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="value">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:SetGameModeText" syntax="SetGameModeText(string[])">
			<attribute name="native"/>
			<referrer name="PawnCmd_OnGameModeInit"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SetPlayerArmour" syntax="SetPlayerArmour(playerid, armour)">
			<attribute name="native"/>
			<referrer name="pc_cmd_aduty"/>
			<param name="playerid">
			</param>
			<param name="armour">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:SetPlayerHealth" syntax="SetPlayerHealth(playerid, health)">
			<attribute name="native"/>
			<referrer name="pc_cmd_aduty"/>
			<param name="playerid">
			</param>
			<param name="health">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:SetPlayerScore" syntax="SetPlayerScore(playerid, score)">
			<attribute name="native"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="IgracRegistrovan"/>
			<param name="playerid">
			</param>
			<param name="score">
			</param>
		</member>
		<member name="M:SetPlayerSkin" syntax="SetPlayerSkin(playerid, skinid)">
			<attribute name="native"/>
			<referrer name="pc_cmd_aduty"/>
			<param name="playerid">
			</param>
			<param name="skinid">
			</param>
		</member>
		<member name="M:SetSpawnInfo" syntax="SetSpawnInfo(playerid, team, skin, x, y, z, rotation, weapon1, weapon1_ammo, weapon2, weapon2_ammo, weapon3, weapon3_ammo)">
			<attribute name="native"/>
			<referrer name="IgracRegistrovan"/>
			<param name="playerid">
			</param>
			<param name="team">
			</param>
			<param name="skin">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rotation">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weapon1">
			</param>
			<param name="weapon1_ammo">
			</param>
			<param name="weapon2">
			</param>
			<param name="weapon2_ammo">
			</param>
			<param name="weapon3">
			</param>
			<param name="weapon3_ammo">
			</param>
		</member>
		<member name="M:SetTimerEx" syntax="SetTimerEx(funcname[], interval, repeating, format[], ...)">
			<attribute name="native"/>
			<referrer name="@yH_OnPlayerDisconnect@001"/>
			<referrer name="ProvjeriBAN"/>
			<referrer name="ProvjeriBANIP"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<param name="funcname">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="interval">
			</param>
			<param name="repeating">
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:ShowPlayerDialog" syntax="ShowPlayerDialog(playerid, dialogid, style, caption[], info[], button1[], button2[])">
			<attribute name="native"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="SQL_ProvjeraAccounta"/>
			<param name="playerid">
			</param>
			<param name="dialogid">
			</param>
			<param name="style">
			</param>
			<param name="caption">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="info">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="button1">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="button2">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:ShowPlayerMarkers" syntax="ShowPlayerMarkers(mode)">
			<attribute name="native"/>
			<referrer name="PawnCmd_OnGameModeInit"/>
			<param name="mode">
			</param>
		</member>
		<member name="M:ShuffleDeepArray_Entry" syntax="ShuffleDeepArray_Entry(...)">
			<stacksize value="7"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<dependency name="random"/>
			<param name="...">
			</param>
		</member>
		<member name="M:SkipWhitespace" syntax="SkipWhitespace(str[], pos)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to skip over part of.
			</param>
			<param name="pos">
				The start of the whitespace.
			</param>
			    <returns>  The end of the whitespace.  </returns>  <remarks>  Doesn't skip over NULL terminators.  </remarks> 
		</member>
		<member name="M:SortArrayUsingCompInto_Entry" syntax="SortArrayUsingCompInto_Entry(results[], size, ...)">
			<stacksize value="11"/>
			<dependency name="GetFunctionAddress"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="SORT_IS_PLAYERS"/>
			<dependency name="SortArrayUsingCompInto_QS"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<dependency name="print"/>
			<param name="results">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="...">
			</param>
		</member>
		<member name="M:SortArrayUsingCompInto_QS" syntax="SortArrayUsingCompInto_QS(array, results[], func, left, right)">
			<stacksize value="6"/>
			<referrer name="SortArrayUsingCompInto_Entry"/>
			<dependency name="g_sort_stack"/>
			<param name="array">
			</param>
			<param name="results">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="func">
			</param>
			<param name="left">
			</param>
			<param name="right">
			</param>
		</member>
		<member name="M:SortArrayUsingComparator_Entry" syntax="SortArrayUsingComparator_Entry(size, ...)">
			<stacksize value="9"/>
			<dependency name="GetFunctionAddress"/>
			<dependency name="SortArrayUsingComparator_QS"/>
			<dependency name="print"/>
			<param name="size">
			</param>
			<param name="...">
			</param>
		</member>
		<member name="M:SortArrayUsingComparator_QS" syntax="SortArrayUsingComparator_QS(array, func, left, right)">
			<stacksize value="6"/>
			<referrer name="SortArrayUsingComparator_Entry"/>
			<dependency name="ExchangeArraySlots"/>
			<dependency name="g_sort_stack"/>
			<param name="array">
			</param>
			<param name="func">
			</param>
			<param name="left">
			</param>
			<param name="right">
			</param>
		</member>
		<member name="M:SortDeepArray_Entry" syntax="SortDeepArray_Entry(&amp;cmp1, &amp;cmp2, size, cmp_tag, cmp_string, ignorecase, order, array[][], ...)">
			<stacksize value="6"/>
			<dependency name="_SortDeepArray"/>
			<dependency name="g_sort_cmp_offset"/>
			<dependency name="g_sort_cmp_type"/>
			<dependency name="g_sort_ignorecase"/>
			<dependency name="g_sort_order"/>
			<param name="cmp1">
				<paraminfo> {Float,String,string,_} &amp; </paraminfo>
			</param>
			<param name="cmp2">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="cmp_tag">
			</param>
			<param name="cmp_string">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="order">
				<paraminfo>E_SORT_ORDER </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [][] </paraminfo>
			</param>
			<param name="...">
			</param>
		</member>
		<member name="M:SpawnPlayer" syntax="SpawnPlayer(playerid)">
			<attribute name="native"/>
			<referrer name="OnPlayerRequestClass"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="IgracRegistrovan"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:StrToLower" syntax="StrToLower(str[], len)">
			<stacksize value="5"/>
			<dependency name="tolower"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to convert.
			</param>
			<param name="len">
				How much of the string to convert.
			</param>
			   
		</member>
		<member name="M:StrToUpper" syntax="StrToUpper(str[], len)">
			<stacksize value="5"/>
			<dependency name="toupper"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to convert.
			</param>
			<param name="len">
				How much of the string to convert.
			</param>
			   
		</member>
		<member name="M:Streamer_OnItemStreamIn" syntax="Streamer_OnItemStreamIn(type, id)">
			<stacksize value="1"/>
			<param name="type">
			</param>
			<param name="id">
				<paraminfo> {Text3D,_} </paraminfo>
			</param>
		</member>
		<member name="M:Streamer_OnItemStreamOut" syntax="Streamer_OnItemStreamOut(type, id)">
			<stacksize value="1"/>
			<param name="type">
			</param>
			<param name="id">
				<paraminfo> {Text3D,_} </paraminfo>
			</param>
		</member>
		<member name="M:Streamer_OnPluginError" syntax="Streamer_OnPluginError(error[])">
			<stacksize value="1"/>
			<param name="error">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Strip" syntax="Strip(str[])">
			<stacksize value="9"/>
			<dependency name="memcpy"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to remove whitespace from the start and end of.
			</param>
			 
		</member>
		<member name="M:StripL" syntax="StripL(str[])">
			<stacksize value="9"/>
			<dependency name="memcpy"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to remove whitespace from the start of.
			</param>
			 
		</member>
		<member name="M:StripNL" syntax="StripNL(str[])">
			<stacksize value="4"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to remove whitespace from the end of.
			</param>
			  <remarks>  Updated from old versions, should be more efficient  </remarks> 
		</member>
		<member name="M:Sum" syntax="Sum(arr[], num)">
			<stacksize value="2"/>
			<referrer name="Mean"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need summing.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  All the values in the array added together.  </returns> 
		</member>
		<member name="M:SysreqC" syntax="SysreqC(index, auto_pop)">
			<stacksize value="9"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="index">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:SysreqCN" syntax="SysreqCN(index, args_to_push, auto_pop)">
			<stacksize value="10"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="index">
			</param>
			<param name="args_to_push">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:SysreqD" syntax="SysreqD(address, auto_pop)">
			<stacksize value="9"/>
			<referrer name="RunShellcode"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:SysreqDN" syntax="SysreqDN(address, args_to_push, auto_pop)">
			<stacksize value="10"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="args_to_push">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:T@" syntax="T@(ret[], ...)">
			<stacksize value="8"/>
			<dependency name="YSI_g_sPropEmpty"/>
			<dependency name="YSI_g_sPropVarArg"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<dependency name="setproperty"/>
			<param name="ret">
				<paraminfo> [144] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:TextDrawAlignment" syntax="TextDrawAlignment(text, alignment)">
			<attribute name="native"/>
			<referrer name="KreirajGlobalneTD"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="alignment">
			</param>
		</member>
		<member name="M:TextDrawBackgroundColor" syntax="TextDrawBackgroundColor(text, color)">
			<attribute name="native"/>
			<referrer name="KreirajGlobalneTD"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="color">
			</param>
		</member>
		<member name="M:TextDrawColor" syntax="TextDrawColor(text, color)">
			<attribute name="native"/>
			<referrer name="KreirajGlobalneTD"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="color">
			</param>
		</member>
		<member name="M:TextDrawCreate" syntax="TextDrawCreate(x, y, text[])">
			<tagname value="Text"/>
			<attribute name="native"/>
			<referrer name="va_TextDrawCreate"/>
			<referrer name="KreirajGlobalneTD"/>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:TextDrawFont" syntax="TextDrawFont(text, font)">
			<attribute name="native"/>
			<referrer name="KreirajGlobalneTD"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="font">
			</param>
		</member>
		<member name="M:TextDrawHideForPlayer" syntax="TextDrawHideForPlayer(playerid, text)">
			<attribute name="native"/>
			<referrer name="SQL_ProvjeraAccounta"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
		</member>
		<member name="M:TextDrawLetterSize" syntax="TextDrawLetterSize(text, x, y)">
			<attribute name="native"/>
			<referrer name="KreirajGlobalneTD"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:TextDrawSetOutline" syntax="TextDrawSetOutline(text, size)">
			<attribute name="native"/>
			<referrer name="KreirajGlobalneTD"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:TextDrawSetProportional" syntax="TextDrawSetProportional(text, set)">
			<attribute name="native"/>
			<referrer name="KreirajGlobalneTD"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="set">
			</param>
		</member>
		<member name="M:TextDrawSetSelectable" syntax="TextDrawSetSelectable(text, set)">
			<attribute name="native"/>
			<referrer name="KreirajGlobalneTD"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="set">
			</param>
		</member>
		<member name="M:TextDrawSetShadow" syntax="TextDrawSetShadow(text, size)">
			<attribute name="native"/>
			<referrer name="KreirajGlobalneTD"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:TextDrawShowForPlayer" syntax="TextDrawShowForPlayer(playerid, text)">
			<attribute name="native"/>
			<referrer name="ProvjeriBANIP"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
		</member>
		<member name="M:TextDrawTextSize" syntax="TextDrawTextSize(text, x, y)">
			<attribute name="native"/>
			<referrer name="KreirajGlobalneTD"/>
			<param name="text">
				<paraminfo>Text </paraminfo>
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:ThirdParty_OnCodeInit" syntax="ThirdParty_OnCodeInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="YSI_g_sInitialised"/>
			<dependency name="YVA2_Initalise"/>
		</member>
		<member name="M:ToHexStr" syntax="ToHexStr(x)">
			<stacksize value="15"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteDataRowHex"/>
			<referrer name="DisasmWriteData"/>
			<dependency name="ToHexStr"/>
			<param name="x">
			</param>
		</member>
		<member name="M:ToPrintableAscii" syntax="ToPrintableAscii(c)">
			<stacksize value="4"/>
			<referrer name="DisasmWriteDataRowChar"/>
			<dependency name="IsPrintableAscii"/>
			<param name="c">
			</param>
		</member>
		<member name="M:TogglePlayerSpectating" syntax="TogglePlayerSpectating(playerid, toggle)">
			<attribute name="native"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="IgracRegistrovan"/>
			<param name="playerid">
			</param>
			<param name="toggle">
			</param>
		</member>
		<member name="M:Trim" syntax="Trim(str[], &amp;start, &amp;end)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to trim.
			</param>
			<param name="start">
				<paraminfo> &amp; </paraminfo>
				Start of the substring.
			</param>
			<param name="end">
				<paraminfo> &amp; </paraminfo>
				End of the substring.
			</param>
			      <remarks>  Modifies "start" and "end" to be tight on text in "str".  </remarks> 
		</member>
		<member name="M:UCMP" syntax="UCMP(value, upper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				The unsigned number to compare.
			</param>
			<param name="upper">
				The upper limit.
			</param>
			    <returns>  An unsigned comparison between the two values.  </returns> 
		</member>
		<member name="M:UnrelocateOpcode" syntax="UnrelocateOpcode(opcode)">
			<tagname value="Opcode"/>
			<stacksize value="3"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="CodeScanRunFastPrescan"/>
			<dependency name="InitOpcodeTable"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="opcode_table"/>
			<dependency name="opcode_table_is_ready"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:Utils_PreSort" syntax="Utils_PreSort(arr[], num)">
			<stacksize value="4"/>
			<referrer name="Mode"/>
			<referrer name="Median"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array to sort.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <remarks>  Sorts the array in place.  Uses bubble sort because it is easy and fast for  pre-sorted arrays (which the callers are likely to be).  </remarks> 
		</member>
		<member name="M:VALID_PLAYERID" syntax="VALID_PLAYERID(playerid)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="playerid">
				The player to check.
			</param>
			  <returns>  Is this a valid playerid (NOT, is the player connected).  </returns> 
		</member>
		<member name="M:VA_OnCodeInit" syntax="VA_OnCodeInit()">
			<attribute name="public"/>
			<stacksize value="11"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_Write"/>
			<dependency name="CGen_SetupCodeSpace"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmInit"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="OP_NONE"/>
			<dependency name="OP_NOP"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="YSI_g_sCodeSpace"/>
		</member>
		<member name="M:WriteAmxCell" syntax="WriteAmxCell(offset, value)">
			<stacksize value="6"/>
			<dependency name="GetAmxAddress"/>
			<dependency name="WritePhysMemoryCell"/>
			<param name="offset">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:WriteAmxMemory" syntax="WriteAmxMemory(address, value)">
			<stacksize value="1"/>
			<referrer name="WriteAmxMemoryArray"/>
			<referrer name="HookPublic"/>
			<referrer name="HookNative"/>
			<referrer name="AsmEmitCell"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitPadding"/>
			<param name="address">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:WriteAmxMemoryArray" syntax="WriteAmxMemoryArray(address, values[], size)">
			<stacksize value="6"/>
			<dependency name="WriteAmxMemory"/>
			<param name="address">
			</param>
			<param name="values">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:WritePhysMemory" syntax="WritePhysMemory(address, src[], num)">
			<stacksize value="5"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:WritePhysMemoryCell" syntax="WritePhysMemoryCell(address, what)">
			<stacksize value="5"/>
			<referrer name="WriteAmxCell"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
			<param name="what">
			</param>
		</member>
		<member name="M:X@" syntax="X@(n)">
			<stacksize value="6"/>
			<dependency name="setproperty"/>
			<param name="n">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:YHNPS_Find" syntax="YHNPS_Find(heap, end, value)">
			<stacksize value="7"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="AMX_Read"/>
			<dependency name="cellmin"/>
			<param name="heap">
			</param>
			<param name="end">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:YHNPS_Insert" syntax="YHNPS_Insert(heap, count, value, ptr)">
			<stacksize value="10"/>
			<referrer name="YHNPS_Push"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="cellmax"/>
			<dependency name="rawMemcpy_"/>
			<param name="heap">
			</param>
			<param name="count">
			</param>
			<param name="value">
			</param>
			<param name="ptr">
			</param>
		</member>
		<member name="M:YHNPS_OnCodeInit" syntax="YHNPS_OnCodeInit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<dependency name="YSI_g_sStack"/>
			<dependency name="YSI_g_sStackPtr"/>
			<remarks>  </remarks> 
		</member>
		<member name="M:YHNPS_Push" syntax="YHNPS_Push(heap, &amp;allocated, &amp;nativeCount, &amp;stockCount, base, find, replace)">
			<stacksize value="7"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="GetNativeAddressFromIndex"/>
			<dependency name="HeapAllocCells"/>
			<dependency name="YHNPS_Insert"/>
			<dependency name="cellmax"/>
			<dependency name="max"/>
			<dependency name="rawMemcpy_"/>
			<param name="heap">
			</param>
			<param name="allocated">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="nativeCount">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="stockCount">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="base">
			</param>
			<param name="find">
			</param>
			<param name="replace">
			</param>
		</member>
		<member name="M:YSIPrint" syntax="YSIPrint(string[])">
			<attribute name="native"/>
			<referrer name="ScriptInit_OnScriptInit"/>
			<referrer name="YVers_Callback"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:YSIPrintF" syntax="YSIPrintF(format[], ...)">
			<attribute name="native"/>
			<referrer name="YVers_Callback"/>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:YVA2_CodeGenDeepCleanup" syntax="YVA2_CodeGenDeepCleanup(ctx[], depth, returningString)">
			<stacksize value="5"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitPopPri"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="cellbits"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="depth">
			</param>
			<param name="returningString">
			</param>
		</member>
		<member name="M:YVA2_CodeGenMainCleanup" syntax="YVA2_CodeGenMainCleanup(ctx[])">
			<stacksize value="5"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitAdd"/>
			<dependency name="AsmEmitLctrl"/>
			<dependency name="AsmEmitLoadPri"/>
			<dependency name="AsmEmitPopAlt"/>
			<dependency name="AsmEmitSctrl"/>
			<dependency name="AsmEmitStorPri"/>
			<dependency name="ref"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:YVA2_CodeGenPushSite" syntax="YVA2_CodeGenPushSite(ctx[], pushedBytes, skippedBytes, offset)">
			<stacksize value="7"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitAddrPri"/>
			<dependency name="AsmEmitCallAbs"/>
			<dependency name="AsmEmitHeap"/>
			<dependency name="AsmEmitPushC"/>
			<dependency name="AsmEmitPushPri"/>
			<dependency name="O@A_"/>
			<dependency name="O@V_"/>
			<dependency name="YVA2_DoPush"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="pushedBytes">
			</param>
			<param name="skippedBytes">
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:YVA2_CodeGenPushVariable" syntax="YVA2_CodeGenPushVariable(ctx[], stack)">
			<stacksize value="5"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitPushS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="stack">
			</param>
		</member>
		<member name="M:YVA2_CodeGenShiftCode" syntax="YVA2_CodeGenShiftCode(dest, src, end)">
			<stacksize value="4"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="OP_NOP"/>
			<dependency name="RelocateOpcode"/>
			<param name="dest">
			</param>
			<param name="src">
			</param>
			<param name="end">
			</param>
		</member>
		<member name="M:YVA2_DoPush" syntax="YVA2_DoPush(skippedBytes, pushedBytes, pushRequirements)">
			<stacksize value="1"/>
			<referrer name="YVA2_DummyPush"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<dependency name="memcpy"/>
			<param name="skippedBytes">
			</param>
			<param name="pushedBytes">
			</param>
			<param name="pushRequirements">
			</param>
		</member>
		<member name="M:YVA2_DummyPush" syntax="YVA2_DummyPush(skippedBytes, pushedBytes, pushRequirements, dummy0, dummy1, dummy2, dummy3, dummy4, dummy5)">
			<stacksize value="6"/>
			<referrer name="YVA2_Initalise"/>
			<referrer name="va_CreatePlayerTextDraw"/>
			<referrer name="va_TextDrawCreate"/>
			<referrer name="va_SendClientMessage"/>
			<referrer name="va_SendClientMessageToAll"/>
			<referrer name="va_SendPlayerMessageToPlayer"/>
			<referrer name="va_SendPlayerMessageToAll"/>
			<referrer name="va_GameTextForPlayer"/>
			<referrer name="va_GameTextForAll"/>
			<referrer name="va_print"/>
			<referrer name="va_fprintf"/>
			<referrer name="va_SendRconCommand"/>
			<referrer name="Iter_RandomAdd_InternalC"/>
			<referrer name="Iter_RandomAdd_InternalD"/>
			<referrer name="Iter_RandomRemove_InternalC"/>
			<referrer name="Iter_RandomRemove_InternalD"/>
			<referrer name="Iter_RandomFree_InternalD"/>
			<dependency name="Debug_Print0"/>
			<dependency name="TRUE"/>
			<dependency name="YSI_g_sInitialised"/>
			<dependency name="YVA2_DoPush"/>
			<dependency name="YVA2_Initalise"/>
			<param name="skippedBytes">
			</param>
			<param name="pushedBytes">
			</param>
			<param name="pushRequirements">
			</param>
			<param name="dummy0">
			</param>
			<param name="dummy1">
			</param>
			<param name="dummy2">
			</param>
			<param name="dummy3">
			</param>
			<param name="dummy4">
			</param>
			<param name="dummy5">
			</param>
		</member>
		<member name="M:YVA2_FoundCall" syntax="YVA2_FoundCall(m[])">
			<stacksize value="17"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitHeap"/>
			<dependency name="AsmEmitPushAlt"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="CodeScanGetMatchAddressData"/>
			<dependency name="CodeScanGetMatchDisasm"/>
			<dependency name="CodeScanGetMatchHole"/>
			<dependency name="CodeScanGetMatchLength"/>
			<dependency name="CodeScanGetMatchStack"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_POP_PRI"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="YSI_g_sContexts"/>
			<dependency name="YSI_g_sContexts"/>
			<dependency name="YSI_g_sLength"/>
			<dependency name="YSI_g_sMaxNesting"/>
			<dependency name="YSI_g_sPassthroughNestings"/>
			<dependency name="YSI_g_sSkips"/>
			<dependency name="YSI_g_sStacks"/>
			<dependency name="YVA2_CodeGenDeepCleanup"/>
			<dependency name="YVA2_CodeGenMainCleanup"/>
			<dependency name="YVA2_CodeGenPushSite"/>
			<dependency name="YVA2_CodeGenPushVariable"/>
			<dependency name="YVA2_CodeGenShiftCode"/>
			<dependency name="cellbits"/>
			<dependency name="cellmax"/>
			<dependency name="cellmin"/>
			<param name="m">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:YVA2_FoundPush" syntax="YVA2_FoundPush(m[])">
			<stacksize value="12"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanGetMatchAddress"/>
			<dependency name="CodeScanGetMatchAsm"/>
			<dependency name="CodeScanGetMatchDisasm"/>
			<dependency name="CodeScanGetMatchHole"/>
			<dependency name="CodeScanGetMatchLength"/>
			<dependency name="CodeScanGetMatchStack"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="YSI_g_sContexts"/>
			<dependency name="YSI_g_sContexts"/>
			<dependency name="YSI_g_sInitialised"/>
			<dependency name="YSI_g_sLength"/>
			<dependency name="YSI_g_sMaxNesting"/>
			<dependency name="YSI_g_sPassthroughNestings"/>
			<dependency name="YSI_g_sSkips"/>
			<dependency name="YSI_g_sStacks"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="max"/>
			<param name="m">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:YVA2_Initalise" syntax="YVA2_Initalise()">
			<stacksize value="1139"/>
			<referrer name="YVA2_DummyPush"/>
			<referrer name="ThirdParty_OnCodeInit"/>
			<dependency name="CodeScanAddMatcher"/>
			<dependency name="CodeScanInit"/>
			<dependency name="CodeScanMatcher"/>
			<dependency name="CodeScanMatcherInit_"/>
			<dependency name="CodeScanMatcherPattern_"/>
			<dependency name="CodeScanRunFast"/>
			<dependency name="CodeScanner"/>
			<dependency name="O@A_"/>
			<dependency name="O@V_"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_MOVE_PRI"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="OP_PUSH_PRI"/>
			<dependency name="OP_STACK"/>
			<dependency name="OP_STOR_I"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_ZERO_PRI"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="YVA2_FoundCall"/>
			<dependency name="YVA2_FoundPush"/>
			<dependency name="gCodeScanCallback_match"/>
		</member>
		<member name="M:YVers_Callback" syntax="YVers_Callback(index, code, data[])">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="YSIPrint"/>
			<dependency name="YSIPrintF"/>
			<dependency name="false"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<param name="index">
			</param>
			<param name="code">
			</param>
			<param name="data">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:YVers_OnScriptInit" syntax="YVers_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="ScriptInit_OnScriptInit"/>
		</member>
		<member name="M:Z@" syntax="Z@(v)">
			<stacksize value="7"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<param name="v">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:_@Iter_ActorDo" syntax="_@Iter_ActorDo(add, actorid)">
			<stacksize value="7"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
			<dependency name="D@"/>
			<dependency name="F@"/>
			<dependency name="I@"/>
			<dependency name="J@"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="actorid">
			</param>
		</member>
		<member name="M:_@Iter_VehicleDo" syntax="_@Iter_VehicleDo(add, vehicleid)">
			<stacksize value="7"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
			<dependency name="D@"/>
			<dependency name="F@"/>
			<dependency name="I@"/>
			<dependency name="J@"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:_@_y_cgen_@_0" syntax="_@_y_cgen_@_0()">
			<attribute name="public"/>
			<stacksize value="55"/>
			<dependency name="CGEN"/>
		</member>
		<member name="M:_@_y_cgen_@_1" syntax="_@_y_cgen_@_1()">
			<attribute name="public"/>
			<stacksize value="1"/>
		</member>
		<member name="M:_@yH" syntax="_@yH(&amp;a, &amp;b, &amp;c, &amp;d, &amp;e, &amp;f)">
			<stacksize value="1"/>
			<referrer name="Hooks_GenerateContinue"/>
			<param name="a">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="b">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="c">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="d">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="e">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="f">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:_Hooks_AddReplacement" syntax="_Hooks_AddReplacement(longName[], shortName[])">
			<stacksize value="5"/>
			<referrer name="@_yHCheckpoint"/>
			<referrer name="@_yHContainer"/>
			<referrer name="@_yHInventory"/>
			<referrer name="@_yHDynamic"/>
			<referrer name="@_yHTextDraw"/>
			<referrer name="@_yHUpdate"/>
			<referrer name="@_yHObject"/>
			<referrer name="@_yHCommand"/>
			<referrer name="@_yHDynamicCP"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_LONG"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MIN"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_SHORT"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsLongOrder"/>
			<dependency name="YSI_g_sReplacementsShortOrder"/>
			<dependency name="strcat"/>
			<dependency name="strlen"/>
			<param name="longName">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="shortName">
				<paraminfo> [] </paraminfo>
			</param>
			<remarks>  Call the main hook run code, then advance the ALS chain.  </remarks> 
		</member>
		<member name="M:_Hooks_RepairStub" syntax="_Hooks_RepairStub()">
			<stacksize value="5"/>
			<referrer name="_Hooks_RepairStubFS"/>
			<referrer name="_Hooks_RepairStubGM"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="YSI_g_sInitFSIdx"/>
			<dependency name="YSI_g_sInitFSRep"/>
			<dependency name="YSI_g_sInitGMIdx"/>
			<dependency name="YSI_g_sInitGMRep"/>
			<dependency name="YSI_g_sInitPublicDiff"/>
			<dependency name="YSI_g_sSortedOnce"/>
			<dependency name="true"/>
		</member>
		<member name="M:_Hooks_RepairStubFS" syntax="_Hooks_RepairStubFS()">
			<stacksize value="3"/>
			<referrer name="Hooks_RepairJITInit"/>
			<dependency name="YSI_g_sInitFSPtr"/>
			<dependency name="_Hooks_RepairStub"/>
		</member>
		<member name="M:_Hooks_RepairStubGM" syntax="_Hooks_RepairStubGM()">
			<stacksize value="3"/>
			<referrer name="Hooks_RepairJITInit"/>
			<dependency name="YSI_g_sInitGMPtr"/>
			<dependency name="_Hooks_RepairStub"/>
		</member>
		<member name="M:_PreHook_IncludeStates" syntax="_PreHook_IncludeStates()">
			<stacksize value="1"/>
			<automaton name="_ALS"/>
		</member>
		<member name="M:_ScriptInit_FixState" syntax="_ScriptInit_FixState()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_script_init_fix_state"/>
		</member>
		<member name="M:_SortDeepArray" syntax="_SortDeepArray(array[][], left, right)">
			<stacksize value="11"/>
			<referrer name="SortDeepArray_Entry"/>
			<dependency name="operator!=(Float:,Float:)"/>
			<dependency name="operator&gt;(Float:,Float:)"/>
			<dependency name="operator&lt;(Float:,Float:)"/>
			<dependency name="ExchangeArraySlots"/>
			<dependency name="SORT_ASC"/>
			<dependency name="g_sort_cmp_offset"/>
			<dependency name="g_sort_cmp_type"/>
			<dependency name="g_sort_ignorecase"/>
			<dependency name="g_sort_order"/>
			<dependency name="g_sort_stack"/>
			<dependency name="strcmp"/>
			<param name="array">
				<paraminfo> [][] </paraminfo>
			</param>
			<param name="left">
			</param>
			<param name="right">
			</param>
		</member>
		<member name="M:_YSI_ConstMod" syntax="_YSI_ConstMod(&amp;var, val)">
			<stacksize value="1"/>
			<param name="var">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="val">
			</param>
		</member>
		<member name="M:__CompilerSecondPass" syntax="__CompilerSecondPass()">
			<stacksize value="1"/>
		</member>
		<member name="M:__TU" syntax="__TU(t, iters)">
			<stacksize value="27"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="__TU"/>
			<dependency name="float"/>
			<dependency name="format"/>
			<param name="t">
				The time in ms.
			</param>
			<param name="iters">
				The number of iterations completed in this time.
			</param>
			    <remarks>  Formats and returns a string representing the time taken for one iteration,  given the time required for many iterations.  This attempts to format the  number using a reasonable fraction of a second.  </remarks> 
		</member>
		<member name="M:_yH@" syntax="_yH@(compressedFormat)">
			<stacksize value="34"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitCallAbs"/>
			<dependency name="AsmEmitHeap"/>
			<dependency name="AsmEmitLctrl"/>
			<dependency name="AsmEmitLoadPri"/>
			<dependency name="AsmEmitMovs"/>
			<dependency name="AsmEmitPadding"/>
			<dependency name="AsmEmitPopAlt"/>
			<dependency name="AsmEmitPopPri"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitPush"/>
			<dependency name="AsmEmitPushAlt"/>
			<dependency name="AsmEmitPushC"/>
			<dependency name="AsmEmitPushPri"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="AsmEmitStorAlt"/>
			<dependency name="AsmEmitSysreqC"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="DisasmInit"/>
			<dependency name="DisasmNext"/>
			<dependency name="GetCurrentFrameReturn"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="YSI_g_sNPSBaseCall"/>
			<dependency name="YSI_g_sNPSReplace"/>
			<dependency name="YSI_g_sNPSStack"/>
			<dependency name="YSI_g_sNPSTrampoline"/>
			<dependency name="YSI_g_sTempRet"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="ref"/>
			<param name="compressedFormat">
			</param>
		</member>
		<member name="M:_y_utils_OnPlayerConnect" syntax="_y_utils_OnPlayerConnect(playerid)">
			<attribute name="public"/>
			<stacksize value="30"/>
			<dependency name="GetPlayerName"/>
			<dependency name="IsPlayerNPC"/>
			<dependency name="SSCANF_Join"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:_y_utils_OnPlayerDisconnect" syntax="_y_utils_OnPlayerDisconnect(playerid, reason)">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="SSCANF_Leave"/>
			<param name="playerid">
			</param>
			<param name="reason">
			</param>
		</member>
		<member name="M:argderef" syntax="argderef(n)">
			<stacksize value="1"/>
			<dependency name="argderef"/>
			<param name="n">
			</param>
		</member>
		<member name="M:argref" syntax="argref(n)">
			<stacksize value="1"/>
			<param name="n">
			</param>
		</member>
		<member name="M:bernstein" syntax="bernstein(string[])">
			<stacksize value="4"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				the string to hash.
			</param>
			  <returns>  the bernstein hash of the input string  </returns>  <remarks>  This is a 32bit hash system so is not very secure, however we're only  using this as a string enumerator to uniquely identify strings easilly  and allow for a binary search of strings based on the hash of their name.  crc32, then jenkins were originally used however this is far faster, if a  little collision prone, but we're checking the strings manually anyway.  This doesn't matter as it would be done regardless of hash method, so this  doesn't need to be accounted for.  Speed is all that matters with at   least a bit of non collision (the number of strings we're dealing with,  this should have none-few collisions).  I modified it slightly from the original code pasted by aru, to code  closer to the code <a href="http://www.burtleburtle.net/bob/hash/doobs.html" />  and to work with PAWN (and shaved 0.2s off the time for one call :D).  Uber reduced version (just for fun):  b(s[]){new h=-1,i,j;while((j=s[i++]))h=h*33+j;return h;}  Update: Contrary to what I said above this is also used to identify colour  strings for the updated text system involving file based styling and this  is not checked for collisions as it's unimportant.  But this doesn't affect  the function at all, I just mentioned it here for "interest".  </remarks> 
		</member>
		<member name="M:binstr" syntax="binstr(string[])">
			<stacksize value="3"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				String to try convert to a boolean.
			</param>
			  <returns>  bool: passed boolean.  </returns>  <remarks>  This takes a value in 0110101 (boolean) format and returns it as a  regular value.  </remarks> 
		</member>
		<member name="M:boolstr" syntax="boolstr(string[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="strcmp"/>
			<dependency name="true"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				String to try convert to a boolean.
			</param>
			  <returns>  bool: passed boolean.  </returns>  <remarks>  This can take a number of ways of representing booleans - 0, false and  nothing there.  Anything not one of those things (false is not case  sensitive) is assumed true.  </remarks> 
		</member>
		<member name="M:cache_get_field_count" syntax="cache_get_field_count(&amp;destination)">
			<attribute name="native"/>
			<referrer name="cache_num_fields"/>
			<param name="destination">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:cache_get_result_count" syntax="cache_get_result_count(&amp;destination)">
			<attribute name="native"/>
			<referrer name="cache_num_results"/>
			<param name="destination">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:cache_get_row_count" syntax="cache_get_row_count(&amp;destination)">
			<attribute name="native"/>
			<referrer name="cache_num_rows"/>
			<referrer name="ProvjeriBAN"/>
			<referrer name="ProvjeriBANIP"/>
			<referrer name="ProvjeriUNBAN"/>
			<referrer name="SQL_ProvjeraAccounta"/>
			<param name="destination">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:cache_get_value_index_bool" syntax="cache_get_value_index_bool(row_idx, column_idx, &amp;destination)">
			<stacksize value="5"/>
			<dependency name="cache_get_value_index_int"/>
			<param name="row_idx">
			</param>
			<param name="column_idx">
			</param>
			<param name="destination">
				<paraminfo>bool &amp; </paraminfo>
			</param>
		</member>
		<member name="M:cache_get_value_index_int" syntax="cache_get_value_index_int(row_idx, column_idx, &amp;destination)">
			<attribute name="native"/>
			<referrer name="cache_get_value_index_bool"/>
			<param name="row_idx">
			</param>
			<param name="column_idx">
			</param>
			<param name="destination">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:cache_get_value_name_bool" syntax="cache_get_value_name_bool(row_idx, column_name[], &amp;destination)">
			<stacksize value="5"/>
			<dependency name="cache_get_value_name_int"/>
			<param name="row_idx">
			</param>
			<param name="column_name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="destination">
				<paraminfo>bool &amp; </paraminfo>
			</param>
		</member>
		<member name="M:cache_get_value_name_int" syntax="cache_get_value_name_int(row_idx, column_name[], &amp;destination)">
			<attribute name="native"/>
			<referrer name="cache_get_value_name_bool"/>
			<referrer name="SQL_ProvjeraAccounta"/>
			<param name="row_idx">
			</param>
			<param name="column_name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="destination">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:cache_insert_id" syntax="cache_insert_id()">
			<attribute name="native"/>
			<referrer name="IgracRegistrovan"/>
		</member>
		<member name="M:cache_num_fields" syntax="cache_num_fields()">
			<stacksize value="4"/>
			<dependency name="cache_get_field_count"/>
		</member>
		<member name="M:cache_num_results" syntax="cache_num_results()">
			<stacksize value="4"/>
			<dependency name="cache_get_result_count"/>
		</member>
		<member name="M:cache_num_rows" syntax="cache_num_rows()">
			<stacksize value="4"/>
			<dependency name="cache_get_row_count"/>
		</member>
		<member name="M:ceildiv" syntax="ceildiv(numerator, denominator)">
			<stacksize value="1"/>
			<param name="numerator">
				The top of the division.
			</param>
			<param name="denominator">
				The bottom of the division.
			</param>
			    <returns>  (numerator / denominator) rounded up.  </returns>  <remarks>  Normal integer division ALWAYS rounds down - this always rounds up.  </remarks> 
		</member>
		<member name="M:chrfind" syntax="chrfind(needle, haystack[], start)">
			<stacksize value="3"/>
			<dependency name="strlen"/>
			<param name="needle">
				The character to find.
			</param>
			<param name="haystack">
				<paraminfo> [] </paraminfo>
				The string to find it in.
			</param>
			<param name="start">
				The offset to start from.
			</param>
			      <returns>  Fail - -1, Success - pos  </returns> 
		</member>
		<member name="M:chrfindp" syntax="chrfindp(needle, haystack[], start)">
			<stacksize value="1"/>
			<param name="needle">
				The character to find.
			</param>
			<param name="haystack">
				<paraminfo> [] </paraminfo>
				The string to find it in.
			</param>
			<param name="start">
				The offset to start from.
			</param>
			      <returns>  Fail - -1, Success - pos  </returns>  <remarks>  Like <symbolref name="chrfind" />, but with no upper-bounds check on  <paramref name="start" />.  </remarks> 
		</member>
		<member name="M:copy_1" syntax="copy_1(&amp;dest, source[], start)">
			<stacksize value="1"/>
			<referrer name="GetAmxHeaderNow"/>
			<param name="dest">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:copy_2" syntax="copy_2(&amp;dest, source[], start)">
			<stacksize value="1"/>
			<referrer name="GetAmxHeaderNow"/>
			<param name="dest">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:copy_4" syntax="copy_4(&amp;dest, source[], start)">
			<stacksize value="1"/>
			<referrer name="GetAmxHeaderNow"/>
			<param name="dest">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:deref" syntax="deref(v)">
			<stacksize value="1"/>
			<dependency name="deref"/>
			<param name="v">
			</param>
		</member>
		<member name="M:endofline" syntax="endofline(line[], pos)">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<dependency name="strlen"/>
			<param name="line">
				<paraminfo> [] </paraminfo>
				String to check.
			</param>
			<param name="pos">
				Postion to start from.
			</param>
			    <remarks>  Checks if the current point in a line is the end of non-whitespace data.  </remarks> 
		</member>
		<member name="M:fclose" syntax="fclose(handle)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="y_profile_WTF"/>
			<referrer name="ftouch"/>
			<referrer name="DisasmWrite"/>
			<param name="handle">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:fexist" syntax="fexist(pattern[])">
			<attribute name="native"/>
			<referrer name="y_profile_WTF"/>
			<referrer name="ftouch"/>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:float" syntax="float(value)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator*(Float:,_:)"/>
			<referrer name="operator/(Float:,_:)"/>
			<referrer name="operator/(_:,Float:)"/>
			<referrer name="operator+(Float:,_:)"/>
			<referrer name="operator-(Float:,_:)"/>
			<referrer name="operator-(_:,Float:)"/>
			<referrer name="operator==(Float:,_:)"/>
			<referrer name="operator!=(Float:,_:)"/>
			<referrer name="operator&gt;(Float:,_:)"/>
			<referrer name="operator&gt;(_:,Float:)"/>
			<referrer name="operator&gt;=(Float:,_:)"/>
			<referrer name="operator&gt;=(_:,Float:)"/>
			<referrer name="operator&lt;(Float:,_:)"/>
			<referrer name="operator&lt;(_:,Float:)"/>
			<referrer name="operator&lt;=(Float:,_:)"/>
			<referrer name="operator&lt;=(_:,Float:)"/>
			<referrer name="__TU"/>
			<referrer name="RandomFloat"/>
			<param name="value">
			</param>
		</member>
		<member name="M:floatadd" syntax="floatadd(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator+(Float:,_:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatcmp" syntax="floatcmp(oper1, oper2)">
			<attribute name="native"/>
			<referrer name="operator==(Float:,Float:)"/>
			<referrer name="operator==(Float:,_:)"/>
			<referrer name="operator!=(Float:,Float:)"/>
			<referrer name="operator!=(Float:,_:)"/>
			<referrer name="operator&gt;(Float:,Float:)"/>
			<referrer name="operator&gt;(Float:,_:)"/>
			<referrer name="operator&gt;(_:,Float:)"/>
			<referrer name="operator&gt;=(Float:,Float:)"/>
			<referrer name="operator&gt;=(Float:,_:)"/>
			<referrer name="operator&gt;=(_:,Float:)"/>
			<referrer name="operator&lt;(Float:,Float:)"/>
			<referrer name="operator&lt;(Float:,_:)"/>
			<referrer name="operator&lt;(_:,Float:)"/>
			<referrer name="operator&lt;=(Float:,Float:)"/>
			<referrer name="operator&lt;=(Float:,_:)"/>
			<referrer name="operator&lt;=(_:,Float:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatdiv" syntax="floatdiv(dividend, divisor)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator/(Float:,_:)"/>
			<referrer name="operator/(_:,Float:)"/>
			<param name="dividend">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="divisor">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatmul" syntax="floatmul(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator*(Float:,_:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatpower" syntax="floatpower(value, exponent)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="RandomFloat"/>
			<param name="value">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="exponent">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatround" syntax="floatround(value, method)">
			<attribute name="native"/>
			<referrer name="RandomFloat"/>
			<param name="value">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="method">
				<paraminfo>floatround_method </paraminfo>
			</param>
		</member>
		<member name="M:floatsub" syntax="floatsub(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator-(Float:,_:)"/>
			<referrer name="operator-(_:,Float:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floordiv" syntax="floordiv(numerator, denominator)">
			<stacksize value="1"/>
			<param name="numerator">
				The top of the division.
			</param>
			<param name="denominator">
				The bottom of the division.
			</param>
			<summary>  floordiv(numerator, denominator);  </summary>      <returns>  (numerator / denominator) rounded down.  </returns>  <remarks>  Normal integer division ALWAYS rounds down - this also always rounds down,  making it a little pointless, but also more explicit in function.  </remarks> 
		</member>
		<member name="M:fopen" syntax="fopen(name[], mode)">
			<tagname value="File"/>
			<attribute name="native"/>
			<referrer name="y_profile_WTF"/>
			<referrer name="ftouch"/>
			<referrer name="DisasmWrite"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="mode">
				<paraminfo>filemode </paraminfo>
			</param>
		</member>
		<member name="M:format" syntax="format(output[], len, format[], ...)">
			<attribute name="native"/>
			<referrer name="Debug_PrintArray"/>
			<referrer name="__TU"/>
			<referrer name="va_return"/>
			<referrer name="PawnCmd_OnGameModeInit"/>
			<referrer name="ProvjeriBANIP"/>
			<referrer name="OnPlayerText"/>
			<referrer name="pc_cmd_me"/>
			<referrer name="pc_cmd_do"/>
			<referrer name="pc_cmd_b"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="SQL_ProvjeraAccounta"/>
			<param name="output">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:ftouch" syntax="ftouch(filename[])">
			<stacksize value="5"/>
			<dependency name="fclose"/>
			<dependency name="fexist"/>
			<dependency name="fopen"/>
			<dependency name="io_write"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
				The file to "touch".
			</param>
			<summary>  ftouch(filename);  </summary>    <returns>  0 - File already exists.  1 - File was created.  -1 - File was not created.  </returns>  <remarks>  This "touches" a file in the Unix sense of creating it but not opening or  editing it in any way.  </remarks> 
		</member>
		<member name="M:funcidx" syntax="funcidx(name[])">
			<attribute name="native"/>
			<referrer name="GetFunctionAddress"/>
			<referrer name="Indirect_Call"/>
			<referrer name="Indirect_Callstring"/>
			<referrer name="Indirect_Callvoid"/>
			<referrer name="Indirect_Array"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="CGen_OnCodeInit"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:fwrite" syntax="fwrite(handle, string[])">
			<attribute name="native"/>
			<referrer name="y_profile_WTF"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteDataRowChar"/>
			<referrer name="DisasmWriteDataRowHex"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="va_fprintf"/>
			<param name="handle">
				<paraminfo>File </paraminfo>
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:getarg" syntax="getarg(arg, index)">
			<attribute name="native"/>
			<referrer name="L@"/>
			<referrer name="T@"/>
			<referrer name="AsmEmitInstruction"/>
			<referrer name="CodeScanMatcherPattern_"/>
			<referrer name="ShuffleDeepArray_Entry"/>
			<referrer name="ResetDeepArray_Entry"/>
			<referrer name="SortArrayUsingCompInto_Entry"/>
			<param name="arg">
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:getdate" syntax="getdate(&amp;year, &amp;month, &amp;day)">
			<attribute name="native"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<param name="year">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="month">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="day">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:getproperty" syntax="getproperty(id, name[], value, string[])">
			<attribute name="native"/>
			<referrer name="C@"/>
			<referrer name="D@"/>
			<referrer name="S@"/>
			<referrer name="Z@"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:gettime" syntax="gettime(&amp;hour, &amp;minute, &amp;second)">
			<attribute name="native"/>
			<referrer name="y_profile_WTF"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<param name="hour">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="minute">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="second">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:hexstr" syntax="hexstr(string[])">
			<stacksize value="4"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				String to convert to a number.
			</param>
			  <returns>  value of the passed hex string.  </returns>  <remarks>  Now stops on invalid characters.  </remarks> 
		</member>
		<member name="M:iseven" syntax="iseven(value)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				Value to check if is even.
			</param>
			 
		</member>
		<member name="M:ishex" syntax="ishex(str[])">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to check.
			</param>
			  <returns>  true/false.  </returns> 
		</member>
		<member name="M:isnull" syntax="isnull(str[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to check if is null.
			</param>
			  <remarks>  Uses a new shorter and branchless method, which also works with offsets so  this is valid:  <code>  new str[32]; isnull(str[5]);  </code>  </remarks> 
		</member>
		<member name="M:isnumeric" syntax="isnumeric(str[])">
			<stacksize value="2"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to check
			</param>
			  <remarks>  Checks if a given string is numeric.  </remarks> 
		</member>
		<member name="M:isodd" syntax="isodd(value)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				Value to check if is odd.
			</param>
			 
		</member>
		<member name="M:iterfunc" syntax="iterfunc(params)">
			<stacksize value="1"/>
			<param name="params">
				The iterator function's parameters.
			</param>
			  <remarks>  Used to declare a special iterator function.  Examples:  <code>  iterfunc stock OnlyZero(cur)                                                    <br />  {                                                                               <br /><indent />  if (cur == -1)                                                              <br /><indent /><indent />  return 0;                                                               <br /><indent />  return -1;                                                                  <br />  }                                                                               <br />  </code>  <code>  iterfunc stock AlsoOnlyZero[cellmin](cur)                                       <br />  {                                                                               <br /><indent />  if (cur == cellmin)                                                         <br /><indent /><indent />  return 0;                                                               <br /><indent />  return cellmin;                                                             <br />  }                                                                               <br />  </code>  <code>  iterfunc stock OneToTen[cellmin](cur)                                           <br />  {                                                                               <br /><indent />  if (cur == cellmin)                                                         <br /><indent /><indent />  return 1;                                                               <br /><indent />  if (cur == 10)                                                              <br /><indent /><indent />  return cellmin;                                                         <br /><indent />  return cur + 1;                                                             <br />  }                                                                               <br />  </code>  <code>  iterfunc stock OneToN(cur, n)                                                   <br />  {                                                                               <br /><indent />  if (n &lt; 1)                                                               <br /><indent /><indent />  return -1;                                                              <br /><indent />  if (cur == -1)                                                              <br /><indent /><indent />  return 1;                                                               <br /><indent />  if (cur == n)                                                               <br /><indent /><indent />  return -1;                                                              <br /><indent />  return cur + 1;                                                             <br />  }                                                                               <br />  </code>  </remarks> 
		</member>
		<member name="M:main" syntax="main()">
			<attribute name="entry"/>
			<stacksize value="4"/>
			<dependency name="print"/>
			<dependency name="printf"/>
		</member>
		<member name="M:max" syntax="max(value1, value2)">
			<attribute name="native"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="YHNPS_Push"/>
			<param name="value1">
			</param>
			<param name="value2">
			</param>
		</member>
		<member name="M:memcmp" syntax="memcmp(arr1[], arr2[], count)">
			<stacksize value="3"/>
			<param name="arr1">
				<paraminfo> [] </paraminfo>
				First array to compare.
			</param>
			<param name="arr2">
				<paraminfo> [] </paraminfo>
				Second array to compare.
			</param>
			<param name="count">
				How many cells to compare.
			</param>
			      <returns>  The difference (0 if the same).  </returns> 
		</member>
		<member name="M:memcpy" syntax="memcpy(dest[], source[], index, numbytes, maxlength)">
			<attribute name="native"/>
			<referrer name="StripL"/>
			<referrer name="Strip"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="Indirect_Array"/>
			<referrer name="YVA2_DoPush"/>
			<referrer name="Iter_Init_Internal"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_YieldReturn"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="index">
			</param>
			<param name="numbytes">
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:memset" syntax="memset(arr[], val, size)">
			<stacksize value="7"/>
			<dependency name="rawMemset"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				Array or address to set to a value.
			</param>
			<param name="val">
			</param>
			<param name="size">
			</param>
			  <param name="iValue">What to set the cells to.</param>  <param name="iSize">Number of cells to fill.</param>  <remarks>  Based on code by Slice:  <a href="http://forum.sa-mp.com/showthread.php?p=1606781#post1606781" />  Modified to use binary flags instead of a loop.  "memset" takes an array, the size of the array, and a value to fill it with  and sets the whole array to that value.  "rawmemset" is similar, but takes an AMX data segment address instead and  the size is in bytes, not cells.  However, the size must still be a multiple  of 4.  </remarks> 
		</member>
		<member name="M:min" syntax="min(value1, value2)">
			<attribute name="native"/>
			<referrer name="Base64Decode"/>
			<referrer name="DoLevenshteinDistance"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="CodeScanAddJumpTarget"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<param name="value1">
			</param>
			<param name="value2">
			</param>
		</member>
		<member name="M:mysql_close" syntax="mysql_close(handle)">
			<attribute name="native"/>
			<referrer name="ScriptInit_OnGameModeExit"/>
			<param name="handle">
				<paraminfo>MySQL </paraminfo>
			</param>
		</member>
		<member name="M:mysql_connect" syntax="mysql_connect(host[], user[], password[], database[], option_id)">
			<tagname value="MySQL"/>
			<attribute name="native"/>
			<referrer name="PawnCmd_OnGameModeInit"/>
			<param name="host">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="user">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="password">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="database">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="option_id">
				<paraminfo>MySQLOpt </paraminfo>
			</param>
		</member>
		<member name="M:mysql_errno" syntax="mysql_errno(handle)">
			<attribute name="native"/>
			<referrer name="PawnCmd_OnGameModeInit"/>
			<param name="handle">
				<paraminfo>MySQL </paraminfo>
			</param>
		</member>
		<member name="M:mysql_format" syntax="mysql_format(handle, output[], max_len, format[], ...)">
			<attribute name="native"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
			<referrer name="ProvjeriBAN"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<referrer name="pc_cmd_unban"/>
			<referrer name="ProvjeriUNBAN"/>
			<referrer name="OnPlayerClickTextDraw"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="SacuvajNalog"/>
			<param name="handle">
				<paraminfo>MySQL </paraminfo>
			</param>
			<param name="output">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="max_len">
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:mysql_tquery" syntax="mysql_tquery(handle, query[], callback[], format[], ...)">
			<attribute name="native"/>
			<referrer name="SSCANF_OnPlayerConnect"/>
			<referrer name="ProvjeriBAN"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<referrer name="pc_cmd_unban"/>
			<referrer name="ProvjeriUNBAN"/>
			<referrer name="OnPlayerClickTextDraw"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="SacuvajNalog"/>
			<param name="handle">
				<paraminfo>MySQL </paraminfo>
			</param>
			<param name="query">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="callback">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:numargs" syntax="numargs()">
			<attribute name="native"/>
			<referrer name="L@"/>
			<referrer name="T@"/>
			<referrer name="ref"/>
			<referrer name="AsmEmitInstruction"/>
			<referrer name="CodeScanMatcherPattern_"/>
			<referrer name="refabs"/>
			<referrer name="ShuffleDeepArray_Entry"/>
			<referrer name="ResetDeepArray_Entry"/>
			<referrer name="SortArrayUsingCompInto_Entry"/>
			<referrer name="Indirect_Ref_"/>
			<referrer name="Indirect_Ptr_"/>
			<referrer name="Indirect_DeRef_"/>
			<referrer name="Indirect_DePtr_"/>
		</member>
		<member name="M:pc_alias_aduty" syntax="pc_alias_aduty()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="PC_RegAlias"/>
		</member>
		<member name="M:pc_cmd_aduty" syntax="pc_cmd_aduty(playerid)">
			<attribute name="public"/>
			<stacksize value="7"/>
			<dependency name="Float:operator=(_:)"/>
			<dependency name="Admin"/>
			<dependency name="AdminDuty"/>
			<dependency name="GetName"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracUlogovan"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SetPlayerArmour"/>
			<dependency name="SetPlayerHealth"/>
			<dependency name="SetPlayerSkin"/>
			<dependency name="Skin"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<dependency name="va_SendClientMessageToAll"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:pc_cmd_b" syntax="pc_cmd_b(playerid, params[])">
			<attribute name="public"/>
			<stacksize value="347"/>
			<dependency name="GetName"/>
			<dependency name="ProxDetector"/>
			<dependency name="SendClientMessage"/>
			<dependency name="format"/>
			<dependency name="sscanf"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:pc_cmd_ban" syntax="pc_cmd_ban(playerid, params[])">
			<attribute name="public"/>
			<stacksize value="323"/>
			<dependency name="Admin"/>
			<dependency name="AdminDuty"/>
			<dependency name="GetName"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracUlogovan"/>
			<dependency name="SQL"/>
			<dependency name="SQLID"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SetTimerEx"/>
			<dependency name="false"/>
			<dependency name="format"/>
			<dependency name="getdate"/>
			<dependency name="gettime"/>
			<dependency name="mysql_format"/>
			<dependency name="mysql_tquery"/>
			<dependency name="printf"/>
			<dependency name="sscanf"/>
			<dependency name="true"/>
			<dependency name="va_SendClientMessage"/>
			<dependency name="va_SendClientMessageToAll"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:pc_cmd_banip" syntax="pc_cmd_banip(playerid, params[])">
			<attribute name="public"/>
			<stacksize value="374"/>
			<dependency name="Admin"/>
			<dependency name="AdminDuty"/>
			<dependency name="GetName"/>
			<dependency name="GetPlayerIp"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracUlogovan"/>
			<dependency name="SQL"/>
			<dependency name="SQLID"/>
			<dependency name="SendClientMessage"/>
			<dependency name="SetTimerEx"/>
			<dependency name="false"/>
			<dependency name="format"/>
			<dependency name="getdate"/>
			<dependency name="gettime"/>
			<dependency name="mysql_format"/>
			<dependency name="mysql_tquery"/>
			<dependency name="printf"/>
			<dependency name="sscanf"/>
			<dependency name="true"/>
			<dependency name="va_SendClientMessage"/>
			<dependency name="va_SendClientMessageToAll"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:pc_cmd_do" syntax="pc_cmd_do(playerid, params[])">
			<attribute name="public"/>
			<stacksize value="347"/>
			<dependency name="GetName"/>
			<dependency name="ProxDetector"/>
			<dependency name="SendClientMessage"/>
			<dependency name="format"/>
			<dependency name="sscanf"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:pc_cmd_kick" syntax="pc_cmd_kick(playerid, params[])">
			<attribute name="public"/>
			<stacksize value="23"/>
			<dependency name="Admin"/>
			<dependency name="AdminDuty"/>
			<dependency name="GetName"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracUlogovan"/>
			<dependency name="Kick"/>
			<dependency name="SendClientMessage"/>
			<dependency name="false"/>
			<dependency name="printf"/>
			<dependency name="sscanf"/>
			<dependency name="true"/>
			<dependency name="va_SendClientMessage"/>
			<dependency name="va_SendClientMessageToAll"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:pc_cmd_me" syntax="pc_cmd_me(playerid, params[])">
			<attribute name="public"/>
			<stacksize value="347"/>
			<dependency name="GetName"/>
			<dependency name="ProxDetector"/>
			<dependency name="SendClientMessage"/>
			<dependency name="format"/>
			<dependency name="sscanf"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:pc_cmd_unban" syntax="pc_cmd_unban(playerid, params[])">
			<attribute name="public"/>
			<stacksize value="132"/>
			<dependency name="Admin"/>
			<dependency name="AdminDuty"/>
			<dependency name="IgracInfo"/>
			<dependency name="IgracUlogovan"/>
			<dependency name="SQL"/>
			<dependency name="SendClientMessage"/>
			<dependency name="false"/>
			<dependency name="mysql_format"/>
			<dependency name="mysql_tquery"/>
			<dependency name="sscanf"/>
			<dependency name="true"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:print" syntax="print(string[])">
			<attribute name="native"/>
			<referrer name="PrintArg"/>
			<referrer name="SortArrayUsingComparator_Entry"/>
			<referrer name="SortArrayUsingCompInto_Entry"/>
			<referrer name="va_print"/>
			<referrer name="main"/>
			<referrer name="PawnCmd_OnGameModeInit"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:printf" syntax="printf(format[], ...)">
			<attribute name="native"/>
			<referrer name="Debug_Print0"/>
			<referrer name="AMX_DumpHeader"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="ScriptInit_OnRuntimeError"/>
			<referrer name="main"/>
			<referrer name="pc_cmd_kick"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<referrer name="ProvjeriUNBAN"/>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:random" syntax="random(max)">
			<attribute name="native"/>
			<referrer name="Random"/>
			<referrer name="RandomFloat"/>
			<referrer name="ShuffleDeepArray_Entry"/>
			<referrer name="Iter_Random_Internal"/>
			<referrer name="Iter_RandomFree_InternalC"/>
			<referrer name="Iter_Func@Random"/>
			<param name="max">
			</param>
		</member>
		<member name="M:rawMemcpy_" syntax="rawMemcpy_(dest, src, index, numbytes, maxlength)">
			<attribute name="native"/>
			<referrer name="YHNPS_Insert"/>
			<referrer name="YHNPS_Push"/>
			<param name="dest">
				Destination address.
			</param>
			<param name="src">
				Source data.
			</param>
			<param name="index">
			</param>
			<param name="numbytes">
				Number of bytes to copy.
			</param>
			<param name="maxlength">
			</param>
			<summary>  rawMemcpy  </summary>        <remarks>  Like memcpy, but takes addresses instead of arrays.  Also far less secure  because it doesn't check the destination size - it just assumes it is large  enough.  </remarks> 
		</member>
		<member name="M:rawMemset" syntax="rawMemset(iAddress, iValue, iSize)">
			<stacksize value="1"/>
			<referrer name="memset"/>
			<param name="iAddress">
				Array or address to set to a value.
			</param>
			<param name="iValue">
				What to set the cells to.
			</param>
			<param name="iSize">
				Number of cells to fill.
			</param>
			      <remarks>  Based on code by Slice:  <a href="http://forum.sa-mp.com/showthread.php?p=1606781#post1606781" />  Modified to use binary flags instead of a loop.  "memset" takes an array, the size of the array, and a value to fill it with  and sets the whole array to that value.  "rawmemset" is similar, but takes an AMX data segment address instead and  the size is in bytes, not cells.  However, the size must still be a multiple  of 4.  </remarks> 
		</member>
		<member name="M:ref" syntax="ref(...)">
			<stacksize value="2"/>
			<referrer name="AsmRaiseError"/>
			<referrer name="AsmInit"/>
			<referrer name="CodeScanAddMatcher"/>
			<referrer name="AddressofResolve"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="numargs"/>
			<param name="...">
			</param>
		</member>
		<member name="M:refabs" syntax="refabs(...)">
			<stacksize value="5"/>
			<referrer name="GetAmxAddress"/>
			<dependency name="RelToAbs"/>
			<dependency name="numargs"/>
			<param name="...">
			</param>
		</member>
		<member name="M:returnstringarg" syntax="returnstringarg(idx)">
			<stacksize value="145"/>
			<dependency name="returnstringarg"/>
			<dependency name="strcat"/>
			<param name="idx">
				Index of the string in the parameters.
			</param>
			  <returns>  string  </returns>  <remarks>  Is passed the result of getarg, which will be the address of a string (in  theory) and uses that for DMA to get the string.  </remarks> 
		</member>
		<member name="M:setarg" syntax="setarg(arg, index, value)">
			<attribute name="native"/>
			<referrer name="C@"/>
			<referrer name="D@"/>
			<referrer name="Iter_Clear_InternalC"/>
			<param name="arg">
			</param>
			<param name="index">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:setproperty" syntax="setproperty(id, name[], value, string[])">
			<attribute name="native"/>
			<referrer name="C@"/>
			<referrer name="D@"/>
			<referrer name="L@"/>
			<referrer name="T@"/>
			<referrer name="S@"/>
			<referrer name="X@"/>
			<referrer name="E@"/>
			<referrer name="Z@"/>
			<referrer name="R@"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:sscanf" syntax="sscanf(data[], format[], ...)">
			<attribute name="native"/>
			<referrer name="pc_cmd_me"/>
			<referrer name="pc_cmd_do"/>
			<referrer name="pc_cmd_b"/>
			<referrer name="pc_cmd_kick"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<referrer name="pc_cmd_unban"/>
			<param name="data">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:sscanf_vehicle" syntax="sscanf_vehicle(string[])">
			<attribute name="public"/>
			<stacksize value="6"/>
			<dependency name="strcmp"/>
			<dependency name="strval"/>
			<dependency name="true"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:sscanf_weapon" syntax="sscanf_weapon(string[])">
			<attribute name="public"/>
			<stacksize value="6"/>
			<dependency name="strcmp"/>
			<dependency name="strval"/>
			<dependency name="true"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:strcat" syntax="strcat(dest[], source[], maxlength)">
			<attribute name="native"/>
			<referrer name="returnstringarg"/>
			<referrer name="DisasmGetInsnName"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanGetMatchName"/>
			<referrer name="Indirect_Tag"/>
			<referrer name="va_getstring"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_Ordinal"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:strcmp" syntax="strcmp(string1[], string2[], ignorecase, length)">
			<attribute name="native"/>
			<referrer name="YVers_Callback"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetName"/>
			<referrer name="boolstr"/>
			<referrer name="LevenshteinDistance"/>
			<referrer name="_SortDeepArray"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="sscanf_weapon"/>
			<referrer name="sscanf_vehicle"/>
			<param name="string1">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="string2">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="length">
			</param>
		</member>
		<member name="M:strcpy" syntax="strcpy(dest[], src[], len)">
			<stacksize value="1"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
				Destination string.
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
				Source string.
			</param>
			<param name="len">
				(Implicit) maximum length of the destination.
			</param>
			     
		</member>
		<member name="M:strcpy_undefined__" syntax="strcpy_undefined__()">
			<stacksize value="1"/>
		</member>
		<member name="M:strdel" syntax="strdel(string[], start, end)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_IsolateName"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="end">
			</param>
		</member>
		<member name="M:strfind" syntax="strfind(string[], sub[], ignorecase, pos)">
			<attribute name="native"/>
			<referrer name="YVers_Callback"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetName"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_IsolateName"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="sub">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="pos">
			</param>
		</member>
		<member name="M:strins" syntax="strins(string[], substr[], pos, maxlength)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="substr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="pos">
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:strlen" syntax="strlen(string[])">
			<attribute name="native"/>
			<referrer name="StripNL"/>
			<referrer name="StripL"/>
			<referrer name="Strip"/>
			<referrer name="endofline"/>
			<referrer name="chrfind"/>
			<referrer name="unpack"/>
			<referrer name="Base64Decode"/>
			<referrer name="LevenshteinDistance"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="va_strlen"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="udb_hash"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:strpack" syntax="strpack(dest[], source[], maxlength)">
			<attribute name="native"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:strunpack" syntax="strunpack(dest[], source[], maxlength)">
			<attribute name="native"/>
			<referrer name="AMX_DumpHeader"/>
			<referrer name="C@"/>
			<referrer name="S@"/>
			<referrer name="unpack"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:strval" syntax="strval(string[])">
			<attribute name="native"/>
			<referrer name="IPToInt"/>
			<referrer name="sscanf_weapon"/>
			<referrer name="sscanf_vehicle"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:swapchars" syntax="swapchars(c)">
			<attribute name="native"/>
			<referrer name="AMX_ReadString"/>
			<referrer name="Cell_ReverseBits"/>
			<referrer name="Cell_ReverseNibbles"/>
			<referrer name="Cell_ReverseBytes"/>
			<param name="c">
			</param>
		</member>
		<member name="M:tolower" syntax="tolower(c)">
			<attribute name="native"/>
			<referrer name="StrToLower"/>
			<param name="c">
			</param>
		</member>
		<member name="M:toupper" syntax="toupper(c)">
			<attribute name="native"/>
			<referrer name="StrToUpper"/>
			<param name="c">
			</param>
		</member>
		<member name="M:u@" syntax="u@(u[])">
			<stacksize value="1"/>
			<param name="u">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:udb_hash" syntax="udb_hash(buf[])">
			<stacksize value="5"/>
			<referrer name="OnDialogResponse"/>
			<dependency name="strlen"/>
			<param name="buf">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:unpack" syntax="unpack(str[])">
			<stacksize value="149"/>
			<referrer name="Hooks_IsolateName"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<dependency name="unpack"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to unpack
			</param>
			  <returns>  unpacked string  </returns>  <remarks>  Mainly used for debugging.  </remarks> 
		</member>
		<member name="M:va_CreatePlayerTextDraw" syntax="va_CreatePlayerTextDraw(playerid, x, y, fmat[], ...)">
			<tagname value="PlayerText"/>
			<stacksize value="160"/>
			<dependency name="CreatePlayerTextDraw"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="playerid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_GameTextForAll" syntax="va_GameTextForAll(fmat[], time, style, ...)">
			<stacksize value="157"/>
			<dependency name="GameTextForAll"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="style">
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_GameTextForPlayer" syntax="va_GameTextForPlayer(playerid, fmat[], time, style, ...)">
			<stacksize value="158"/>
			<dependency name="GameTextForPlayer"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="playerid">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="style">
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendClientMessage" syntax="va_SendClientMessage(playerid, colour, fmat[], ...)">
			<stacksize value="159"/>
			<referrer name="ProvjeriBAN"/>
			<referrer name="ProvjeriBANIP"/>
			<referrer name="pc_cmd_kick"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<referrer name="ProvjeriUNBAN"/>
			<referrer name="OnDialogResponse"/>
			<referrer name="IgracRegistrovan"/>
			<dependency name="SendClientMessage"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="playerid">
			</param>
			<param name="colour">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendClientMessageToAll" syntax="va_SendClientMessageToAll(colour, fmat[], ...)">
			<stacksize value="158"/>
			<referrer name="pc_cmd_aduty"/>
			<referrer name="pc_cmd_kick"/>
			<referrer name="pc_cmd_ban"/>
			<referrer name="pc_cmd_banip"/>
			<referrer name="ProvjeriUNBAN"/>
			<dependency name="SendClientMessageToAll"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="colour">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendPlayerMessageToAll" syntax="va_SendPlayerMessageToAll(senderid, fmat[], ...)">
			<stacksize value="158"/>
			<dependency name="SendPlayerMessageToAll"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="senderid">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendPlayerMessageToPlayer" syntax="va_SendPlayerMessageToPlayer(playerid, senderid, fmat[], ...)">
			<stacksize value="159"/>
			<dependency name="SendPlayerMessageToPlayer"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="playerid">
			</param>
			<param name="senderid">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendRconCommand" syntax="va_SendRconCommand(command[], ...)">
			<stacksize value="157"/>
			<dependency name="SendRconCommand"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="command">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_TextDrawCreate" syntax="va_TextDrawCreate(x, y, fmat[], ...)">
			<tagname value="Text"/>
			<stacksize value="159"/>
			<dependency name="TextDrawCreate"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_formatex" syntax="va_formatex(output[], size, fmat[], STATIC_ARGS)">
			<stacksize value="1"/>
			<param name="output">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="STATIC_ARGS">
				<paraminfo>va_ </paraminfo>
			</param>
		</member>
		<member name="M:va_fprintf" syntax="va_fprintf(fhnd, fmat[], ...)">
			<stacksize value="158"/>
			<referrer name="y_profile_WTF"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="fwrite"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="fhnd">
				<paraminfo>File </paraminfo>
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_getstring" syntax="va_getstring(dest[], arg, len)">
			<stacksize value="1"/>
			<dependency name="strcat"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="arg">
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:va_print" syntax="va_print(fmat[], ...)">
			<stacksize value="157"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="print"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_return" syntax="va_return(fmat[], ...)">
			<stacksize value="145"/>
			<referrer name="va_CreatePlayerTextDraw"/>
			<referrer name="va_TextDrawCreate"/>
			<referrer name="va_SendClientMessage"/>
			<referrer name="va_SendClientMessageToAll"/>
			<referrer name="va_SendPlayerMessageToPlayer"/>
			<referrer name="va_SendPlayerMessageToAll"/>
			<referrer name="va_GameTextForPlayer"/>
			<referrer name="va_GameTextForAll"/>
			<referrer name="va_print"/>
			<referrer name="va_fprintf"/>
			<referrer name="va_SendRconCommand"/>
			<dependency name="format"/>
			<dependency name="va_return"/>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
				String format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				Parameters.
			</param>
			    <returns>  Formatted string.  </returns>  <remarks>  Just wraps `format` and returns a string instead.  Has extra code to ensure that it works correct on the old compiler.  </remarks> 
		</member>
		<member name="M:va_strlen" syntax="va_strlen(arg)">
			<stacksize value="1"/>
			<dependency name="strlen"/>
			<param name="arg">
			</param>
		</member>
		<member name="M:valstr" syntax="valstr(dest[], value, pack)">
			<attribute name="native"/>
			<referrer name="Hooks_Ordinal"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
			</param>
			<param name="pack">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:y_profile_WTF" syntax="y_profile_WTF(name[], timings[], iters, size)">
			<stacksize value="11"/>
			<dependency name="Debug_Print0"/>
			<dependency name="fclose"/>
			<dependency name="fexist"/>
			<dependency name="fopen"/>
			<dependency name="fwrite"/>
			<dependency name="gettime"/>
			<dependency name="io_append"/>
			<dependency name="io_write"/>
			<dependency name="va_fprintf"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The name of the profile.
			</param>
			<param name="timings">
				<paraminfo> [] </paraminfo>
				The raw profiling results.
			</param>
			<param name="iters">
				The number of iterations per run.
			</param>
			<param name="size">
				The number of repeats.
			</param>
			        <remarks>  "WTF" here stands for "Write To File".  The output looks like:  <code>  timestamp,runs,repeats,results (ms)  1546082820,10,1000000,122,121,121,120,121,121,121,119,119,121  1546082822,10,1000000,123,124,123,123,121,121,121,120,122,122  </code>  The timestamp is the unix timestamp at which the line was WRITTEN, not the  time at which the profilings started or ended.  "runs" is the number of times the whole profile was repeated.  "repeats" is the number of times the code was run for each repeat.  "results" are the total times for each repeat, in milliseconds.  The time  for an individual piece of code is <c>result[n] / repeats</c>.  This is  equivalent to:  <code>  for (new i = 0; i != runs; ++i)  {  start = GetTickCount();  for (new i = 0; i != repeats; ++i)  {  USER_CODE_HERE();  }  end = GetTickCount();  WriteToFile(end - start);  }  </code>  The repeats help to time very short pieces of code.  The runs help to  average.  The console reports average results (mean, mode, median, range).  Thus the even more accurate result for a single iteration would be:  <c>sum(results) / (runs * repeats)</c>.  </remarks> 
		</member>

	</members>
</doc>
